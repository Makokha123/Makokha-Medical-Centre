from __future__ import annotations
import os

# Socket.IO async backend selection.
#
# IMPORTANT: Avoid unconditional eventlet monkey-patching in production.
# On some platforms/configurations (e.g. Gunicorn preload + Eventlet on newer
# Python versions), monkey_patch() can leak into the Gunicorn arbiter and crash
# with: "do not call blocking functions from the mainloop".
#
# Default behavior:
# - Render (production): threading (stable; falls back to polling if websockets unavailable)
# - Local/dev: threading
#
# To force eventlet explicitly, set: SOCKETIO_ASYNC_MODE=eventlet
_socketio_async_mode = (os.getenv('SOCKETIO_ASYNC_MODE') or '').strip().lower()
if not _socketio_async_mode:
    # If Gunicorn is explicitly using the Eventlet worker, match it.
    # This must happen BEFORE importing Flask/Werkzeug/SQLAlchemy.
    _gunicorn_cmd = (os.getenv('GUNICORN_CMD_ARGS') or '').lower()
    _using_gunicorn_eventlet = ('-k eventlet' in _gunicorn_cmd) or ('--worker-class eventlet' in _gunicorn_cmd) or ('worker_class=eventlet' in _gunicorn_cmd)
    _socketio_async_mode = 'eventlet' if _using_gunicorn_eventlet else 'threading'

if _socketio_async_mode == 'eventlet':
    try:
        import eventlet
        # Avoid patching `os` so Gunicorn arbiter pipes don't become green.
        eventlet.monkey_patch(os=False)
    except Exception:
        # If eventlet is unavailable or fails to patch, continue without it.
        _socketio_async_mode = 'threading'
from logging.handlers import RotatingFileHandler
from operator import and_
from sqlalchemy import MetaData, Table
import calendar
import csv
import io
import threading
from threading import Thread
from flask_migrate import Migrate
import time
from flask import Flask, abort, Blueprint, make_response, render_template, request, redirect, send_from_directory, url_for, flash, session, jsonify, send_file, Response
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user
import openai
import httpx
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedelta, date, timezone

# Global timezone used across the app and scheduler.
# Prefer stdlib ZoneInfo; fall back gracefully.
try:
    from zoneinfo import ZoneInfo

    EAT = ZoneInfo("Africa/Nairobi")
except Exception:
    try:
        from pytz import timezone as pytz_timezone

        EAT = pytz_timezone("Africa/Nairobi")
    except Exception:
        # Last-resort fixed-offset EAT (UTC+3)
        EAT = timezone(timedelta(hours=3))

def get_eat_now():
    """Get current time in EAT (Africa/Nairobi)."""
    return datetime.now(EAT)

def get_eat_today():
    """Get current date in EAT (Africa/Nairobi)."""
    return datetime.now(EAT).date()

from sqlalchemy import create_engine, func, literal
from sqlalchemy import case
from sqlalchemy.ext.hybrid import hybrid_property
from config import Config 
import random
import string
from flask import jsonify, request, current_app
from sqlalchemy import or_
from flask_migrate import Migrate
import json
from werkzeug.utils import secure_filename
import os 
from dotenv import load_dotenv
from flask import send_file
import tempfile
import secrets
import imaplib
import email
from botocore.exceptions import ClientError
from cryptography.fernet import Fernet
import boto3 
import uuid
from datetime import datetime, timezone, timedelta
import zipfile
import hashlib
from sqlalchemy import text
import base64
from apscheduler.schedulers.background import BackgroundScheduler
from openai import OpenAI, APITimeoutError, APIError, APIConnectionError
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import logging
from sqlalchemy.exc import OperationalError, DBAPIError, IntegrityError
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP
from functools import wraps
from itsdangerous import URLSafeTimedSerializer
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
from flask_wtf.csrf import CSRFProtect, generate_csrf
from itsdangerous import URLSafeTimedSerializer
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired, Email, EqualTo, Length
from sqlalchemy import event, text as sa_text
from sqlalchemy import inspect as sa_inspect
import uuid as _uuid
import re
from markupsafe import Markup, escape
from utils.encryption import EncryptionUtils
import bleach

# Try to import CSSSanitizer, but continue without it if not available
try:
    from bleach.css_sanitizer import CSSSanitizer
    HAS_CSS_SANITIZER = True
except ImportError:
    HAS_CSS_SANITIZER = False

from time import monotonic

import html as html_lib

from utils.encrypted_type import EncryptedType
from utils.stamp_signature import generate_rubber_stamp, generate_digital_signature
from utils.whatsapp_meta import normalize_msisdn, send_document, send_text, WhatsAppConfigError
from utils.whatsapp_settings_store import load_whatsapp_settings, save_whatsapp_settings, mask_token

import base64
from io import BytesIO

try:
    from reportlab.lib.pagesizes import letter
    from reportlab.lib.units import mm
    from reportlab.lib import colors
    from reportlab.lib.utils import ImageReader
    from reportlab.pdfgen import canvas as rl_canvas
    _REPORTLAB_AVAILABLE = True
except Exception:
    _REPORTLAB_AVAILABLE = False

from typing import Optional

# Load environment variables from .env for local/dev runs (debugger, python app.py).
# This is a no-op if variables are already set in the process environment.
load_dotenv()
from pathlib import Path

# Initialize Flask app
app = Flask(__name__)

def nl2br(value):
    """Converts newlines to <br> tags, ensuring the input is escaped."""
    if not value:
        return ""
    # Escape the input to prevent XSS, then convert newlines
    escaped_value = escape(value)
    return Markup(escaped_value.replace('\\n', '<br>\\n'))

def format_eat_time(dt, fmt='%Y-%m-%d %H:%M'):
    """Format a datetime to EAT (East Africa Time) zone."""
    if not dt:
        return ''
    try:
        # If datetime is naive, assume it's already in EAT
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=EAT)
        else:
            # Convert to EAT if it has timezone info
            dt = dt.astimezone(EAT)
        return dt.strftime(fmt)
    except Exception as e:
        app.logger.error(f"Error formatting time: {e}")
        return str(dt)

app.jinja_env.filters['nl2br'] = nl2br
app.jinja_env.filters['eat_time'] = format_eat_time



# Production configuration for Render
if os.environ.get('RENDER'):
    # Production settings
    app.config.update(
        DEBUG=False,
        TESTING=False,
        PREFERRED_URL_SCHEME='https'
    )
    
    # Setup logging for production
    if not os.path.exists('logs'):
        os.mkdir('logs')
    
    file_handler = RotatingFileHandler('logs/clinic.log', maxBytes=10240, backupCount=10)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'
    ))
    file_handler.setLevel(logging.INFO)
    app.logger.addHandler(file_handler)
    app.logger.setLevel(logging.INFO)
    app.logger.info('Clinic Management System starting in production mode')
else:
    # Development settings
    app.config.update(
        DEBUG=True,
        TESTING=True,
        PREFERRED_URL_SCHEME='http'
    )
    app.logger.setLevel(logging.DEBUG)
    app.logger.info('Clinic Management System starting in development mode')

app.config.from_object('config.Config')

# Override cookie security settings for development (HTTP)
if not os.environ.get('RENDER'):
    app.config['SESSION_COOKIE_SECURE'] = False
    app.config['REMEMBER_COOKIE_SECURE'] = False
    app.logger.info('Session cookies set to non-secure for development (HTTP)')

Config.init_fernet(app)
EncryptionUtils.init_fernet(app)

# Initialize Socket.IO for real-time communication
from flask_socketio import SocketIO

# Use configured async mode (default: threading).
async_mode = _socketio_async_mode
_socketio_message_queue = (os.getenv('SOCKETIO_MESSAGE_QUEUE') or os.getenv('REDIS_URL') or '').strip()

socketio_kwargs = dict(
    cors_allowed_origins="*",
    async_mode=async_mode,
    logger=True,
    engineio_logger=False,
    ping_timeout=60,
    ping_interval=25,
)
if _socketio_message_queue:
    socketio_kwargs["message_queue"] = _socketio_message_queue

socketio = SocketIO(app, **socketio_kwargs)

# WSGI entrypoints (so deployments can use `gunicorn ... app:app`)
application = app
socketio_app = app

auth_bp = Blueprint('auth', __name__)
csrf = CSRFProtect()

# Configure rate limit storage backend. Use Redis in production.
# In a production environment with multiple workers, using in-memory storage for rate limiting is not effective.
# It's recommended to use a centralized backend like Redis.
# You can set the REDIS_URL environment variable to point to your Redis instance.
ratelimit_storage_uri = os.getenv('REDIS_URL') or os.getenv('RATELIMIT_STORAGE_URI')

if not ratelimit_storage_uri:
    ratelimit_storage_uri = 'memory://'
    if os.getenv('FLASK_ENV') == 'production' and not app.config.get('DEBUG'):
        app.logger.warning(
            'Rate limiting is using in-memory storage, which is not suitable for production with multiple workers. '
            'Please configure a REDIS_URL or RATELIMIT_STORAGE_URI for persistent storage.'
        )

app.config['RATELIMIT_STORAGE_URI'] = ratelimit_storage_uri
limiter = Limiter(key_func=get_remote_address, storage_uri=app.config['RATELIMIT_STORAGE_URI'])
# Ensure CSRF and Limiter are initialized on the app
csrf.init_app(app)
limiter.init_app(app)

UPLOAD_FOLDER = os.path.join(app.root_path, 'static', 'uploads')
PROFILE_PICTURE_FOLDER = os.path.join(UPLOAD_FOLDER, 'profile_pictures')
os.makedirs(PROFILE_PICTURE_FOLDER, exist_ok=True)
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}

SECRET_KEY = os.getenv('SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("No SECRET_KEY set for Flask application. Please set the SECRET_KEY environment variable.")
app.config['SECRET_KEY'] = SECRET_KEY
def get_database_uri():
    """Get database URI from environment. No fallback to SQLite."""
    
    def _normalize_database_url(raw: str) -> str:
        """Normalize database URL (handle postgres:// vs postgresql://)."""
        database_url = (raw or '').strip()
        
        # Handle both PostgreSQL URL formats
        if database_url.startswith('postgres://'):
            database_url = database_url.replace('postgres://', 'postgresql://', 1)
        
        return database_url

    def _safe_db_url_for_logging(url: str) -> str:
        """Format database URL for logging without leaking credentials."""
        try:
            from urllib.parse import urlsplit
            parts = urlsplit(url)
            netloc = parts.netloc
            if '@' in netloc:
                netloc = netloc.split('@', 1)[1]
            return f"{parts.scheme}://{netloc}{parts.path}"
        except Exception:
            return '<redacted>'

    # DATABASE_URL is required
    database_url_raw = os.getenv('DATABASE_URL', '').strip()
    if not database_url_raw:
        raise RuntimeError(
            'DATABASE_URL environment variable is required and must not be empty. '
            'Please set DATABASE_URL to a valid PostgreSQL connection string.'
        )

    database_url = _normalize_database_url(database_url_raw)
    if not app.config.get('DEBUG', True):  # Default to True during early init
        app.logger.info(f"Using database: {_safe_db_url_for_logging(database_url)}")
    return database_url
app.config['SQLALCHEMY_DATABASE_URI'] = get_database_uri()
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Harden DB pooling for long-running processes (APScheduler) where connections may go idle
# while waiting on external APIs. Particularly important for Postgres + SSL.
_db_uri = (app.config.get('SQLALCHEMY_DATABASE_URI') or '').strip().lower()
if _db_uri.startswith('postgresql://'):
    # Defaults are conservative and can be overridden via env.
    app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
        'pool_pre_ping': True,
        # Recycle periodically to avoid server-side idle timeout drops.
        'pool_recycle': int(os.getenv('SQLALCHEMY_POOL_RECYCLE', '300')),
        'pool_timeout': int(os.getenv('SQLALCHEMY_POOL_TIMEOUT', '30')),
        'pool_size': int(os.getenv('SQLALCHEMY_POOL_SIZE', '5')),
        'max_overflow': int(os.getenv('SQLALCHEMY_MAX_OVERFLOW', '10')),
        'connect_args': {
            # psycopg2 connect args - increased timeout for cloud databases that may be sleeping
            'connect_timeout': int(os.getenv('PG_CONNECT_TIMEOUT', '30')),
            # TCP keepalives help prevent silent mid-run disconnects.
            'keepalives': 1,
            'keepalives_idle': int(os.getenv('PG_KEEPALIVES_IDLE', '30')),
            'keepalives_interval': int(os.getenv('PG_KEEPALIVES_INTERVAL', '10')),
            'keepalives_count': int(os.getenv('PG_KEEPALIVES_COUNT', '5')),
        },
    }
app.config['UPLOAD_FOLDER'] = os.getenv('UPLOAD_FOLDER', UPLOAD_FOLDER)
app.config['BACKUP_FOLDER'] = os.getenv('BACKUP_FOLDER', 'backups')
app.config['MAX_CONTENT_LENGTH'] = int(os.getenv('MAX_CONTENT_LENGTH', 16 * 1024 * 1024))  # 16MB max upload size
app.config['FERNET_KEY'] = os.getenv('FERNET_KEY')
app.config['DEEPSEEK_API_KEY'] = os.getenv('DEEPSEEK_API_KEY')
app.config['RESET_TOKEN_EXPIRATION'] = int(os.getenv('RESET_TOKEN_EXPIRATION', 3600))

# --- AI request tuning (env-driven) ---
# Keep interactive web requests under upstream/gateway timeouts (Render typically ~30s).
try:
    app.config['AI_SUMMARY_TIMEOUT_SECONDS'] = float(os.getenv('AI_SUMMARY_TIMEOUT_SECONDS', '20'))
except Exception:
    app.config['AI_SUMMARY_TIMEOUT_SECONDS'] = 20.0
try:
    app.config['AI_SUMMARY_MAX_RETRIES'] = int(float(os.getenv('AI_SUMMARY_MAX_RETRIES', '2')))
except Exception:
    app.config['AI_SUMMARY_MAX_RETRIES'] = 2
try:
    app.config['AI_SUMMARY_MAX_TOKENS'] = int(float(os.getenv('AI_SUMMARY_MAX_TOKENS', '900')))
except Exception:
    app.config['AI_SUMMARY_MAX_TOKENS'] = 900

# --- Safaricom Daraja (M-Pesa) configuration (env-driven) ---
# Receive (Till / Buy Goods): STK Push + manual Till confirmation (C2B URLs)
app.config['MPESA_ENV'] = (os.getenv('MPESA_ENV') or 'sandbox').strip().lower()  # sandbox|production
app.config['MPESA_BASE_URL'] = (os.getenv('MPESA_BASE_URL') or (
    'https://sandbox.safaricom.co.ke' if app.config['MPESA_ENV'] != 'production' else 'https://api.safaricom.co.ke'
)).strip()
app.config['MPESA_CONSUMER_KEY'] = (os.getenv('MPESA_CONSUMER_KEY') or '').strip()
app.config['MPESA_CONSUMER_SECRET'] = (os.getenv('MPESA_CONSUMER_SECRET') or '').strip()

# Till / Buy Goods shortcode
app.config['MPESA_TILL_SHORTCODE'] = (os.getenv('MPESA_TILL_SHORTCODE') or '').strip()
# Daraja Lipa Na Mpesa Online passkey (for STK password generation)
app.config['MPESA_PASSKEY'] = (os.getenv('MPESA_PASSKEY') or '').strip()

# Public callback URLs (must be HTTPS in production)
app.config['MPESA_STK_CALLBACK_URL'] = (os.getenv('MPESA_STK_CALLBACK_URL') or '').strip()
app.config['MPESA_C2B_VALIDATION_URL'] = (os.getenv('MPESA_C2B_VALIDATION_URL') or '').strip()
app.config['MPESA_C2B_CONFIRMATION_URL'] = (os.getenv('MPESA_C2B_CONFIRMATION_URL') or '').strip()

# Outgoing (admin) + verification endpoints
app.config['MPESA_INITIATOR_NAME'] = (os.getenv('MPESA_INITIATOR_NAME') or '').strip()
app.config['MPESA_SECURITY_CREDENTIAL'] = (os.getenv('MPESA_SECURITY_CREDENTIAL') or '').strip()
app.config['MPESA_OUTGOING_SHORTCODE'] = (os.getenv('MPESA_OUTGOING_SHORTCODE') or '').strip()

app.config['MPESA_TRANSACTION_STATUS_ENDPOINT'] = (os.getenv('MPESA_TRANSACTION_STATUS_ENDPOINT') or '/mpesa/transactionstatus/v1/query').strip()
app.config['MPESA_TRANSACTION_STATUS_RESULT_URL'] = (os.getenv('MPESA_TRANSACTION_STATUS_RESULT_URL') or '').strip()
app.config['MPESA_TRANSACTION_STATUS_TIMEOUT_URL'] = (os.getenv('MPESA_TRANSACTION_STATUS_TIMEOUT_URL') or '').strip()

app.config['MPESA_B2C_ENDPOINT'] = (os.getenv('MPESA_B2C_ENDPOINT') or '/mpesa/b2c/v1/paymentrequest').strip()
app.config['MPESA_B2C_RESULT_URL'] = (os.getenv('MPESA_B2C_RESULT_URL') or '').strip()
app.config['MPESA_B2C_TIMEOUT_URL'] = (os.getenv('MPESA_B2C_TIMEOUT_URL') or '').strip()

app.config['MPESA_B2B_ENDPOINT'] = (os.getenv('MPESA_B2B_ENDPOINT') or '/mpesa/b2b/v1/paymentrequest').strip()
app.config['MPESA_B2B_RESULT_URL'] = (os.getenv('MPESA_B2B_RESULT_URL') or '').strip()
app.config['MPESA_B2B_TIMEOUT_URL'] = (os.getenv('MPESA_B2B_TIMEOUT_URL') or '').strip()

app.config['MPESA_B2POCHI_ENDPOINT'] = (os.getenv('MPESA_B2POCHI_ENDPOINT') or '').strip()
app.config['MPESA_B2POCHI_RESULT_URL'] = (os.getenv('MPESA_B2POCHI_RESULT_URL') or '').strip()
app.config['MPESA_B2POCHI_TIMEOUT_URL'] = (os.getenv('MPESA_B2POCHI_TIMEOUT_URL') or '').strip()

# Optional: attribute webhook-posted ledger entries to this user id (admin/system).
try:
    _mpesa_sys_uid = (os.getenv('MPESA_SYSTEM_USER_ID') or '').strip()
    app.config['MPESA_SYSTEM_USER_ID'] = int(_mpesa_sys_uid) if _mpesa_sys_uid else None
except Exception:
    app.config['MPESA_SYSTEM_USER_ID'] = None

# Optional: default timeout for Daraja requests
try:
    app.config['MPESA_HTTP_TIMEOUT'] = float(os.getenv('MPESA_HTTP_TIMEOUT', '45'))
except Exception:
    app.config['MPESA_HTTP_TIMEOUT'] = 45.0

# Custom DateTime type that safely handles NULL and non-string values
from sqlalchemy import TypeDecorator, DateTime as SQLAlchemyDateTime

class SafeDateTime(TypeDecorator):
    """Custom DateTime column that safely handles NULL values and prevents fromisoformat errors."""
    impl = SQLAlchemyDateTime
    cache_ok = True

    def process_bind_param(self, value, dialect):
        """Convert Python datetime to database format."""
        if value is None:
            return None
        if isinstance(value, datetime):
            return value
        if isinstance(value, str):
            try:
                return datetime.fromisoformat(value)
            except (ValueError, TypeError):
                return None
        return value

    def process_result_value(self, value, dialect):
        """Convert database value back to Python datetime."""
        if value is None:
            return None
        if isinstance(value, datetime):
            return value
        if isinstance(value, str):
            try:
                dt = datetime.fromisoformat(value)
                # Treat naive timestamps as EAT
                if dt.tzinfo is None:
                    dt = dt.replace(tzinfo=EAT)
                return dt
            except (ValueError, TypeError, AttributeError):
                return None
        return value

# Initialize database extensions AFTER configuration is finalized.
db = SQLAlchemy(app, session_options={"autoflush": False, "autocommit": False})
migrate = Migrate(app, db)



ts = URLSafeTimedSerializer(app.config['SECRET_KEY'])

bcrypt = Bcrypt(app)
login_manager = LoginManager(app)
login_manager.login_view = 'auth.login'

# Initialize production-ready email system (Resend-only)
from utils.email_production import EmailAuditLogger, ResendConfig, ResendEmailSender


def _coerce_int(value, default: int) -> int:
    if value is None:
        return default
    if isinstance(value, bool):
        return int(value)
    if isinstance(value, int):
        return value
    if isinstance(value, float):
        return int(value)
    s = str(value).strip()
    if not s:
        return default
    try:
        return int(s)
    except Exception:
        try:
            return int(float(s))
        except Exception:
            return default


def _db_get(model, ident):
    """SQLAlchemy 2.x-safe replacement for Model.query.get(ident)."""
    if ident is None:
        return None

    # First try as-is.
    try:
        obj = db.session.get(model, ident)
        if obj is not None:
            return obj
    except Exception:
        pass

    # Then try common coercions (Flask request ids often arrive as strings).
    try:
        ident_int = int(str(ident).strip())
    except Exception:
        return None

    try:
        return db.session.get(model, ident_int)
    except Exception:
        return None


def _db_get_or_404(model, ident):
    """SQLAlchemy 2.x-safe replacement for Model.query.get_or_404(ident)."""
    obj = _db_get(model, ident)
    if obj is None:
        abort(404)
    return obj
_resend_api_key = (os.getenv('RESEND_API_KEY') or app.config.get('RESEND_API_KEY') or '').strip()
_resend_from = (os.getenv('RESEND_FROM') or app.config.get('RESEND_FROM') or 'Makokha Medical Centre <onboarding@resend.dev>').strip()
_resend_reply_to = (os.getenv('RESEND_REPLY_TO') or app.config.get('RESEND_REPLY_TO') or 'makokhamedicalcentre2025@gmail.com').strip()

_resend_timeout_seconds = _coerce_int(
    os.getenv('RESEND_TIMEOUT_SECONDS') or app.config.get('RESEND_TIMEOUT_SECONDS', 30),
    30,
)
_resend_max_retries = _coerce_int(
    os.getenv('RESEND_MAX_RETRIES') or app.config.get('RESEND_MAX_RETRIES', 3),
    3,
)

_resend_config = ResendConfig(
    api_key=_resend_api_key,
    from_address=_resend_from,
    reply_to=_resend_reply_to,
    timeout_seconds=_resend_timeout_seconds,
    max_retries=_resend_max_retries,
)

is_valid, error_msg = _resend_config.validate()
if is_valid:
    if not app.config.get('DEBUG'):
        app.logger.info("Email config: Using Resend API")
        # Warn about test domain limitations
        if 'onboarding@resend.dev' in _resend_from.lower() or 'resend.dev' in _resend_from.lower():
            app.logger.warning(
                "⚠ IMPORTANT: Using Resend test domain (onboarding@resend.dev). "
                "Emails will ONLY be sent to verified email addresses in your Resend dashboard. "
                "To send to ANY email address, add and verify your own domain in Resend: "
                "https://resend.com/domains"
            )
else:
    if not app.config.get('DEBUG'):
        app.logger.warning(f"⚠ Email config: Resend not configured: {error_msg}. Emails will not send.")

_email_sender = ResendEmailSender(_resend_config)

_email_audit_logger = EmailAuditLogger(
    log_file=os.getenv('EMAIL_AUDIT_LOG', 'instance/email_audit.log')
)

if not os.path.exists(os.path.join(app.config['UPLOAD_FOLDER'], 'profile_pictures')):
    os.makedirs(os.path.join(app.config['UPLOAD_FOLDER'], 'profile_pictures'))


class ResetPasswordRequestForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Request Password Reset')

class ResetPasswordForm(FlaskForm):
    password = PasswordField('Password', validators=[DataRequired(), Length(min=8)])
    confirm_password = PasswordField('Confirm Password', 
                                   validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Reset Password')

# Database Models
class User(db.Model, UserMixin):
    __tablename__ = 'user'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(EncryptedType, unique=True, nullable=False)
    email = db.Column(EncryptedType, unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)              # Hashed, not encrypted
    role = db.Column(EncryptedType, nullable=False)
    # These columns are BOOLEAN/TIMESTAMP/VARCHAR in the existing Postgres schema.
    # Do not store them via EncryptedType to avoid BYTEA type mismatches.
    is_active = db.Column(db.Boolean, default=True)
    last_login = db.Column(db.DateTime)
    profile_picture = db.Column(db.String(500))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Email verification & password reset (stored unencrypted; safe metadata)
    is_email_verified = db.Column(db.Boolean, nullable=False, default=True)
    email_otp_hash = db.Column(db.String(128))
    email_otp_expires_at = db.Column(db.DateTime)
    password_reset_nonce = db.Column(db.String(64))
    password_reset_sent_at = db.Column(db.DateTime)

    def set_password(self, password):
        self.password = generate_password_hash(password)
    
    def check_password(self, password):
        return check_password_hash(self.password, password)
    
    def get_id(self):
        return str(self.id)
        # Relationship to Sales (as pharmacist)
    def update_last_login(self):
        self.last_login = get_eat_now()
        db.session.commit()

    @property
    def last_login_dt(self):
        """Best-effort datetime view of last_login.

        Historical data and encrypted storage may return a string.
        """
        value = getattr(self, 'last_login', None)
        if not value:
            return None
        if isinstance(value, datetime):
            return value
        if not isinstance(value, str):
            return None

        s = value.strip()
        if not s:
            return None

        # Try ISO first (handles timezone offsets too)
        try:
            return datetime.fromisoformat(s)
        except Exception:
            pass

        # Common fallback formats
        for fmt in (
            '%Y-%m-%d %H:%M:%S.%f%z',
            '%Y-%m-%d %H:%M:%S%z',
            '%Y-%m-%d %H:%M:%S.%f',
            '%Y-%m-%d %H:%M:%S',
            '%Y-%m-%d %H:%M',
        ):
            try:
                return datetime.strptime(s, fmt)
            except Exception:
                continue
        return None
    # Relationships 
    generated_summaries = db.relationship('PatientSummary', back_populates='generator', lazy=True)
    ward_assignments = db.relationship('UserWardAssignment', back_populates='user', lazy=True, cascade='all, delete-orphan')
    department_assignments = db.relationship('UserDepartmentAssignment', back_populates='user', lazy=True, cascade='all, delete-orphan')


# Communication System Models
class Conversation(db.Model):
    """Stores conversation metadata between users"""
    __tablename__ = 'conversations'
    
    id = db.Column(db.Integer, primary_key=True)
    conversation_id = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    user1_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    user2_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    last_message_at = db.Column(db.DateTime, default=get_eat_now)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    
    # Relationships
    user1 = db.relationship('User', foreign_keys=[user1_id], backref='conversations_as_user1')
    user2 = db.relationship('User', foreign_keys=[user2_id], backref='conversations_as_user2')
    messages = db.relationship('Message', back_populates='conversation', lazy=True, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<Conversation {self.conversation_id}>'


class Message(db.Model):
    """Stores individual messages in conversations"""
    __tablename__ = 'messages'
    
    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    conversation_id = db.Column(db.Integer, db.ForeignKey('conversations.id'), nullable=True)
    sender_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipient_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content = db.Column(db.Text, nullable=False)
    message_type = db.Column(db.String(20), default='text')  # text, image, file
    is_delivered = db.Column(db.Boolean, default=False)
    delivered_at = db.Column(db.DateTime)
    is_read = db.Column(db.Boolean, default=False)
    read_at = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    
    # Relationships
    conversation = db.relationship('Conversation', back_populates='messages')
    sender = db.relationship('User', foreign_keys=[sender_id], backref='sent_messages')
    recipient = db.relationship('User', foreign_keys=[recipient_id], backref='received_messages')
    
    def __repr__(self):
        return f'<Message {self.message_id}>'


class CallLog(db.Model):
    """Stores call history (voice and video)"""
    __tablename__ = 'call_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    call_id = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    caller_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    receiver_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    call_type = db.Column(db.String(20), nullable=False)  # voice, video
    call_status = db.Column(db.String(20), default='initiated')  # initiated, ringing, answered, ended, missed, rejected
    started_at = db.Column(db.DateTime, default=get_eat_now)
    answered_at = db.Column(db.DateTime)
    ended_at = db.Column(db.DateTime)
    duration_seconds = db.Column(db.Integer, default=0)
    
    # Relationships
    caller = db.relationship('User', foreign_keys=[caller_id], backref='calls_made')
    receiver = db.relationship('User', foreign_keys=[receiver_id], backref='calls_received')
    
    def __repr__(self):
        return f'<CallLog {self.call_id}>'


class UserOnlineStatus(db.Model):
    """Tracks online status of users"""
    __tablename__ = 'user_online_status'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)
    is_online = db.Column(db.Boolean, default=False)
    last_seen = db.Column(db.DateTime, default=get_eat_now)
    socket_id = db.Column(db.String(100))
    
    # Relationship
    user = db.relationship('User', backref='online_status')
    
    def __repr__(self):
        return f'<UserOnlineStatus user_id={self.user_id} online={self.is_online}>'


class TypingIndicator(db.Model):
    """Tracks who is typing in which conversation"""
    __tablename__ = 'typing_indicators'
    
    id = db.Column(db.Integer, primary_key=True)
    conversation_id = db.Column(db.Integer, db.ForeignKey('conversations.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    is_typing = db.Column(db.Boolean, default=False)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # Relationships
    conversation = db.relationship('Conversation', backref='typing_indicators')
    user = db.relationship('User', backref='typing_activity')
    
    def __repr__(self):
        return f'<TypingIndicator conv={self.conversation_id} user={self.user_id}>'


class BlockedUser(db.Model):
    """Tracks user blocks to prevent messaging/calls."""
    __tablename__ = 'blocked_users'

    id = db.Column(db.Integer, primary_key=True)
    blocker_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    blocked_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    __table_args__ = (
        db.UniqueConstraint('blocker_id', 'blocked_id', name='uq_blocked_users_pair'),
    )

    blocker = db.relationship('User', foreign_keys=[blocker_id], backref='blocks_made')
    blocked = db.relationship('User', foreign_keys=[blocked_id], backref='blocks_received')


class ConversationSettings(db.Model):
    """Per-user settings for a 1:1 conversation."""
    __tablename__ = 'conversation_settings'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    conversation_id = db.Column(db.Integer, db.ForeignKey('conversations.id'), nullable=False)
    is_muted = db.Column(db.Boolean, default=False)
    muted_until = db.Column(db.DateTime)
    is_archived = db.Column(db.Boolean, default=False)
    is_pinned = db.Column(db.Boolean, default=False)
    pinned_at = db.Column(db.DateTime)
    notifications_enabled = db.Column(db.Boolean, default=True)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    __table_args__ = (
        db.UniqueConstraint('user_id', 'conversation_id', name='uq_conversation_settings_user_conv'),
    )

    user = db.relationship('User', backref='conversation_settings')
    conversation = db.relationship('Conversation', backref='settings')


class MessageEdit(db.Model):
    """Stores message edit history."""
    __tablename__ = 'message_edits'

    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), nullable=False, index=True)
    editor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    old_content = db.Column(db.Text, nullable=False)
    new_content = db.Column(db.Text, nullable=False)
    edited_at = db.Column(db.DateTime, default=get_eat_now)

    editor = db.relationship('User', backref='message_edits')


class MessageReaction(db.Model):
    """One reaction per user per message (WhatsApp-like)."""
    __tablename__ = 'message_reactions'

    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    emoji = db.Column(db.String(32), nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    __table_args__ = (
        db.UniqueConstraint('message_id', 'user_id', name='uq_message_reaction_user'),
    )

    user = db.relationship('User', backref='message_reactions')


class MessageStar(db.Model):
    """Per-user starring (favorite) of messages."""
    __tablename__ = 'message_stars'

    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), nullable=False, index=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    starred_at = db.Column(db.DateTime, default=get_eat_now)

    __table_args__ = (
        db.UniqueConstraint('message_id', 'user_id', name='uq_message_star_user'),
    )

    user = db.relationship('User', backref='message_stars')


class MessageDeletion(db.Model):
    """Represents a message deleted for everyone."""
    __tablename__ = 'message_deletions'

    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), nullable=False, unique=True, index=True)
    deleted_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    deleted_at = db.Column(db.DateTime, default=get_eat_now)
    scope = db.Column(db.String(20), default='everyone')

    deleted_by = db.relationship('User', backref='message_deletions')


class MessageReply(db.Model):
    """Links a message to the message it replies to."""
    __tablename__ = 'message_replies'

    id = db.Column(db.Integer, primary_key=True)
    message_id = db.Column(db.String(36), nullable=False, unique=True, index=True)
    replied_to_message_id = db.Column(db.String(36), nullable=False, index=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)


def _is_blocked(user_a_id: int, user_b_id: int) -> bool:
    """True if either user has blocked the other."""
    if not user_a_id or not user_b_id:
        return False
    try:
        return (
            BlockedUser.query.filter_by(blocker_id=user_a_id, blocked_id=user_b_id).first() is not None
            or BlockedUser.query.filter_by(blocker_id=user_b_id, blocked_id=user_a_id).first() is not None
        )
    except Exception:
        # If the blocked_users table isn't created yet, don't block base functionality.
        return False


class BackupRecord(db.Model):
    __tablename__ = 'backup_records'

    id = db.Column(db.Integer, primary_key=True)
    backup_id = db.Column(db.String(36), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    timestamp = db.Column(db.DateTime, nullable=False, default=get_eat_now)
    backup_type = db.Column(db.String(20), nullable=False)  # 'manual', 'scheduled', 'disaster_recovery'
    status = db.Column(db.String(20), nullable=False, default='pending')  # 'pending', 'in_progress', 'completed', 'failed'
    size_bytes = db.Column(db.Integer)
    storage_location = db.Column(db.String(255))  # S3 path or local path
    checksum = db.Column(db.String(64))  # SHA-256 checksum
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    notes = db.Column(db.Text)
    
    user = db.relationship('User', backref='backups')
    
    def __repr__(self):
        return f'<BackupRecord {self.backup_id}>'


class DrawnSignature(db.Model):
    """Store hand-drawn digital signatures"""
    __tablename__ = 'drawn_signatures'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    signature_data = db.Column(db.Text, nullable=False)  # Base64 encoded PNG
    signature_type = db.Column(db.String(50), default='admin')  # admin, doctor, etc.
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    user = db.relationship('User', backref='signatures')
    
    def __repr__(self):
        return f'<DrawnSignature {self.id} User:{self.user_id}>'


_BACKUP_STATS_MARKER = "\n\n__BACKUP_STATS__:\n"
_RESTORE_STATUS_MARKER = "\n\n__RESTORE_STATUS__:\n"


def _backup_notes_with_stats(notes: str | None, stats: dict) -> str:
    """Append structured backup stats to notes without breaking legacy display."""
    base = (notes or '').rstrip()
    try:
        payload = json.dumps(stats or {}, ensure_ascii=False, separators=(',', ':'))
    except Exception:
        payload = '{}'
    if not base:
        return _BACKUP_STATS_MARKER + payload
    return base + _BACKUP_STATS_MARKER + payload


def _backup_extract_stats(notes: str | None) -> dict | None:
    if not notes:
        return None
    try:
        if _BACKUP_STATS_MARKER not in notes:
            return None
        _, raw = notes.split(_BACKUP_STATS_MARKER, 1)
        raw = (raw or '').strip()
        data = json.loads(raw)
        return data if isinstance(data, dict) else None
    except Exception:
        return None


def _backup_strip_stats(notes: str | None) -> str | None:
    if not notes:
        return notes
    if _BACKUP_STATS_MARKER not in notes:
        return notes
    return notes.split(_BACKUP_STATS_MARKER, 1)[0].strip() or None


def _backup_notes_with_restore_status(notes: str | None, restore_status: dict) -> str:
    """Append structured restore status to notes.

    Keeps existing text and backup stats, and replaces any existing restore marker.
    """
    base = (notes or '').rstrip()
    # Drop any existing restore marker to keep only the latest restore status.
    if _RESTORE_STATUS_MARKER in base:
        base = base.split(_RESTORE_STATUS_MARKER, 1)[0].rstrip()
    try:
        payload = json.dumps(restore_status or {}, ensure_ascii=False, separators=(',', ':'))
    except Exception:
        payload = '{}'
    if not base:
        return _RESTORE_STATUS_MARKER + payload
    return base + _RESTORE_STATUS_MARKER + payload


def _backup_extract_restore_status(notes: str | None) -> dict | None:
    if not notes:
        return None
    try:
        if _RESTORE_STATUS_MARKER not in notes:
            return None
        _, raw = notes.split(_RESTORE_STATUS_MARKER, 1)
        raw = (raw or '').strip()
        data = json.loads(raw)
        return data if isinstance(data, dict) else None
    except Exception:
        return None


def _backup_strip_restore_status(notes: str | None) -> str | None:
    if not notes:
        return notes
    if _RESTORE_STATUS_MARKER not in notes:
        return notes
    return notes.split(_RESTORE_STATUS_MARKER, 1)[0].rstrip() or None


class BackupAccessCredential(db.Model):
    __tablename__ = 'backup_access_credentials'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    created_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)


class BackupScheduleConfig(db.Model):
    __tablename__ = 'backup_schedule_config'

    id = db.Column(db.Integer, primary_key=True)
    daily_enabled = db.Column(db.Boolean, default=True)
    daily_time = db.Column(db.String(5), default='02:00')  # HH:MM
    disaster_enabled = db.Column(db.Boolean, default=True)
    disaster_interval_minutes = db.Column(db.Integer, default=30)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)


class BackupLoginUser(db.Model):
    """User credentials for backup feature access (separate from main system login)."""
    __tablename__ = 'backup_login_users'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)  # Hospital email for backup
    password_hash = db.Column(db.String(255), nullable=True)  # Set after OTP verification
    is_verified = db.Column(db.Boolean, default=False)  # Email verified via OTP
    verified_at = db.Column(db.DateTime)
    otp_hash = db.Column(db.String(128))  # Hash of OTP sent for verification
    otp_expires_at = db.Column(db.DateTime)
    is_active = db.Column(db.Boolean, default=True)

    
    # Linkage to admin user who created/registered
    created_by_admin_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # For security tracking - log failed attempts
    last_login_attempt = db.Column(db.DateTime)
    last_successful_login = db.Column(db.DateTime)
    failed_attempts = db.Column(db.Integer, default=0)
    
    # NOTE: created_by_admin_id is used as the *linked admin user_id* for backup-login restriction.
    # The system requires the currently logged-in admin to match this id to use the backup credentials.
    created_by_admin = db.relationship('User', foreign_keys=[created_by_admin_id], backref='backup_login_users_created')

    @property
    def created_by(self):
        # Backward-compat alias used by older templates/tests
        return self.created_by_admin
    
    def __repr__(self):
        return f'<BackupLoginUser {self.email}>'


class DisasterRecoveryPlan(db.Model):
    __tablename__ = 'disaster_recovery_plans'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    recovery_point_objective = db.Column(db.Integer)  # in minutes
    recovery_time_objective = db.Column(db.Integer)  # in minutes
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    last_tested = db.Column(db.DateTime)
    test_results = db.Column(db.Text)
    
    def __repr__(self):
        return f'<DisasterRecoveryPlan {self.name}>'

class Ward(db.Model):
    __tablename__ = 'wards'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    daily_rate = db.Column(db.Float, default=0.0)  # Ward bed charge per day
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    
    beds = db.relationship('Bed', backref='ward', lazy=True)

class Bed(db.Model):
    __tablename__ = 'beds'
    
    id = db.Column(db.Integer, primary_key=True)
    bed_number = db.Column(db.String(50), nullable=False, unique=True)
    ward_id = db.Column(db.Integer, db.ForeignKey('wards.id'), nullable=False)
    status = db.Column(db.String(20), default='available')  # available, occupied, maintenance
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'))
    assigned_at = db.Column(db.DateTime)
    released_at = db.Column(db.DateTime)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    
    patient = db.relationship('Patient', backref='bed_assignment')


class OutpatientDepartment(db.Model):
    """Outpatient departments and clinics."""
    __tablename__ = 'outpatient_departments'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    type = db.Column(db.String(20), nullable=False)  # 'department' or 'clinic'
    description = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # Relationships
    user_assignments = db.relationship('UserDepartmentAssignment', back_populates='department', lazy=True, cascade='all, delete-orphan')
    
    def __repr__(self):
        return f'<OutpatientDepartment {self.name} ({self.type})>'


class UserWardAssignment(db.Model):
    """Many-to-many assignment of users to wards with roles."""
    __tablename__ = 'user_ward_assignments'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    ward_id = db.Column(db.Integer, db.ForeignKey('wards.id'), nullable=False)
    role = db.Column(db.String(50), nullable=False)  # consultant, general (doctors); incharge, general, student, intern (nurses)
    is_primary = db.Column(db.Boolean, default=False)  # Primary ward assignment
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    __table_args__ = (
        db.Index('ix_user_ward_assignments_user_id', 'user_id'),
        db.Index('ix_user_ward_assignments_ward_id', 'ward_id'),
        db.UniqueConstraint('user_id', 'ward_id', name='uq_user_ward'),
    )
    
    # Relationships
    user = db.relationship('User', back_populates='ward_assignments')
    ward = db.relationship('Ward', backref='user_assignments')
    
    def __repr__(self):
        return f'<UserWardAssignment User {self.user_id} - Ward {self.ward_id} - {self.role}>'


class UserDepartmentAssignment(db.Model):
    """Many-to-many assignment of users to outpatient departments with roles."""
    __tablename__ = 'user_department_assignments'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    department_id = db.Column(db.Integer, db.ForeignKey('outpatient_departments.id'), nullable=False)
    role = db.Column(db.String(50), nullable=False)  # consultant, general, specialist
    is_primary = db.Column(db.Boolean, default=False)  # Primary department assignment
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    __table_args__ = (
        db.Index('ix_user_department_assignments_user_id', 'user_id'),
        db.Index('ix_user_department_assignments_department_id', 'department_id'),
        db.UniqueConstraint('user_id', 'department_id', name='uq_user_department'),
    )
    
    # Relationships
    user = db.relationship('User', back_populates='department_assignments')
    department = db.relationship('OutpatientDepartment', back_populates='user_assignments')
    
    def __repr__(self):
        return f'<UserDepartmentAssignment User {self.user_id} - Department {self.department_id} - {self.role}>'


class BedAssignment(db.Model):
    """Historical record of bed occupancy.

    Used so ward stay charges can still be billed after a bed is released (when
    Bed.patient_id is cleared).
    """

    __tablename__ = 'bed_assignments'

    id = db.Column(db.Integer, primary_key=True)
    bed_id = db.Column(db.Integer, db.ForeignKey('beds.id'), nullable=False)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    ward_id = db.Column(db.Integer, db.ForeignKey('wards.id'), nullable=False)
    assigned_at = db.Column(db.DateTime, nullable=False)
    start_date = db.Column(db.DateTime, nullable=False)
    released_at = db.Column(db.DateTime)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    __table_args__ = (
        db.Index('ix_bed_assignments_patient_id', 'patient_id'),
        db.Index('ix_bed_assignments_bed_id', 'bed_id'),
        db.Index('ix_bed_assignments_assigned_at', 'assigned_at'),
    )

    bed = db.relationship('Bed', backref='assignments')
    patient = db.relationship('Patient', backref='bed_assignments')
    ward = db.relationship('Ward', backref='bed_assignments')


class BedStayCharge(db.Model):
    """Tracks ward-stay periods already billed for a patient.

    This lets ward stay totals "auto-update" daily by billing only the unbilled
    date range since assignment.
    """

    __tablename__ = 'bed_stay_charges'

    id = db.Column(db.Integer, primary_key=True)
    bed_id = db.Column(db.Integer, db.ForeignKey('beds.id'), nullable=False)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    charge_start_date = db.Column(db.Date, nullable=False)
    charge_end_date = db.Column(db.Date, nullable=False)
    days = db.Column(db.Integer, nullable=False)
    daily_rate = db.Column(db.Float, nullable=False)
    amount = db.Column(db.Float, nullable=False)
    sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    __table_args__ = (
        db.UniqueConstraint('bed_id', 'patient_id', 'charge_end_date', name='uq_bed_stay_charge_end'),
        db.Index('ix_bed_stay_charges_patient_id', 'patient_id'),
        db.Index('ix_bed_stay_charges_bed_id', 'bed_id'),
    )

    bed = db.relationship('Bed', backref='stay_charges')
    patient = db.relationship('Patient', backref='stay_charges')
    sale = db.relationship('Sale', backref='bed_stay_charges', uselist=False)


def update_ward_stay_bill_for_patient(patient_id: int, context: dict):
    """Idempotent ward stay bill updater.

    - Calculates unbilled days since the last charge.
    - Creates BedStayCharge, Sale, and Transaction records.
    - Returns (BedStayCharge, unbilled_days) tuple.
    """
    if not patient_id or not context:
        return None, 0

    today = date.today()
    start_date = context.get('start_date')
    end_date = context.get('end_date')
    bed_id = context.get('bed_id')
    daily_rate = float(context.get('daily_rate') or 0)

    if not all([start_date, end_date, bed_id, daily_rate > 0]):
        return None, 0

    # Find the last date a charge was recorded for this stay
    last_charge = (
        BedStayCharge.query
        .filter_by(patient_id=patient_id, bed_id=bed_id)
        .order_by(BedStayCharge.charge_end_date.desc())
        .first()
    )
    
    charge_from_date = last_charge.charge_end_date + timedelta(days=1) if last_charge else start_date
    
    if charge_from_date > end_date:
        return None, 0 # Already billed up to date

    unbilled_days = (end_date - charge_from_date).days + 1
    if unbilled_days <= 0:
        return None, 0

    amount = daily_rate * unbilled_days

    patient = _db_get(Patient, patient_id)
    ward_name = context.get('ward_name', 'Ward')

    # Create Sale and Transaction first
    sale = Sale(
        sale_number=generate_sale_number(),
        patient_id=patient_id,
        user_id=current_user.id,
        pharmacist_name=current_user.username,
        total_amount=amount,
        payment_method='internal',
        status='completed',
        notes=f"Ward stay charge for {patient.name if patient else 'patient'} in {ward_name} for {unbilled_days} days."
    )
    db.session.add(sale)
    db.session.flush() # Flush to get sale.id

    sale_item = SaleItem(
        sale_id=sale.id,
        description=f"Ward Stay: {ward_name} ({unbilled_days} days)",
        quantity=unbilled_days,
        unit_price=daily_rate,
        total_price=amount
    )
    db.session.add(sale_item)

    transaction = Transaction(
        transaction_number=generate_transaction_number(),
        transaction_type='sale',
        amount=amount,
        user_id=current_user.id,
        reference_id=sale.id,
        reference_table='sales',
        direction='IN',
        status='posted',
        department='in-patient',
        category='accommodation',
        payer=patient.name if patient else 'Patient',
        notes=f"Ward stay: {patient.name if patient else 'patient'} - {unbilled_days} days"
    )
    db.session.add(transaction)

    # Now create the BedStayCharge and link it to the sale
    charge = BedStayCharge(
        bed_id=bed_id,
        patient_id=patient_id,
        charge_start_date=charge_from_date,
        charge_end_date=end_date,
        days=unbilled_days,
        daily_rate=daily_rate,
        amount=amount,
        sale_id=sale.id
    )
    db.session.add(charge)
    
    try:
        db.session.commit()
        return charge, unbilled_days
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to update ward stay bill: {e}")
        return None, 0


class NurseNotification(db.Model):
    __tablename__ = 'nurse_notifications'
    
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    ward_id = db.Column(db.Integer, db.ForeignKey('wards.id'), nullable=False)
    bed_id = db.Column(db.Integer, db.ForeignKey('beds.id'), nullable=False)
    doctor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    notified_at = db.Column(db.DateTime, nullable=False, default=get_eat_now)
    completed_at = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(20), default='pending')  # pending, completed, expired
    notes = db.Column(db.Text, nullable=True)
    
    # Relationships
    patient = db.relationship('Patient', backref='nurse_notifications')
    ward = db.relationship('Ward', backref='nurse_notifications')
    bed = db.relationship('Bed', backref='nurse_notifications')
    doctor = db.relationship('User', backref='nurse_notifications')
    
    # Indexes for query performance
    __table_args__ = (
        db.Index('idx_nurse_notif_patient', 'patient_id'),
        db.Index('idx_nurse_notif_status', 'status'),
        db.Index('idx_nurse_notif_ward', 'ward_id'),
    )
    
    def __repr__(self):
        return f'<NurseNotification {self.id} - Patient {self.patient_id} - Status {self.status}>'


class NursingReport(db.Model):
    """Nursing reports and observations for patients."""
    __tablename__ = 'nursing_reports'
    
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    nurse_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    report_type = db.Column(db.String(50), default='general')  # general, admission, discharge, incident
    
    # Vital signs
    temperature = db.Column(db.Float)  # Celsius
    blood_pressure_systolic = db.Column(db.Integer)
    blood_pressure_diastolic = db.Column(db.Integer)
    pulse_rate = db.Column(db.Integer)  # beats per minute
    respiratory_rate = db.Column(db.Integer)  # breaths per minute
    oxygen_saturation = db.Column(db.Integer)  # percentage
    blood_sugar = db.Column(db.Float)  # mg/dL
    weight = db.Column(db.Float)  # kg
    height = db.Column(db.Float)  # cm
    
    # Observations and notes
    observations = db.Column(db.Text)  # General observations
    symptoms = db.Column(db.Text)  # Patient symptoms
    pain_level = db.Column(db.Integer)  # 0-10 scale
    consciousness_level = db.Column(db.String(50))  # alert, drowsy, unconscious, etc.
    mobility_status = db.Column(db.String(100))  # ambulatory, bed-bound, assisted, etc.
    
    # Care activities
    care_provided = db.Column(db.Text)  # Description of care activities
    medications_given = db.Column(db.Text)  # Summary of medications administered
    intake_output = db.Column(db.Text)  # Fluid intake/output tracking
    
    # Follow-up
    recommendations = db.Column(db.Text)
    doctor_notified = db.Column(db.Boolean, default=False)
    urgent = db.Column(db.Boolean, default=False)
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # Relationships
    patient = db.relationship('Patient', backref='nursing_reports')
    nurse = db.relationship('User', backref='nursing_reports')
    
    # Indexes
    __table_args__ = (
        db.Index('idx_nursing_reports_patient', 'patient_id'),
        db.Index('idx_nursing_reports_nurse', 'nurse_id'),
        db.Index('idx_nursing_reports_created', 'created_at'),
    )
    
    def __repr__(self):
        return f'<NursingReport {self.id} - Patient {self.patient_id}>'


class MedicationAdministration(db.Model):
    """Track medication administration by nurses."""
    __tablename__ = 'medication_administrations'
    
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    nurse_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    
    # Medication details
    medication_name = db.Column(db.String(255), nullable=False)
    dosage = db.Column(db.String(100), nullable=False)
    route = db.Column(db.String(50))  # oral, IV, IM, topical, etc.
    frequency = db.Column(db.String(100))  # e.g., "twice daily", "every 6 hours"
    
    # Administration details
    scheduled_time = db.Column(db.DateTime)  # When it was supposed to be given
    administered_at = db.Column(db.DateTime, nullable=False, default=get_eat_now)
    status = db.Column(db.String(20), default='administered')  # administered, refused, missed, delayed
    
    # Additional information
    site = db.Column(db.String(100))  # Injection site if applicable
    reaction = db.Column(db.Text)  # Any adverse reactions
    notes = db.Column(db.Text)
    
    # Prescription reference
    prescription_id = db.Column(db.Integer)  # Link to prescription if applicable
    doctor_id = db.Column(db.Integer, db.ForeignKey('user.id'))  # Prescribing doctor
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # Relationships
    patient = db.relationship('Patient', backref='medication_administrations')
    nurse = db.relationship('User', foreign_keys=[nurse_id], backref='medications_administered')
    doctor = db.relationship('User', foreign_keys=[doctor_id], backref='medications_prescribed_for_admin')
    
    # Indexes
    __table_args__ = (
        db.Index('idx_med_admin_patient', 'patient_id'),
        db.Index('idx_med_admin_nurse', 'nurse_id'),
        db.Index('idx_med_admin_time', 'administered_at'),
    )
    
    def __repr__(self):
        return f'<MedicationAdministration {self.id} - {self.medication_name} to Patient {self.patient_id}>'


def get_ward_stay_bill(patient_id: int, context: dict):
    """Get total ward stay bill and any unbilled portion."""
    if not patient_id or not context:
        return None, None

    bed_id = context.get('bed_id')
    daily_rate = float(context.get('daily_rate') or 0)
    start_date = context.get('start_date')
    end_date = context.get('end_date')

    if not all([bed_id, daily_rate > 0, start_date, end_date]):
        return None, None

    # Get all historical charges for this stay
    all_charges = BedStayCharge.query.filter_by(patient_id=patient_id, bed_id=bed_id).all()
    
    total_billed_days = sum(c.days for c in all_charges)
    total_billed_amount = sum(c.amount for c in all_charges)

    # Calculate unbilled portion
    last_charge_date = max(c.charge_end_date for c in all_charges) if all_charges else start_date - timedelta(days=1)
    
    unbilled_start_date = last_charge_date + timedelta(days=1)
    unbilled_days = 0
    if end_date >= unbilled_start_date:
        unbilled_days = (end_date - unbilled_start_date).days + 1

    unbilled_amount = unbilled_days * daily_rate if unbilled_days > 0 else 0

    total_stay_days = total_billed_days + unbilled_days
    total_stay_amount = total_billed_amount + unbilled_amount

    bill_summary = {
        'context': context,
        'total_stay_days': total_stay_days,
        'total_stay_amount': total_stay_amount,
        'billed_days': total_billed_days,
        'billed_amount': total_billed_amount,
        'unbilled_days': unbilled_days,
        'unbilled_amount': unbilled_amount,
        'charges': all_charges
    }

    unbilled_summary = {
        'days': unbilled_days,
        'amount': unbilled_amount,
        'from': unbilled_start_date.isoformat(),
        'to': end_date.isoformat()
    } if unbilled_days > 0 else None

    return bill_summary, unbilled_summary



def _get_patient_bed_stay_context(patient_id: int):
    """Return (bed, ward, start_date, end_date) for ward-stay billing.

    Prefers the currently occupied bed. If none, falls back to the most recent
    BedAssignment so billing still works after bed release.
    """
    if not patient_id:
        return None

    today = date.today()

    bed = Bed.query.filter_by(patient_id=patient_id, status='occupied').first()
    if bed and getattr(bed, 'ward', None):
        assigned_at = getattr(bed, 'assigned_at', None)
        start_date = assigned_at.date() if assigned_at else today
        end_date = today
        return {
            'bed_id': bed.id,
            'bed_number': bed.bed_number,
            'ward_name': bed.ward.name,
            'daily_rate': float(getattr(bed.ward, 'daily_rate', 0) or 0),
            'start_date': start_date,
            'end_date': end_date,
            'source': 'current',
        }

    # Fallback: last known assignment
    last = (
        BedAssignment.query
        .filter_by(patient_id=patient_id)
        .order_by(BedAssignment.assigned_at.desc())
        .first()
    )
    if not last or not getattr(last, 'bed', None) or not getattr(last.bed, 'ward', None):
        return None

    start_date = last.assigned_at.date()
    end_date = (last.released_at.date() if last.released_at else today)
    return {
        'bed_id': last.bed.id,
        'bed_number': last.bed.bed_number,
        'ward_name': last.bed.ward.name,
        'daily_rate': float(getattr(last.bed.ward, 'daily_rate', 0) or 0),
        'start_date': start_date,
        'end_date': end_date,
        'source': 'history',
    }


def _ward_stay_is_paid_through(patient_id: int, bed_id: int, through_date: 'date') -> bool:
    """Return True if ward stay charges are posted through the given date."""
    if not patient_id or not bed_id or not through_date:
        return True

    # Find the latest charge whose end_date covers the requested through_date
    charges = (
        BedStayCharge.query
        .filter_by(patient_id=patient_id, bed_id=bed_id)
        .filter(BedStayCharge.charge_end_date >= through_date)
        .order_by(BedStayCharge.charge_end_date.desc())
        .all()
    )
    for ch in charges or []:
        sale_id = getattr(ch, 'sale_id', None)
        if not sale_id:
            continue
        tx = _get_transaction_for_sale(int(sale_id))
        if tx:
            return True
    return False

def get_total_beds():
    return Bed.query.count()

def get_available_beds():
    return Bed.query.options(db.joinedload(Bed.patient)).filter_by(status='available').count()

def get_occupied_beds():
    return Bed.query.options(db.joinedload(Bed.patient)).filter_by(status='occupied').count()

class Drug(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    drug_number = db.Column(db.String(100), unique=True, nullable=False)  # Increased from 50
    name = db.Column(db.String(255), nullable=False)                      # Increased from 100
    specification = db.Column(db.Text)                                    # Changed from String(200) to Text
    buying_price = db.Column(db.Numeric(10, 2), nullable=False)           # Use Numeric for money
    selling_price = db.Column(db.Numeric(10, 2), nullable=False)          # Use Numeric for money
    stocked_quantity = db.Column(db.Integer, nullable=False)
    sold_quantity = db.Column(db.Integer, default=0)
    expiry_date = db.Column(db.Date, nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # Relationship to dosages with cascade delete
    dosages = db.relationship('DrugDosage', back_populates='drug_record', cascade='all, delete-orphan', lazy=True)

    @hybrid_property
    def remaining_quantity(self):
        return self.stocked_quantity - (self.sold_quantity or 0)
    
    @remaining_quantity.expression
    def remaining_quantity(cls):
        return cls.stocked_quantity - (cls.sold_quantity or 0)
    
    def update_stock(self, quantity):
        """Safe method to update stock quantities"""
        if self.remaining_quantity >= quantity:
            self.sold_quantity += quantity
            db.session.add(self)
            return True
        return False
    
    @hybrid_property
    def stock_status(self):
        remaining = self.remaining_quantity
        if remaining <= 0:
            return 'out-of-stock'
        elif remaining < 10:
            return 'low-stock'
        elif self.expiry_date and (self.expiry_date - date.today()).days < 30:
            return 'expiring-soon'
        return 'in-stock'
    
    @stock_status.expression
    def stock_status(cls):
        return case([
            (cls.remaining_quantity == 0, 'out-of-stock'),
            (cls.remaining_quantity < 10, 'low-stock'),
            (cls.expiry_date <= date.today() + timedelta(days=30), 'expiring-soon')
        ], else_='in-stock')
    
    def update_stock(self, quantity):
        """Safe method to update stock quantities"""
        if self.remaining_quantity >= quantity:
            self.sold_quantity += quantity  # Update the underlying column
            return True
        return False  


class ControlledDrug(db.Model):
    __tablename__ = 'controlled_drugs'

    id = db.Column(db.Integer, primary_key=True)
    controlled_drug_number = db.Column(db.String(100), unique=True, nullable=False)
    name = db.Column(db.String(255), nullable=False)
    specification = db.Column(db.Text)
    buying_price = db.Column(db.Numeric(10, 2), nullable=False)
    selling_price = db.Column(db.Numeric(10, 2), nullable=False)
    stocked_quantity = db.Column(db.Integer, nullable=False)
    sold_quantity = db.Column(db.Integer, default=0)
    expiry_date = db.Column(db.Date, nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(
        db.DateTime,
        default=get_eat_now,
        onupdate=get_eat_now,
    )
    
    # Relationship to dosages with cascade delete
    dosages = db.relationship('ControlledDrugDosage', back_populates='controlled_drug_record', cascade='all, delete-orphan', lazy=True)

    @hybrid_property
    def remaining_quantity(self):
        return self.stocked_quantity - (self.sold_quantity or 0)

    @remaining_quantity.expression
    def remaining_quantity(cls):
        return cls.stocked_quantity - (cls.sold_quantity or 0)

    @hybrid_property
    def stock_status(self):
        remaining = self.remaining_quantity
        if remaining <= 0:
            return 'out-of-stock'
        if remaining < 10:
            return 'low-stock'
        if self.expiry_date and (self.expiry_date - date.today()).days < 30:
            return 'expiring-soon'
        return 'in-stock'


class ControlledPrescription(db.Model):
    __tablename__ = 'controlled_prescriptions'

    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    doctor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    notes = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')  # pending, dispensed, cancelled
    dispensed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    dispensed_at = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(
        db.DateTime,
        default=get_eat_now,
        onupdate=get_eat_now,
    )

    items = db.relationship('ControlledPrescriptionItem', backref='controlled_prescription', lazy=True, cascade='all, delete-orphan')
    patient = db.relationship('Patient', backref='controlled_prescriptions')
    doctor = db.relationship('User', foreign_keys=[doctor_id], backref='controlled_prescriptions')
    dispenser = db.relationship('User', foreign_keys=[dispensed_by], backref='dispensed_controlled_prescriptions')


class ControlledPrescriptionItem(db.Model):
    __tablename__ = 'controlled_prescription_items'

    id = db.Column(db.Integer, primary_key=True)
    controlled_prescription_id = db.Column(db.Integer, db.ForeignKey('controlled_prescriptions.id'), nullable=False)
    controlled_drug_id = db.Column(db.Integer, db.ForeignKey('controlled_drugs.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    dosage = db.Column(db.Text)
    frequency = db.Column(db.String(50))
    duration = db.Column(db.String(50))
    notes = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(
        db.DateTime,
        default=get_eat_now,
        onupdate=get_eat_now,
    )

    controlled_drug = db.relationship('ControlledDrug', backref='controlled_prescription_items')


class ControlledSale(db.Model):
    __tablename__ = 'controlled_sales'

    id = db.Column(db.Integer, primary_key=True)
    sale_number = db.Column(db.String(80), unique=True, nullable=False)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    pharmacist_name = db.Column(db.String(100))
    total_amount = db.Column(db.Numeric(10, 2), nullable=False)
    payment_method = db.Column(db.String(20))
    status = db.Column(db.String(20), default='completed')
    notes = db.Column(db.Text)
    transaction_id = db.Column(db.Integer, db.ForeignKey('transaction.id'), nullable=True)
    transaction = db.relationship('Transaction', backref='controlled_sale', uselist=False)


    # Walk-in / external controlled sale metadata (captured by pharmacist)
    customer_name = db.Column(db.String(255))
    customer_age = db.Column(db.Integer)
    customer_gender = db.Column(db.String(50))
    diagnosis = db.Column(db.String(255))
    customer_phone = db.Column(db.String(100))
    destination = db.Column(db.String(255))

    # Prescription image/photo for external controlled sales
    prescription_image_path = db.Column(db.String(500))

    # Stored receipt copy (HTML)
    receipt_html = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(
        db.DateTime,
        default=get_eat_now,
        onupdate=get_eat_now,
    )

    patient = db.relationship('Patient', backref='controlled_sales')
    user = db.relationship('User', foreign_keys=[user_id], backref='controlled_sales')
    items = db.relationship('ControlledSaleItem', back_populates='sale', lazy=True, cascade='all, delete-orphan')


class ControlledSaleItem(db.Model):
    __tablename__ = 'controlled_sale_items'

    id = db.Column(db.Integer, primary_key=True)
    sale_id = db.Column(db.Integer, db.ForeignKey('controlled_sales.id'), nullable=False)
    controlled_drug_id = db.Column(db.Integer, db.ForeignKey('controlled_drugs.id'), nullable=False)
    controlled_drug_name = db.Column(db.String(255))
    controlled_drug_specification = db.Column(db.Text)
    individual_sale_number = db.Column(db.String(120))
    description = db.Column(db.String(255), nullable=False, default='Controlled drug sale')
    prescription_source = db.Column(db.String(20), nullable=False, default='external')  # internal, external
    prescription_sheet_path = db.Column(db.String(500))

    # Optional Rx instructions captured at point of sale
    dosage = db.Column(db.Text)
    frequency = db.Column(db.String(50))
    duration = db.Column(db.String(50))
    notes = db.Column(db.Text)

    quantity = db.Column(db.Integer, default=1)
    unit_price = db.Column(db.Float, nullable=False)
    total_price = db.Column(db.Float, nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(
        db.DateTime,
        default=get_eat_now,
        onupdate=get_eat_now,
    )

    controlled_drug = db.relationship('ControlledDrug', backref='controlled_sale_items')
    sale = db.relationship('ControlledSale', back_populates='items')

    def __init__(self, **kwargs):
        super(ControlledSaleItem, self).__init__(**kwargs)
        if getattr(self, 'controlled_drug', None):
            self.controlled_drug_name = self.controlled_drug.name
            self.controlled_drug_specification = self.controlled_drug.specification
    
class DrugDosage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    drug_id = db.Column(db.Integer, db.ForeignKey('drug.id'), nullable=False)
    source = db.Column(db.String(20), default='manual')  # manual|ai
    indication = db.Column(db.Text)
    contraindication = db.Column(db.Text)
    interaction = db.Column(db.Text)
    side_effects = db.Column(db.Text)
    dosage_peds = db.Column(db.Text)
    dosage_adults = db.Column(db.Text)
    dosage_geriatrics = db.Column(db.Text)
    important_notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    
    drug_record = db.relationship('Drug', back_populates='dosages')


class ControlledDrugDosage(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    controlled_drug_id = db.Column(db.Integer, db.ForeignKey('controlled_drugs.id'), nullable=False)
    source = db.Column(db.String(20), default='manual')  # manual|ai
    indication = db.Column(db.Text)
    contraindication = db.Column(db.Text)
    interaction = db.Column(db.Text)
    side_effects = db.Column(db.Text)
    dosage_peds = db.Column(db.Text)
    dosage_adults = db.Column(db.Text)
    dosage_geriatrics = db.Column(db.Text)
    important_notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    controlled_drug_record = db.relationship('ControlledDrug', back_populates='dosages')


def _normalize_drug_name(name: str) -> str:
    return (name or '').strip().lower()


def _load_dosage_index_book():
    """Load dosage index book JSON if present.

    Expected format:
      {"entries": [{"name": "Paracetamol", "indication": "...", "dosage_adults": "...", ...}]}
    """
    candidates = [
        os.path.join(app.instance_path, 'dosage_index.json'),
        os.path.join(app.root_path, 'static', 'dosage_index.json'),
        os.path.join(app.root_path, 'dosage_index.json'),
    ]
    for path in candidates:
        try:
            if os.path.exists(path):
                with open(path, 'r', encoding='utf-8') as f:
                    data = json.load(f) or {}
                entries = data.get('entries')
                if isinstance(entries, list):
                    return entries
        except Exception as e:
            current_app.logger.error(f"Failed to load dosage index book from {path}: {str(e)}", exc_info=True)
    return []


def _lookup_index_dosage_by_name(drug_name: str):
    key = _normalize_drug_name(drug_name)
    if not key:
        return None
    for entry in _load_dosage_index_book():
        if _normalize_drug_name(entry.get('name')) == key:
            return {
                'indication': entry.get('indication'),
                'contraindication': entry.get('contraindication'),
                'interaction': entry.get('interaction'),
                'side_effects': entry.get('side_effects'),
                'dosage_peds': entry.get('dosage_peds'),
                'dosage_adults': entry.get('dosage_adults'),
                'dosage_geriatrics': entry.get('dosage_geriatrics'),
                'important_notes': entry.get('important_notes'),
            }
    return None


def _get_dosage_ai_client():
    """Get OpenAI client for dosage generation (separate from doctor AIService)"""
    api_key = current_app.config.get('DEEPSEEK_API_KEY')
    if not api_key:
        return None

    try:
        dosage_timeout = float(current_app.config.get('DOSAGE_AI_TIMEOUT_SECONDS') or 1200.0)
    except Exception:
        dosage_timeout = 1200.0
    try:
        return OpenAI(
            api_key=api_key,
            base_url="https://api.deepseek.com/v1",
            # Dosage monographs can be long; allow enough time for model completion.
            timeout=dosage_timeout,
        )
    except Exception as e:
        app.logger.error(f"Failed to create dosage AI client: {e}")
        return None


def _ai_generate_dosage_fields_from_name(drug_name: str, context_entry: dict | None = None):
    """Generate dosage/monograph fields using the configured AI service.

    This is AI-generated content. Admin review is required before clinical use.
    Returns dict with our standard keys or None.
    """
    name = (drug_name or '').strip()
    if not name:
        return None

    api_key = current_app.config.get('DEEPSEEK_API_KEY')
    if not api_key:
        return None

    client = _get_dosage_ai_client()
    if not client:
        app.logger.error(f"Failed to get dosage AI client for '{name}'")
        return None

    # NOTE: Per admin requirement, dosage generation is AI-only.
    # We intentionally do not use any external/index-book context here.

    prompt = (
        "You are an expert clinical pharmacist and physician with 20+ years of experience in clinical medicine, pharmacology, and drug therapy.\n"
        "You have extensive knowledge from medical textbooks, clinical guidelines, peer-reviewed journals, and pharmaceutical references.\n"
        "Generate a comprehensive, professional drug monograph summary for the given medicine.\n\n"
        "INSTRUCTIONS:\n"
        "For each section, provide detailed, evidence-based information appropriate for healthcare providers:\n\n"
        "INDICATION:\n"
        "- List primary therapeutic uses and clinical indications\n"
        "- Include approved indications and common off-label uses when evidence-supported\n"
        "- Be specific about conditions and diseases\n"
        "- Format as bullet points or numbered list for clarity\n\n"
        "CONTRAINDICATION:\n"
        "- List absolute contraindications (conditions where drug must NOT be used)\n"
        "- Include relative contraindications (conditions requiring careful consideration)\n"
        "- Mention contraindications related to drug class, allergy history, and specific patient populations\n"
        "- Include cautionary notes for special populations (pregnancy, lactation, renal/hepatic impairment)\n\n"
        "INTERACTION:\n"
        "- List major and clinically significant drug-drug interactions\n"
        "- Include cytochrome P450 interactions (CYP3A4, CYP2D6, etc.) if applicable\n"
        "- Mention food interactions and significant supplement interactions\n"
        "- Include mechanism and clinical significance of major interactions\n"
        "- Format interactions clearly with drug names and expected effects\n\n"
        "SIDE_EFFECTS:\n"
        "- List common (>10%) and serious adverse effects\n"
        "- Organize by frequency/severity (most frequent/serious first)\n"
        "- Include system-based organization when helpful (GI, CNS, cardiac, etc.)\n"
        "- Mention black box warnings and serious adverse reactions\n"
        "- Include manifestations of overdose or toxicity\n\n"
        "DOSAGE_PEDS (Pediatric dosing):\n"
        "- Provide age-specific or weight-based dosing guidelines\n"
        "- Include neonatal dosing if applicable\n"
        "- Specify routes (oral, IV, IM, etc.) and frequency\n"
        "- Include maximum daily doses for children\n"
        "- Format clearly: 'Age/Weight range: Dose, Route, Frequency'\n\n"
        "DOSAGE_ADULTS (Adult dosing):\n"
        "- Provide standard adult dosing regimens\n"
        "- Include initial, maintenance, and maximum doses\n"
        "- Specify routes (oral, IV, IM, etc.) and frequency\n"
        "- Include dosing adjustments for renal/hepatic impairment if needed\n"
        "- Format clearly: 'Indication: Dose, Route, Frequency'\n\n"
        "DOSAGE_GERIATRICS (Elderly dosing):\n"
        "- Provide age-specific dosing for patients >65-75 years\n"
        "- Include dose reductions when necessary\n"
        "- Mention special considerations (polypharmacy, reduced renal function, etc.)\n"
        "- Include monitoring parameters for elderly patients\n"
        "- Format clearly: 'Starting dose: X, Maintenance dose: Y, Notes on adjustments'\n\n"
        "IMPORTANT_NOTES:\n"
        "- Mechanism of action and pharmacokinetic highlights\n"
        "- Key monitoring parameters (labs, vital signs, clinical signs)\n"
        "- Therapeutic drug levels/monitoring if applicable\n"
        "- Patient counseling points\n"
        "- Stability, storage, and administration considerations\n"
        "- Risk assessment and special precautions\n"
        "- Use in pregnancy/lactation classification if applicable\n\n"
        "SAFETY REQUIREMENTS:\n"
        "- Base all information on established pharmaceutical references and clinical guidelines\n"
        "- If uncertain about specific details, either provide general information or set field to null\n"
        "- Prefer evidence-based, peer-reviewed sources\n"
        "- Do not invent dosages or clinical information\n"
        "- Include appropriate cautions and warnings\n\n"
        f"Drug name: {name}\n"
        "\n"
        "Output STRICT JSON (no markdown) with exactly these keys and no extras: "
        "indication, contraindication, interaction, side_effects, dosage_peds, dosage_adults, dosage_geriatrics, important_notes. "
        "Each value must be a string (formatted with bullet points, line breaks, and clear organization) or null.\n"
        "Ensure the response is comprehensive yet concise, formatted for easy reading by healthcare providers."
    )

    def _generate_field_via_ai(field_key: str) -> str | None:
        """Generate one field as JSON {field_key: <string|null>} to avoid truncation."""
        field_prompt = (
            "You are an expert clinical pharmacist writing content for a clinic management system.\n"
            "Return STRICT JSON (no markdown) with exactly one key and no extras.\n"
            f"Key: {field_key}\n"
            "Value rules: a clinically useful but concise string (use bullet points and line breaks) OR null.\n"
            "Hard limit: keep the value under ~1200 characters to ensure the JSON completes.\n\n"
            f"Drug name: {name}\n"
        )
        try:
            resp = client.chat.completions.create(
                model="deepseek-chat",
                messages=[{"role": "user", "content": field_prompt}],
                temperature=0.2,
                max_tokens=600,
            )
            field_content = (resp.choices[0].message.content or '').strip()
            field_payload = _extract_json_object(field_content)
            if isinstance(field_payload, dict):
                v = field_payload.get(field_key)
                return v.strip() if isinstance(v, str) and v.strip() else None
            return None
        except Exception as e:
            app.logger.warning(
                f"AI per-field generation failed for '{name}' field '{field_key}': {type(e).__name__}: {str(e)}"
            )
            return None

    try:
        app.logger.debug(f"Calling AI for drug '{name}'...")
        response = None
        last_exception: Exception | None = None
        # First attempt: enough tokens for a professional monograph.
        # Retry: smaller output if the first call times out.
        for attempt_max_tokens in (3000, 1800, 900):
            try:
                response = client.chat.completions.create(
                    model="deepseek-chat",
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.2,
                    max_tokens=attempt_max_tokens,
                )
                break
            except Exception as e:
                last_exception = e
                err_name = type(e).__name__
                err_text = str(e).lower()
                is_timeout = ("timeout" in err_name.lower()) or ("timed out" in err_text) or ("timeout" in err_text)
                if is_timeout and attempt_max_tokens != 900:
                    app.logger.warning(
                        f"AI call timed out for '{name}' at max_tokens={attempt_max_tokens}; retrying with fewer tokens"
                    )
                    continue
                raise

        if response is None:
            if last_exception is not None:
                raise last_exception
            return None
        content = (response.choices[0].message.content or '').strip()
        app.logger.debug(f"AI response for '{name}': {content[:200]}...")
        payload = _extract_json_object(content)
        if not payload:
            app.logger.warning(
                f"AI returned non-dict or null payload for '{name}'; falling back to per-field generation"
            )
            payload = {}
            for field_key in [
                'indication',
                'contraindication',
                'interaction',
                'side_effects',
                'dosage_peds',
                'dosage_adults',
                'dosage_geriatrics',
                'important_notes',
            ]:
                payload[field_key] = _generate_field_via_ai(field_key)
        if not isinstance(payload, dict):
            app.logger.warning(f"AI returned non-dict payload for '{name}': {type(payload).__name__}")
            return None

        out = {'source': 'ai'}
        for key in [
            'indication',
            'contraindication',
            'interaction',
            'side_effects',
            'dosage_peds',
            'dosage_adults',
            'dosage_geriatrics',
            'important_notes',
        ]:
            v = payload.get(key)
            if v is None:
                out[key] = None
                continue
            if isinstance(v, str):
                vv = v.strip()
                out[key] = vv if vv else None
            else:
                out[key] = None
        app.logger.info(f"AI generation success for '{name}': {out}")
        return out
    except Exception as e:
        app.logger.error(f"AI dosage generation exception for '{name}': {type(e).__name__}: {str(e)}")
        return None


def _extract_json_object(text: str):
    if not text:
        return None
    
    # Remove markdown code block wrapper if present (LLMs sometimes ignore "no markdown").
    cleaned_text = text.strip()
    if cleaned_text.startswith('```'):
        # Drop the first fence line (``` or ```json or ```JSON, etc.)
        newline_index = cleaned_text.find('\n')
        cleaned_text = cleaned_text[newline_index + 1 :] if newline_index != -1 else ''
    if cleaned_text.endswith('```'):
        cleaned_text = cleaned_text[:-3]
    cleaned_text = cleaned_text.strip()

    # Fast-path: sometimes the model returns raw JSON already.
    if cleaned_text.startswith('{') and cleaned_text.endswith('}'):
        try:
            return json.loads(cleaned_text)
        except Exception:
            pass
    
    # Try to find a JSON object in a free-form response.
    start = cleaned_text.find('{')
    end = cleaned_text.rfind('}')
    if start != -1 and end == -1:
        # This almost always means the response was truncated before closing the JSON object.
        app.logger.debug(
            f"No JSON object found in text (missing closing brace). Start pos: {start}, End pos: {end}, Length: {len(cleaned_text)}"
        )
        return None
    if start == -1 or end == -1 or end <= start:
        app.logger.debug(
            f"No JSON object found in text. Start pos: {start}, End pos: {end}, Length: {len(cleaned_text)}"
        )
        return None
    
    candidate = cleaned_text[start:end + 1]
    try:
        result = json.loads(candidate)
        app.logger.debug(f"Successfully extracted JSON object from text")
        return result
    except Exception as e:
        app.logger.error(f"Failed to parse extracted JSON: {type(e).__name__}: {str(e)}\nCandidate text (first 300 chars): {candidate[:300]}")
        return None


def _ai_structure_dosage_fields(drug_name: str, base_entry: dict | None):
    """Use configured AI (DeepSeek via AIService) to structure label text into our dosage fields.

    Safety: the model is instructed to ONLY reorganize/condense provided text (no invention).
    If AI is not configured or fails, returns base_entry unchanged.
    """
    if not isinstance(base_entry, dict):
        return base_entry

    api_key = current_app.config.get('DEEPSEEK_API_KEY')
    if not api_key:
        return base_entry

    try:
        client = AIService.get_client()
    except Exception:
        return base_entry

    prompt = (
        "You are an expert clinical pharmacist reorganizing pharmaceutical documentation for a clinical management system.\n"
        "Task: Extract and restructure the provided excerpts into structured database fields.\n\n"
        "GUIDELINES FOR STRUCTURING:\n\n"
        "INDICATION:\n"
        "- Extract and reorganize approved indications and therapeutic uses\n"
        "- Use bullet points or numbered format\n"
        "- Be specific about conditions and patient populations\n\n"
        "CONTRAINDICATION:\n"
        "- Extract absolute and relative contraindications\n"
        "- Clearly distinguish between absolute (must not use) and relative (use with caution)\n"
        "- Include special population considerations\n\n"
        "INTERACTION:\n"
        "- List clinically significant drug-drug interactions\n"
        "- Include mechanism if provided in excerpts\n"
        "- Format clearly with interacting drug and clinical significance\n\n"
        "SIDE_EFFECTS:\n"
        "- Organize by frequency or severity\n"
        "- Include serious adverse reactions and black box warnings\n"
        "- Use clear formatting for easy scanning\n\n"
        "DOSAGE_PEDS:\n"
        "- Extract pediatric dosing with age/weight parameters\n"
        "- Include all dosage forms and routes mentioned\n"
        "- Format as: 'Age/Weight: Dose, Route, Frequency'\n\n"
        "DOSAGE_ADULTS:\n"
        "- Extract standard adult dosing with clear indications\n"
        "- Include initial, maintenance, and maximum doses\n"
        "- Format as: 'Indication: Dose, Route, Frequency'\n\n"
        "DOSAGE_GERIATRICS:\n"
        "- Extract geriatric-specific dosing and adjustments\n"
        "- Include age-related considerations and monitoring\n\n"
        "IMPORTANT_NOTES:\n"
        "- Extract mechanism of action\n"
        "- Include key monitoring parameters and therapeutic levels\n"
        "- Add storage, administration, and clinical considerations\n"
        "- Include pregnancy/lactation information if available\n\n"
        "CRITICAL RULES:\n"
        "- Do NOT invent or add information not in the excerpts\n"
        "- Do NOT use general medical knowledge beyond text reorganization\n"
        "- Use verbatim phrases when possible; light reformatting is acceptable\n"
        "- Preserve all clinical details and numerical values exactly\n"
        "- If an excerpt doesn't contain enough information for a field, return null\n"
        "- Organize for clarity and clinical utility\n\n"
        f"Drug name: {drug_name}\n\n"
        "Provided excerpts (may be incomplete):\n"
        f"INDICATIONS_AND_USAGE:\n{base_entry.get('indication') or '[Not provided]'}\n\n"
        f"CONTRAINDICATIONS:\n{base_entry.get('contraindication') or '[Not provided]'}\n\n"
        f"DRUG_INTERACTIONS:\n{base_entry.get('interaction') or '[Not provided]'}\n\n"
        f"ADVERSE_REACTIONS:\n{base_entry.get('side_effects') or '[Not provided]'}\n\n"
        f"DOSAGE_AND_ADMINISTRATION:\n{base_entry.get('dosage_adults') or '[Not provided]'}\n\n"
        f"PEDIATRIC_DOSING:\n{base_entry.get('dosage_peds') or '[Not provided]'}\n\n"
        f"WARNINGS_AND_PRECAUTIONS:\n{base_entry.get('important_notes') or '[Not provided]'}\n\n"
        "Output format:\n"
        "Return STRICT JSON (no markdown) with these exact keys only: "
        "indication, contraindication, interaction, side_effects, dosage_peds, dosage_adults, dosage_geriatrics, important_notes.\n"
        "Each value must be a well-formatted string (with bullet points, line breaks for readability) or null.\n"
        "Ensure organized, professional formatting suitable for healthcare provider reference."
    )

    try:
        response = client.chat.completions.create(
            model=AIService.MODELS.get('primary', 'deepseek-chat'),
            messages=[{"role": "user", "content": prompt}],
            temperature=0.1,
            max_tokens=700,
        )
        content = (response.choices[0].message.content or '').strip()
        payload = _extract_json_object(content)
        if not isinstance(payload, dict):
            return base_entry

        out = dict(base_entry)
        for key in [
            'indication',
            'contraindication',
            'interaction',
            'side_effects',
            'dosage_peds',
            'dosage_adults',
            'dosage_geriatrics',
            'important_notes',
        ]:
            v = payload.get(key)
            if v is None:
                continue
            if isinstance(v, str) and v.strip():
                out[key] = v.strip()
        out['source'] = f"{base_entry.get('source') or 'index'}+ai"
        return out
    except Exception as e:
        try:
            current_app.logger.warning(f"AI dosage structuring failed for '{drug_name}': {str(e)}")
        except Exception:
            pass
        return base_entry


def _is_blank(value):
    return value is None or (isinstance(value, str) and not value.strip())


def _ai_dosage_agent_state_path():
    try:
        os.makedirs(app.instance_path, exist_ok=True)
    except Exception:
        pass
    return os.path.join(app.instance_path, 'ai_dosage_agent.json')


def _ai_dosage_jobs_dir() -> str:
    try:
        os.makedirs(app.instance_path, exist_ok=True)
    except Exception:
        pass
    path = os.path.join(app.instance_path, 'ai_dosage_jobs')
    try:
        os.makedirs(path, exist_ok=True)
    except Exception:
        pass
    return path


def _ai_dosage_job_path(job_id: str) -> str:
    safe = ''.join([c for c in (job_id or '') if c.isalnum() or c in ('-', '_')])
    return os.path.join(_ai_dosage_jobs_dir(), f'{safe}.json')


def _write_ai_job_state(job_id: str, state: dict) -> None:
    path = _ai_dosage_job_path(job_id)
    tmp = path + '.tmp'
    try:
        with open(tmp, 'w', encoding='utf-8') as f:
            json.dump(state, f, ensure_ascii=False, indent=2)
        os.replace(tmp, path)
    except Exception:
        try:
            if os.path.exists(tmp):
                os.remove(tmp)
        except Exception:
            pass


def _read_ai_job_state(job_id: str) -> dict | None:
    path = _ai_dosage_job_path(job_id)
    try:
        if not os.path.exists(path):
            return None
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f) or None
    except Exception:
        return None


def _truncate_for_table(value: str | None, limit: int = 50) -> str:
    if not value:
        return '-'
    s = str(value).strip()
    if not s:
        return '-'
    return (s[: max(0, limit - 3)] + '...') if len(s) > limit else s


def _is_db_disconnect_error(exc: Exception) -> bool:
    """Best-effort detection of transient DB disconnects (common with Postgres+SSL)."""
    try:
        msg = str(exc).lower()
    except Exception:
        msg = ''
    needles = [
        'ssl connection has been closed unexpectedly',
        'server closed the connection unexpectedly',
        'connection reset by peer',
        'connection refused',
        'could not receive data from server',
        'terminating connection due to administrator command',
        'connection timed out',
        'broken pipe',
    ]
    return any(n in msg for n in needles)


def _recover_db_connection(reason: str) -> None:
    """Dispose SQLAlchemy engine + reset session so next checkout gets a fresh connection."""
    try:
        db.session.rollback()
    except Exception:
        pass
    try:
        db.session.remove()
    except Exception:
        pass
    try:
        db.engine.dispose()
    except Exception:
        pass
    try:
        app.logger.warning(f"DB connection recovered after disconnect: {reason}")
    except Exception:
        pass


def _ai_dosage_job_thread(*, job_id: str, kind: str, mode: str, limit: int | None, requested_by_user_id: int):
    """Runs a dosage generation job and persists progress to an instance JSON file.

    mode:
      - 'full': create missing + fill missing fields
      - 'fill': only fill missing fields on existing dosage rows
    """
    with app.app_context():
        # Ensure this background thread starts with a fresh session/connection.
        try:
            db.session.remove()
        except Exception:
            pass
        state = _read_ai_job_state(job_id) or {}
        state.setdefault('updates', [])
        state.setdefault('update_seq', 0)

        def push_update(update: dict):
            state['update_seq'] = int(state.get('update_seq') or 0) + 1
            update['seq'] = state['update_seq']
            # Keep last 100 updates only
            updates = list(state.get('updates') or [])
            updates.append(update)
            state['updates'] = updates[-100:]

        def set_status(status: str, message: str | None = None):
            state['status'] = status
            state['updated_at'] = get_eat_now().isoformat()
            if message:
                state['message'] = message
            _write_ai_job_state(job_id, state)

        try:
            # Build work queue
            kind_norm = (kind or 'drug').strip().lower()
            if kind_norm not in ('drug', 'controlled'):
                kind_norm = 'drug'

            mode_norm = (mode or 'full').strip().lower()
            if mode_norm not in ('full', 'fill'):
                mode_norm = 'full'

            create_limit = 0 if mode_norm == 'fill' else int(limit or 10)
            update_limit = int(limit or 10)

            # Keep interactive jobs conservative but responsive
            ai_generation_limit = int(limit or 10)
            # Interactive job time budget (avoid runaway jobs but allow slow AI).
            # Configurable via AI_DOSAGE_JOB_MAX_RUN_SECONDS.
            try:
                max_run_seconds = int(current_app.config.get('AI_DOSAGE_JOB_MAX_RUN_SECONDS') or 1200)
            except Exception:
                max_run_seconds = 1200

            queue: list[dict] = []

            if mode_norm == 'full' and create_limit > 0:
                if kind_norm == 'drug':
                    missing = Drug.query.filter(~Drug.dosages.any()).limit(create_limit).all()
                    for d in missing:
                        queue.append({'action': 'create', 'kind': 'drug', 'drug_id': d.id})
                else:
                    missing = ControlledDrug.query.filter(~ControlledDrug.dosages.any()).limit(create_limit).all()
                    for d in missing:
                        queue.append({'action': 'create', 'kind': 'controlled', 'drug_id': d.id})

            if update_limit > 0:
                if kind_norm == 'drug':
                    rows = (
                        DrugDosage.query.join(Drug)
                        .filter(_dosage_missing_filter(DrugDosage))
                        .limit(update_limit)
                        .all()
                    )
                    for r in rows:
                        queue.append({'action': 'fill', 'kind': 'drug', 'dosage_id': r.id})
                else:
                    rows = (
                        ControlledDrugDosage.query.join(ControlledDrug)
                        .filter(_dosage_missing_filter(ControlledDrugDosage))
                        .limit(update_limit)
                        .all()
                    )
                    for r in rows:
                        queue.append({'action': 'fill', 'kind': 'controlled', 'dosage_id': r.id})

            planned_total = min(int(ai_generation_limit or 0), len(queue))
            queue = queue[:planned_total]

            state.update({
                'job_id': job_id,
                'kind': kind_norm,
                'mode': mode_norm,
                'requested_by_user_id': requested_by_user_id,
                'status': 'running',
                'total': planned_total,
                'processed': 0,
                'completed': 0,
                'failed': 0,
                'created': 0,
                'updated_records': 0,
                'filled_fields': 0,
                'errors': 0,
                'started_at': state.get('started_at') or get_eat_now().isoformat(),
                'updated_at': get_eat_now().isoformat(),
            })
            _write_ai_job_state(job_id, state)

            started = monotonic()
            ai_budget = planned_total

            for item in queue:
                if ai_budget <= 0:
                    break
                if max_run_seconds and (monotonic() - started) > max_run_seconds:
                    break

                state['processed'] = int(state.get('processed') or 0) + 1
                state['updated_at'] = get_eat_now().isoformat()

                try:
                    if item['kind'] == 'drug':
                        if item['action'] == 'create':
                            drug = _db_get(Drug, item['drug_id'])
                            if not drug:
                                raise Exception('Drug not found')
                            suggestion = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
                            ai_budget -= 1
                            if not suggestion:
                                state['failed'] = int(state.get('failed') or 0) + 1
                                _write_ai_job_state(job_id, state)
                                continue
                            dosage = DrugDosage(drug_id=drug.id, source='ai')
                            changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                            if not changed:
                                state['failed'] = int(state.get('failed') or 0) + 1
                                _write_ai_job_state(job_id, state)
                                continue
                            state['filled_fields'] = int(state.get('filled_fields') or 0) + int(changed)
                            db.session.add(dosage)
                            db.session.commit()
                            state['created'] = int(state.get('created') or 0) + 1
                            state['completed'] = int(state.get('completed') or 0) + 1
                            push_update({
                                'kind': 'drug',
                                'drug_id': drug.id,
                                'dosage_id': dosage.id,
                                'indication': _truncate_for_table(dosage.indication, 50),
                                'dosage_adults': _truncate_for_table(dosage.dosage_adults, 50),
                                'dosage_peds': _truncate_for_table(dosage.dosage_peds, 50),
                            })
                            _write_ai_job_state(job_id, state)
                            continue

                        # fill existing dosage
                        dosage = _db_get(DrugDosage, item['dosage_id'])
                        if not dosage or not dosage.drug_record:
                            raise Exception('Dosage not found')
                        suggestion = _ai_generate_dosage_fields_from_name(dosage.drug_record.name, context_entry=None)
                        ai_budget -= 1
                        if not suggestion:
                            state['failed'] = int(state.get('failed') or 0) + 1
                            _write_ai_job_state(job_id, state)
                            continue
                        changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                        if not changed:
                            state['failed'] = int(state.get('failed') or 0) + 1
                            _write_ai_job_state(job_id, state)
                            continue
                        try:
                            dosage.source = 'ai'
                        except Exception:
                            pass
                        state['filled_fields'] = int(state.get('filled_fields') or 0) + int(changed)
                        db.session.commit()
                        state['updated_records'] = int(state.get('updated_records') or 0) + 1
                        state['completed'] = int(state.get('completed') or 0) + 1
                        push_update({
                            'kind': 'drug',
                            'drug_id': dosage.drug_record.id,
                            'dosage_id': dosage.id,
                            'indication': _truncate_for_table(dosage.indication, 50),
                            'dosage_adults': _truncate_for_table(dosage.dosage_adults, 50),
                            'dosage_peds': _truncate_for_table(dosage.dosage_peds, 50),
                        })
                        _write_ai_job_state(job_id, state)
                        continue

                    # controlled
                    if item['action'] == 'create':
                        drug = _db_get(ControlledDrug, item['drug_id'])
                        if not drug:
                            raise Exception('Controlled drug not found')
                        suggestion = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
                        ai_budget -= 1
                        if not suggestion:
                            state['failed'] = int(state.get('failed') or 0) + 1
                            _write_ai_job_state(job_id, state)
                            continue
                        dosage = ControlledDrugDosage(controlled_drug_id=drug.id, source='ai')
                        changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                        if not changed:
                            state['failed'] = int(state.get('failed') or 0) + 1
                            _write_ai_job_state(job_id, state)
                            continue
                        state['filled_fields'] = int(state.get('filled_fields') or 0) + int(changed)
                        db.session.add(dosage)
                        db.session.commit()
                        state['created'] = int(state.get('created') or 0) + 1
                        state['completed'] = int(state.get('completed') or 0) + 1
                        push_update({
                            'kind': 'controlled',
                            'drug_id': drug.id,
                            'dosage_id': dosage.id,
                            'indication': _truncate_for_table(dosage.indication, 50),
                            'dosage_adults': _truncate_for_table(dosage.dosage_adults, 50),
                            'dosage_peds': _truncate_for_table(dosage.dosage_peds, 50),
                        })
                        _write_ai_job_state(job_id, state)
                        continue

                    dosage = _db_get(ControlledDrugDosage, item['dosage_id'])
                    if not dosage or not dosage.controlled_drug_record:
                        raise Exception('Controlled dosage not found')
                    suggestion = _ai_generate_dosage_fields_from_name(dosage.controlled_drug_record.name, context_entry=None)
                    ai_budget -= 1
                    if not suggestion:
                        state['failed'] = int(state.get('failed') or 0) + 1
                        _write_ai_job_state(job_id, state)
                        continue
                    changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                    if not changed:
                        state['failed'] = int(state.get('failed') or 0) + 1
                        _write_ai_job_state(job_id, state)
                        continue
                    try:
                        dosage.source = 'ai'
                    except Exception:
                        pass
                    state['filled_fields'] = int(state.get('filled_fields') or 0) + int(changed)
                    db.session.commit()
                    state['updated_records'] = int(state.get('updated_records') or 0) + 1
                    state['completed'] = int(state.get('completed') or 0) + 1
                    push_update({
                        'kind': 'controlled',
                        'drug_id': dosage.controlled_drug_record.id,
                        'dosage_id': dosage.id,
                        'indication': _truncate_for_table(dosage.indication, 50),
                        'dosage_adults': _truncate_for_table(dosage.dosage_adults, 50),
                        'dosage_peds': _truncate_for_table(dosage.dosage_peds, 50),
                    })
                    _write_ai_job_state(job_id, state)
                except Exception as e:
                    state['errors'] = int(state.get('errors') or 0) + 1
                    state['failed'] = int(state.get('failed') or 0) + 1
                    try:
                        db.session.rollback()
                    except Exception:
                        pass
                    # If Postgres SSL dropped mid-run, recover and keep going.
                    try:
                        import sqlalchemy
                        is_operational = isinstance(e, sqlalchemy.exc.OperationalError)
                    except Exception:
                        is_operational = False
                    if is_operational and _is_db_disconnect_error(e):
                        _recover_db_connection('ai_dosage_job_thread item')
                    _write_ai_job_state(job_id, state)

            state['status'] = 'complete'
            state['updated_at'] = get_eat_now().isoformat()
            _write_ai_job_state(job_id, state)
        except Exception as e:
            try:
                db.session.rollback()
            except Exception:
                pass
            state['status'] = 'failed'
            state['errors'] = int(state.get('errors') or 0) + 1
            state['message'] = str(e)
            state['updated_at'] = get_eat_now().isoformat()
            _write_ai_job_state(job_id, state)



def _get_ai_dosage_agent_enabled() -> bool:
    """Returns True if the background dosage agent is enabled."""
    path = _ai_dosage_agent_state_path()
    try:
        if os.path.exists(path):
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f) or {}
            return bool(data.get('enabled', False))
    except Exception:
        return False
    return False


def _set_ai_dosage_agent_enabled(enabled: bool):
    path = _ai_dosage_agent_state_path()
    try:
        payload = {
            'enabled': bool(enabled),
            'updated_at': get_eat_now().isoformat(),
        }
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(payload, f, ensure_ascii=False, indent=2)
    except Exception as e:
        try:
            current_app.logger.error(f"Failed to persist AI dosage agent state: {str(e)}", exc_info=True)
        except Exception:
            pass


def _apply_dosage_suggestion_to_model(dosage_obj, suggestion: dict):
    """Apply suggestion onto dosage model, but only for empty fields."""
    changed = 0
    if not isinstance(suggestion, dict):
        return 0

    if _is_blank(dosage_obj.indication) and suggestion.get('indication'):
        dosage_obj.indication = suggestion.get('indication'); changed += 1
    if _is_blank(dosage_obj.contraindication) and suggestion.get('contraindication'):
        dosage_obj.contraindication = suggestion.get('contraindication'); changed += 1
    if _is_blank(dosage_obj.interaction) and suggestion.get('interaction'):
        dosage_obj.interaction = suggestion.get('interaction'); changed += 1
    if _is_blank(dosage_obj.side_effects) and suggestion.get('side_effects'):
        dosage_obj.side_effects = suggestion.get('side_effects'); changed += 1
    if _is_blank(dosage_obj.dosage_peds) and suggestion.get('dosage_peds'):
        dosage_obj.dosage_peds = suggestion.get('dosage_peds'); changed += 1
    if _is_blank(dosage_obj.dosage_adults) and suggestion.get('dosage_adults'):
        dosage_obj.dosage_adults = suggestion.get('dosage_adults'); changed += 1
    if _is_blank(dosage_obj.dosage_geriatrics) and suggestion.get('dosage_geriatrics'):
        dosage_obj.dosage_geriatrics = suggestion.get('dosage_geriatrics'); changed += 1
    if _is_blank(dosage_obj.important_notes) and suggestion.get('important_notes'):
        dosage_obj.important_notes = suggestion.get('important_notes'); changed += 1

    return changed


def _dosage_missing_filter(model_cls):
    # Filter rows that have at least one empty/null field.
    return or_(
        model_cls.indication.is_(None), model_cls.indication == '',
        model_cls.contraindication.is_(None), model_cls.contraindication == '',
        model_cls.interaction.is_(None), model_cls.interaction == '',
        model_cls.side_effects.is_(None), model_cls.side_effects == '',
        model_cls.dosage_peds.is_(None), model_cls.dosage_peds == '',
        model_cls.dosage_adults.is_(None), model_cls.dosage_adults == '',
        model_cls.dosage_geriatrics.is_(None), model_cls.dosage_geriatrics == '',
        model_cls.important_notes.is_(None), model_cls.important_notes == '',
    )


# Best-effort in-process guard to prevent overlapping runs (e.g., scheduler + manual run-now).
# Note: this is per-process; in multi-worker deployments, APScheduler's max_instances helps,
# and admin-triggered runs should be rare.
_AI_DOSAGE_AGENT_LOCK = threading.Lock()




def run_ai_dosage_agent_once(
    kind: str = 'both',
    create_limit: int = 50,
    update_limit: int = 50,
    ai_generation_limit: int = 50,
    max_run_seconds: int = 300,
):
    """Creates missing dosage rows and fills missing fields (does not overwrite existing values).

    kind: 'drug' | 'controlled' | 'both'

    Notes on scaling:
    - create/update limits can be large (e.g., 10,000) because DB operations are local.
    - ai_generation_limit and max_run_seconds prevent runaway background runs.
    """
    if current_app.config.get('FAST_DEV'):
        return {
            'enabled': False,
            'created': 0,
            'updated_records': 0,
            'filled_fields': 0,
            'reason': 'FAST_DEV enabled: AI dosage agent disabled for faster debugging.'
        }
    if not _get_ai_dosage_agent_enabled():
        return {'enabled': False, 'created': 0, 'updated_records': 0, 'filled_fields': 0, 'reason': 'Agent is disabled.'}

    if not _AI_DOSAGE_AGENT_LOCK.acquire(blocking=False):
        return {
            'enabled': True,
            'created': 0,
            'updated_records': 0,
            'filled_fields': 0,
            'errors': 0,
            'reason': 'Another AI dosage agent run is already in progress.',
        }

    created = 0
    updated_records = 0
    filled_fields = 0

    errors = 0
    ai_budget = max(0, int(ai_generation_limit or 0))
    started = monotonic()

    # Keep transactions short to avoid losing all progress if the process/request dies.
    # Also reduces SQLite/MySQL lock contention.
    db_batch_size = 25
    pending_writes = 0

    def _commit_batch():
        nonlocal errors, pending_writes
        if pending_writes <= 0:
            return
        try:
            db.session.commit()
            pending_writes = 0
        except Exception:
            errors += 1
            pending_writes = 0
            try:
                db.session.rollback()
            except Exception:
                pass

    if not current_app.config.get('DEEPSEEK_API_KEY'):
        msg = 'DEEPSEEK_API_KEY not configured. Set it in environment/config to use AI generation.'
        try:
            current_app.logger.warning(msg)
        except Exception:
            pass
        return {
            'enabled': True,
            'created': 0,
            'updated_records': 0,
            'filled_fields': 0,
            'errors': 1,
            'reason': msg,
        }

    kind_norm = (kind or 'both').strip().lower()
    if kind_norm not in ('drug', 'controlled', 'both'):
        kind_norm = 'both'

    def get_suggestion(name: str):
        nonlocal ai_budget
        if ai_budget <= 0:
            return None
        suggestion = _ai_generate_dosage_fields_from_name(name, context_entry=None)
        ai_budget -= 1
        return suggestion

    try:
        # 1) Create missing dosage rows for normal drugs
        if kind_norm in ('drug', 'both'):
            missing_drugs = Drug.query.filter(~Drug.dosages.any()).limit(max(0, int(create_limit or 0))).all()
            app.logger.info(f"Agent: Found {len(missing_drugs)} drugs without dosage (kind=drug)")
            for drug in missing_drugs:
                if max_run_seconds and (monotonic() - started) > max_run_seconds:
                    break
                try:
                    suggestion = get_suggestion(drug.name)
                    app.logger.debug(f"AI suggestion for '{drug.name}': {suggestion}")
                    if not suggestion:
                        app.logger.info(f"Skipped {drug.name}: AI returned None")
                        continue
                    dosage = DrugDosage(drug_id=drug.id, source='ai')
                    changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                    app.logger.debug(f"Applied {changed} fields to {drug.name} dosage")
                    if changed:
                        try:
                            dosage.source = 'ai'
                        except Exception:
                            pass
                        filled_fields += changed
                        db.session.add(dosage)
                        created += 1
                        pending_writes += 1
                        app.logger.info(f"Created dosage for {drug.name} (fields: {changed})")
                    else:
                        app.logger.info(f"Skipped {drug.name}: suggestion had no fields to apply")
                except Exception as e:
                    app.logger.error(f"Error creating dosage for {drug.name}: {e}")
                    errors += 1
                    try:
                        db.session.rollback()
                    except Exception:
                        pass
                    pending_writes = 0
                    continue

                if pending_writes >= db_batch_size:
                    _commit_batch()

        # 2) Create missing dosage rows for controlled drugs
        if kind_norm in ('controlled', 'both'):
            missing_controlled = ControlledDrug.query.filter(~ControlledDrug.dosages.any()).limit(max(0, int(create_limit or 0))).all()
            app.logger.info(f"Agent: Found {len(missing_controlled)} controlled drugs without dosage (kind=controlled)")
            for drug in missing_controlled:
                if max_run_seconds and (monotonic() - started) > max_run_seconds:
                    break
                try:
                    suggestion = get_suggestion(drug.name)
                    app.logger.debug(f"AI suggestion for '{drug.name}': {suggestion}")
                    if not suggestion:
                        app.logger.info(f"Skipped {drug.name}: AI returned None")
                        continue
                    dosage = ControlledDrugDosage(controlled_drug_id=drug.id, source='ai')
                    changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                    app.logger.debug(f"Applied {changed} fields to {drug.name} dosage")
                    if changed:
                        try:
                            dosage.source = 'ai'
                        except Exception:
                            pass
                        filled_fields += changed
                        db.session.add(dosage)
                        created += 1
                        pending_writes += 1
                        app.logger.info(f"Created dosage for {drug.name} (fields: {changed})")
                    else:
                        app.logger.info(f"Skipped {drug.name}: suggestion had no fields to apply")
                except Exception as e:
                    app.logger.error(f"Error creating dosage for {drug.name}: {e}")
                    errors += 1
                    try:
                        db.session.rollback()
                    except Exception:
                        pass
                    pending_writes = 0
                    continue

                if pending_writes >= db_batch_size:
                    _commit_batch()

        # 3) Fill missing fields for existing rows
        # Normal
        if update_limit and int(update_limit) > 0:
            if kind_norm in ('drug', 'both'):
                candidates = (
                    DrugDosage.query.join(Drug)
                    .filter(_dosage_missing_filter(DrugDosage))
                    .limit(int(update_limit))
                    .all()
                )
                for dosage in candidates:
                    if max_run_seconds and (monotonic() - started) > max_run_seconds:
                        break
                    try:
                        drug = dosage.drug_record
                        suggestion = get_suggestion(drug.name)
                        if not suggestion:
                            continue
                        before = filled_fields
                        changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                        if changed:
                            try:
                                dosage.source = 'ai'
                            except Exception:
                                pass
                        filled_fields += changed
                        if filled_fields > before:
                            updated_records += 1
                            pending_writes += 1
                    except Exception:
                        errors += 1
                        try:
                            db.session.rollback()
                        except Exception:
                            pass
                        pending_writes = 0
                        continue

                    if pending_writes >= db_batch_size:
                        _commit_batch()

            if kind_norm in ('controlled', 'both'):
                candidates = (
                    ControlledDrugDosage.query.join(ControlledDrug)
                    .filter(_dosage_missing_filter(ControlledDrugDosage))
                    .limit(int(update_limit))
                    .all()
                )
                for dosage in candidates:
                    if max_run_seconds and (monotonic() - started) > max_run_seconds:
                        break
                    try:
                        drug = dosage.controlled_drug_record
                        suggestion = get_suggestion(drug.name)
                        if not suggestion:
                            continue
                        before = filled_fields
                        changed = _apply_dosage_suggestion_to_model(dosage, suggestion)
                        if changed:
                            try:
                                dosage.source = 'ai'
                            except Exception:
                                pass
                        filled_fields += changed
                        if filled_fields > before:
                            updated_records += 1
                            pending_writes += 1
                    except Exception:
                        errors += 1
                        try:
                            db.session.rollback()
                        except Exception:
                            pass
                        pending_writes = 0
                        continue

                    if pending_writes >= db_batch_size:
                        _commit_batch()

        # Final commit for any remaining work
        _commit_batch()
    finally:
        try:
            _AI_DOSAGE_AGENT_LOCK.release()
        except Exception:
            pass
    
    reason = None
    if created == 0 and updated_records == 0 and filled_fields == 0:
        # Check why nothing was done
        try:
            drug_total = Drug.query.count()
            drug_missing = Drug.query.filter(~Drug.dosages.any()).count()
            controlled_total = ControlledDrug.query.count()
            controlled_missing = ControlledDrug.query.filter(~ControlledDrug.dosages.any()).count()
            
            app.logger.info(f"Diagnostic: Drug total={drug_total}, missing={drug_missing} | Controlled total={controlled_total}, missing={controlled_missing} | kind={kind}")
            
            if kind in ('drug', 'both') and drug_missing == 0:
                reason = f'No drug dosages missing. ({drug_total} drugs, all have dosage)'
            elif kind in ('controlled', 'both') and controlled_missing == 0:
                reason = f'No controlled drug dosages missing. ({controlled_total} controlled drugs, all have dosage)'
            elif drug_missing == 0 and controlled_missing == 0:
                reason = f'No missing dosages found. (Drug: {drug_total}, Controlled: {controlled_total})'
            elif ai_budget == 0:
                reason = 'AI generation budget exhausted.'
        except Exception as e:
            app.logger.error(f"Diagnostic check failed: {e}")
    
    result = {
        'enabled': True,
        'created': created,
        'updated_records': updated_records,
        'filled_fields': filled_fields,
        'ai_generation_remaining': ai_budget,
        'errors': errors,
    }
    if reason:
        result['reason'] = reason
    return result



def scheduled_ai_dosage_agent():
    """Background job runner; safe to run periodically."""
    with app.app_context():
        if not _get_ai_dosage_agent_enabled():
            return

        # Retry once on transient Postgres disconnects (common with SSL idle timeouts).
        last_exc: Exception | None = None
        for attempt in (1, 2):
            try:
                # Start clean each attempt.
                try:
                    db.session.remove()
                except Exception:
                    pass

                # Aggressive DB processing, bounded external/API usage.
                result = run_ai_dosage_agent_once(
                    kind='both',
                    create_limit=50,
                    update_limit=50,
                    ai_generation_limit=50,
                    max_run_seconds=300,
                )
                app.logger.info(f"AI dosage agent ran: {result}")
                return
            except Exception as e:
                last_exc = e
                # If DB connection dropped, recover and retry once.
                try:
                    import sqlalchemy
                    is_operational = isinstance(e, sqlalchemy.exc.OperationalError)
                except Exception:
                    is_operational = False
                if attempt == 1 and is_operational and _is_db_disconnect_error(e):
                    _recover_db_connection('scheduled_ai_dosage_agent')
                    continue
                break

        try:
            db.session.rollback()
        except Exception:
            pass
        app.logger.error(f"AI dosage agent error: {str(last_exc) if last_exc else 'unknown'}", exc_info=True)

class Patient(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    op_number = db.Column(db.String(500), unique=True, nullable=True)  # Increased from 20
    ip_number = db.Column(db.String(500), unique=True, nullable=True)  # Increased from 20
    name = db.Column(db.Text, nullable=True)
    age = db.Column(db.Integer, nullable=True)
    gender = db.Column(db.String(200), nullable=True)  # Increased from 10
    address = db.Column(db.Text, nullable=True)
    phone = db.Column(db.Text, nullable=True)
    destination = db.Column(db.Text, nullable=True)
    occupation = db.Column(db.Text, nullable=True)
    religion = db.Column(db.String(500), nullable=True)
    nok_name = db.Column(db.Text, nullable=True)
    nok_contact = db.Column(db.Text, nullable=True)
    tca = db.Column(db.Date, nullable=True)
    date_of_admission = db.Column(db.Date, nullable=True)
    status = db.Column(db.String(250), default='active', nullable=True)
    # Discharge workflow (mainly for inpatients). Kept additive to avoid breaking existing features.
    # discharge_state: none | pending | discharged
    discharge_state = db.Column(db.String(20), default='none')
    discharge_requested_at = db.Column(db.DateTime)
    discharge_requested_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    discharged_at = db.Column(db.DateTime)
    discharged_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    chief_complaint = db.Column(db.Text, nullable=True)
    history_present_illness = db.Column(db.Text, nullable=True)
    
    # Outpatient department assignment (for outpatient visits)
    department_id = db.Column(db.Integer, db.ForeignKey('outpatient_departments.id'), nullable=True)
    
    # Assistant Integration Fields
    ai_assistance_enabled = db.Column(db.Boolean, default=False)
    ai_diagnosis = db.Column(db.Text)
    ai_treatment_recommendations = db.Column(db.Text)
    ai_last_updated = db.Column(db.DateTime)
    ai_confidence_score = db.Column(db.Float)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships
    reviews = db.relationship('PatientReviewSystem', backref='patient', lazy=True)
    histories = db.relationship('PatientHistory', backref='patient', lazy=True)
    examinations = db.relationship('PatientExamination', backref='patient', lazy=True)
    diagnoses = db.relationship('PatientDiagnosis', backref='patient', lazy=True)
    management = db.relationship('PatientManagement', backref='patient', lazy=True)
    # lab_requests relationship defined in LabRequest model with cascade rules
    # imaging_requests relationship defined in ImagingRequest model with cascade rules
    summaries = db.relationship('PatientSummary', back_populates='patient', lazy=True)
    department = db.relationship('OutpatientDepartment', backref='patients')

    discharge_requester = db.relationship('User', foreign_keys=[discharge_requested_by])
    discharger = db.relationship('User', foreign_keys=[discharged_by])

    @staticmethod
    def _safe_decrypt(value) -> str:
        """Best-effort decrypt for fields stored via Config.encrypt_data_static.

        Handles mixed datasets where older rows may be plaintext.
        """
        if value is None:
            return ""
        s = str(value)
        if not s:
            return ""

        # Fernet tokens generated by cryptography typically start with 'gAAAA'.
        # If it doesn't look like a token, treat as plaintext.
        if not s.startswith("gAAAA"):
            return s

        try:
            decrypted = Config.decrypt_data_static(s)
            if decrypted.startswith("[Decryption Error"):
                return s
            return decrypted
        except Exception:
            return s

    @property
    def get_decrypted_name(self) -> str:
        return self._safe_decrypt(self.name)

    # Template-friendly aliases (older templates reference `patient.decrypted_*`).
    @property
    def decrypted_name(self) -> str:
        return self.get_decrypted_name

    @property
    def get_decrypted_address(self) -> str:
        return self._safe_decrypt(self.address)

    @property
    def decrypted_address(self) -> str:
        return self.get_decrypted_address

    @property
    def get_decrypted_phone(self) -> str:
        return self._safe_decrypt(self.phone)

    @property
    def decrypted_phone(self) -> str:
        return self.get_decrypted_phone

    @property
    def get_decrypted_occupation(self) -> str:
        return self._safe_decrypt(self.occupation)

    @property
    def decrypted_occupation(self) -> str:
        return self.get_decrypted_occupation

    @property
    def get_decrypted_nok_name(self) -> str:
        return self._safe_decrypt(self.nok_name)

    @property
    def decrypted_nok_name(self) -> str:
        return self.get_decrypted_nok_name

    @property
    def get_decrypted_nok_contact(self) -> str:
        return self._safe_decrypt(self.nok_contact)

    @property
    def decrypted_nok_contact(self) -> str:
        return self.get_decrypted_nok_contact

    def get_ai_recommendations(self):
        """Return formatted AI recommendations if available"""
        if not self.ai_assistance_enabled or not self.ai_diagnosis:
            return None
        
        return {
            'diagnosis': self.ai_diagnosis,
            'treatment': self.ai_treatment_recommendations,
            'last_updated': self.ai_last_updated.strftime('%Y-%m-%d %H:%M') if self.ai_last_updated else None,
            'confidence': f"{round(self.ai_confidence_score * 100, 1)}%" if self.ai_confidence_score else None
        }
    
    def get_ai_summary(self):
        """Generate a concise summary of AI findings"""
        if not self.ai_assistance_enabled:
            return "AI assistance not enabled for this patient"
        
        summary = []
        if self.ai_diagnosis:
            summary.append(f"AI Diagnosis: {self.ai_diagnosis.splitlines()[0]}")
        if self.ai_treatment_recommendations:
            summary.append(f"Treatment Suggestions: {self.ai_treatment_recommendations.splitlines()[0]}")
        if self.ai_confidence_score:
            summary.append(f"Confidence: {round(self.ai_confidence_score * 100, 1)}%")
        
        return "\n".join(summary) if summary else "No AI recommendations available"


class PatientNumberCounter(db.Model):
    """Atomic counters for OP/IP patient numbers.

    This avoids collisions when multiple staff create patients concurrently.
    """

    __tablename__ = 'patient_number_counters'

    # Use kind as primary key so we can row-lock a single record per type.
    kind = db.Column(db.String(2), primary_key=True)  # 'OP' | 'IP'
    last_value = db.Column(db.Integer, nullable=False, default=0)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    
class PatientReviewSystem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    cns = db.Column(db.Text)
    cvs = db.Column(db.Text)
    rs = db.Column(db.Text)
    git = db.Column(db.Text)
    gut = db.Column(db.Text)
    skin = db.Column(db.Text)
    msk = db.Column(db.Text)
    
    # Assistant fields
    ai_suggested_questions = db.Column(db.Text)  # Stores AI-generated questions for review of systems
    ai_last_updated = db.Column(db.DateTime)

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    creator = db.relationship('User', foreign_keys=[created_by])


class PatientHistory(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    social_history = db.Column(db.Text)
    medical_history = db.Column(db.Text)
    surgical_history = db.Column(db.Text)
    family_history = db.Column(db.Text)
    allergies = db.Column(db.Text)
    medications = db.Column(db.Text)
    
    # Assistant fields
    ai_identified_risk_factors = db.Column(db.Text)

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    creator = db.relationship('User', foreign_keys=[created_by])

class PatientExamination(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    general_appearance = db.Column(db.Text)
    jaundice = db.Column(db.Boolean, default=False)
    pallor = db.Column(db.Boolean, default=False)
    cyanosis = db.Column(db.Boolean, default=False)
    lymphadenopathy = db.Column(db.Boolean, default=False)
    edema = db.Column(db.Boolean, default=False)
    dehydration = db.Column(db.Boolean, default=False)
    dehydration_parameters = db.Column(db.Text)
    temperature = db.Column(db.Float)
    pulse = db.Column(db.Integer)
    resp_rate = db.Column(db.Integer)
    bp_systolic = db.Column(db.Integer)
    bp_diastolic = db.Column(db.Integer)
    spo2 = db.Column(db.Integer)
    weight = db.Column(db.Float)
    height = db.Column(db.Float)
    bmi = db.Column(db.Float)
    cvs_exam = db.Column(db.Text)
    resp_exam = db.Column(db.Text)
    abdo_exam = db.Column(db.Text)
    cns_exam = db.Column(db.Text)
    msk_exam = db.Column(db.Text)
    skin_exam = db.Column(db.Text)
    
    # Assistant fields
    ai_identified_red_flags = db.Column(db.Text)

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    creator = db.relationship('User', foreign_keys=[created_by])

class PatientSummary(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    summary_text = db.Column(db.Text, nullable=False)
    summary_type = db.Column(db.String(20), default='manual')  # 'manual' or 'ai_generated'
    generated_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    # FIXED: Use back_populates instead of backref to avoid naming conflicts
    patient = db.relationship('Patient', back_populates='summaries')
    generator = db.relationship('User', back_populates='generated_summaries')
    
class PatientDiagnosis(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    working_diagnosis = db.Column(db.Text)
    differential_diagnosis = db.Column(db.Text)

    # Optional clinician rationale fields
    working_diagnosis_supporting_argument = db.Column(db.Text)
    differential_diagnosis_supporting_argument = db.Column(db.Text)
    
        # Assistant fields
    ai_supported_diagnosis = db.Column(db.Boolean, default=False)
    ai_alternative_diagnoses = db.Column(db.Text)

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    creator = db.relationship('User', foreign_keys=[created_by])

class PatientManagement(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    treatment_plan = db.Column(db.Text)
    follow_up = db.Column(db.Text)
    notes = db.Column(db.Text)   
     
    # Assistant fields
    ai_generated_plan = db.Column(db.Boolean, default=False)
    ai_alternative_treatments = db.Column(db.Text)

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    creator = db.relationship('User', foreign_keys=[created_by])


class PatientBiodataEntry(db.Model):
    """Append-only snapshots of key biodata fields that change over time."""
    __tablename__ = 'patient_biodata_entries'

    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)

    # Store PII encrypted (consistent with Patient fields)
    phone = db.Column(db.Text)
    nok_name = db.Column(db.Text)
    nok_contact = db.Column(db.Text)

    # Non-encrypted fields
    tca = db.Column(db.Date)
    religion = db.Column(db.String(500))

    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)

    patient = db.relationship('Patient', backref=db.backref('biodata_entries', lazy=True, cascade='all, delete-orphan'))
    creator = db.relationship('User', foreign_keys=[created_by])


class PatientChiefComplaintEntry(db.Model):
    """Append-only chief complaint entries."""
    __tablename__ = 'patient_chief_complaint_entries'

    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    complaint_text = db.Column(db.Text, nullable=False)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)

    patient = db.relationship('Patient', backref=db.backref('chief_complaint_entries', lazy=True, cascade='all, delete-orphan'))
    creator = db.relationship('User', foreign_keys=[created_by])


class PatientHPIEntry(db.Model):
    """Append-only HPI entries."""
    __tablename__ = 'patient_hpi_entries'

    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    hpi_text = db.Column(db.Text, nullable=False)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)

    patient = db.relationship('Patient', backref=db.backref('hpi_entries', lazy=True, cascade='all, delete-orphan'))
    creator = db.relationship('User', foreign_keys=[created_by])

class LabRequest(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    test_id = db.Column(db.Integer, db.ForeignKey('lab_test.id'), nullable=False)
    requested_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    status = db.Column(db.String(20), default='pending')  # pending, completed, cancelled
    # Completion/result fields (nullable for backward-compat; migrations add columns)
    result = db.Column(db.Text)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    performed_at = db.Column(db.DateTime)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships for template access
    patient = db.relationship('Patient', backref=db.backref('lab_requests', lazy=True, cascade='all, delete-orphan'))
    test = db.relationship('LabTest', backref='lab_requests')
    requester = db.relationship('User', foreign_keys=[requested_by], backref='created_lab_requests')
    performer = db.relationship('User', foreign_keys=[performed_by])

class ImagingRequest(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    test_id = db.Column(db.Integer, db.ForeignKey('imaging_test.id'), nullable=False)
    requested_by = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    status = db.Column(db.String(20), default='pending')  # pending, completed, cancelled
    # Completion/result fields (nullable for backward-compat; migrations add columns)
    result = db.Column(db.Text)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    performed_at = db.Column(db.DateTime)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships for template access
    patient = db.relationship('Patient', backref=db.backref('imaging_requests', lazy=True, cascade='all, delete-orphan'))
    test = db.relationship('ImagingTest', backref='imaging_requests')
    requester = db.relationship('User', foreign_keys=[requested_by], backref='created_imaging_requests')
    performer = db.relationship('User', foreign_keys=[performed_by])

class ImagingTest(db.Model):
    """Model for imaging tests available in the clinic"""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    price = db.Column(db.Float, nullable=False, default=0.0)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    def __repr__(self):
        return f'<ImagingTest {self.name}>'

class LabRequestItem(db.Model):
    """Model for individual items in a lab request"""
    id = db.Column(db.Integer, primary_key=True)
    request_id = db.Column(db.Integer, db.ForeignKey('lab_request.id'), nullable=False)
    test_id = db.Column(db.Integer, db.ForeignKey('lab_test.id'), nullable=False)
    status = db.Column(db.String(20), default='pending')  # pending, completed, cancelled
    results = db.Column(db.Text)
    comments = db.Column(db.Text)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    performed_at = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships
    test = db.relationship('LabTest', backref='request_items')
    performer = db.relationship('User', backref='performed_lab_tests')

    def __repr__(self):
        return f'<LabRequestItem {self.id} for test {self.test_id}>'

class LabTest(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)
    description = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

class PatientLab(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    test_id = db.Column(db.Integer, db.ForeignKey('lab_test.id'), nullable=False)
    results = db.Column(db.Text)
    comments = db.Column(db.Text)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    reviewed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
        
    patient = db.relationship('Patient', backref='labs')
    test = db.relationship('LabTest', backref='patient_labs')
    performer = db.relationship('User', foreign_keys=[performed_by])
    reviewer = db.relationship('User', foreign_keys=[reviewed_by])

# New model for examination findings
class ExaminationFinding(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    note = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=get_eat_now)

    patient = db.relationship('Patient', back_populates='examination_findings')

# Update Patient model to include relationship
Patient.examination_findings = db.relationship('ExaminationFinding', back_populates='patient', lazy=True)

# Enhanced AIService class with more comprehensive AI integration
class AIService:
    
    MODELS = {
        'primary': 'deepseek-chat',  # Update based on verification
        'fallback': 'gpt-3.5-turbo'  # Optional fallback
    }

    @classmethod
    def get_client(cls):
        """Get AI client with proper configuration"""
        api_key = current_app.config.get('DEEPSEEK_API_KEY')
        if not api_key:
            raise ValueError("DEEPSEEK_API_KEY is not configured")

        # Render/Gunicorn worker timeouts are typically ~30s. Keep AI calls well under that
        # and disable client-side retries (retries can sleep and push requests past worker timeout).
        try:
            request_timeout = float(current_app.config.get('AI_REQUEST_TIMEOUT_SECONDS') or 20.0)
        except Exception:
            request_timeout = 20.0
        request_timeout = max(5.0, min(request_timeout, 25.0))

        try:
            max_retries = int(current_app.config.get('AI_MAX_RETRIES') or 0)
        except Exception:
            max_retries = 0
        max_retries = max(0, min(max_retries, 2))

        return OpenAI(
            api_key=api_key,
            base_url="https://api.deepseek.com/v1",
            timeout=request_timeout,
            max_retries=max_retries,
        )
        
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry=(retry_if_exception_type(APITimeoutError) | 
              retry_if_exception_type(APIError)),
        reraise=True
    )
    
    @staticmethod
    def generate_review_systems_questions(patient_data):
        """Generate focused review of systems questions based on chief complaint and biodata"""
        age = patient_data.get('age', 'Not specified')
        gender = patient_data.get('gender', 'Not specified')
        chief_complaint = patient_data.get('chief_complaint', 'Not specified')
        occupation = patient_data.get('occupation', 'Not specified')

        prompt = f"""
You are a competent, experienced clinician.

Task: Suggest targeted Review of Systems (ROS) questions to quickly identify clinically important positives/negatives.

Patient context:
- Age: {age}
- Gender: {gender}
- Occupation: {occupation}
- Chief complaint: {chief_complaint}

Output requirements:
- Choose the 4-6 most relevant systems.
- For each system, provide 2-4 specific questions.
- Keep questions short, patient-friendly, and clinically precise.
- Include red-flag screening where appropriate.
- Format strictly as:
SYSTEM: <name>
- Q1
- Q2
"""

        try:
            client = AIService.get_client()
            response = client.chat.completions.create(
                model=AIService.MODELS['primary'],
                messages=[{"role": "user", "content": prompt}],
                temperature=0.3,
                max_tokens=600,
            )
            return response.choices[0].message.content
        except Exception as e:
            AIService.log_ai_error("review_systems_questions", e, patient_data=patient_data)
            return None

    @staticmethod
    def _build_hpi_questions_prompt(patient_data) -> str:
        age = patient_data.get('age', 'Not specified')
        gender = patient_data.get('gender', 'Not specified')
        chief_complaint = patient_data.get('chief_complaint', 'Not specified')
        ros = patient_data.get('review_systems', 'Not documented')
        return f"""
You are an experienced clinician.

Task: Generate HPI clarification questions using SOCRATES/OPQRST where appropriate.

Patient context:
- Age: {age}
- Gender: {gender}
- Chief complaint: {chief_complaint}
- ROS summary:
{ros}

Output requirements:
- Provide 8-12 high-yield questions.
- Group by headings: Onset/Timing, Character/Severity, Associated symptoms, Exposures/Risk factors, Red flags.
- Questions must be concise.
"""

    @staticmethod
    def generate_hpi_questions(patient_data):
        """Generate HPI questions using SOCRATES framework with retries and fallbacks"""
        prompt = AIService._build_hpi_questions_prompt(patient_data)
        
        for model_name in AIService.MODELS.values():
            try:
                response = AIService.get_client().chat.completions.create(
                    model=model_name,
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.3,
                    max_tokens=3800
                )
                return response.choices[0].message.content
            except Exception as e:
                logging.warning(f"Model {model_name} failed: {str(e)}")
                continue
                
        return None

    @staticmethod
    def log_ai_error(method_name, error, patient_data=None):
        """Centralized error logging"""
        error_info = {
            "error": str(error),
            "type": type(error).__name__,
            "patient_data": patient_data,
            "timestamp": get_eat_now().isoformat()
        }
        current_app.logger.error(
            f"AI {method_name} Error",
            extra={"error_details": error_info},
            exc_info=True
        )
        
    @staticmethod
    def generate_hpi_content(patient_data):
        """Robust HPI generation with model verification"""
        prompt = AIService._build_hpi_prompt(patient_data)
        
        # Use configured timeout to prevent Gunicorn worker timeout
        ai_timeout = current_app.config.get('AI_SUMMARY_TIMEOUT_SECONDS', 20)
        
        for model_name in AIService.MODELS.values():
            try:
                response = AIService.get_client().chat.completions.create(
                    model=model_name,
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.3,
                    max_tokens=3800,
                    timeout=ai_timeout  # Use configured timeout
                )
                return response.choices[0].message.content
            except Exception as e:
                logging.warning(f"Model {model_name} failed: {str(e)}")
                continue
                
        return None

    @staticmethod
    def _build_hpi_prompt(patient_data):
        """Construct a detailed HPI prompt with proper validation and structure
        
        Args:
            patient_data (dict): Dictionary containing patient information including:
                - age
                - gender
                - address 
                - occupation
                - chief_complaint
                - review_of_systems
        
        Returns:
            str: A well-structured prompt for AI-generated HPI content
        """
     
        age = patient_data.get('age', 'unknown age')
        gender = patient_data.get('gender', 'unknown gender')
        address = patient_data.get('address', 'address not specified')
        occupation = patient_data.get('occupation', 'occupation not specified')
        chief_complaint = patient_data.get('chief_complaint', 'unspecified complaint')
        review_systems = patient_data.get('review_systems', 'not documented')
        
        return f"""
        As an experienced physician, generate a comprehensive History of Present Illness (HPI) 
        for this patient case following the SOCRATES framework and including all relevant details:

        Patient Background:
        - age: {age} 
        - gender {gender}
        - address: {address}
        - Occupation: {occupation}
        - Chief Complaint: "{chief_complaint}"
        - Review of Systems: {review_systems}

        Required HPI Structure:
        1. Opening Statement:
        - Start with a concise opening that introduces the patient and chief complaint

        2. Symptom Analysis (SOCRATES):
        a) Site: Location of symptoms with radiation patterns
        b) Onset: When it began and circumstances of onset
        c) Character: Quality and nature of symptoms
        d) Radiation: Where symptoms spread/migrate
        e) Associated Symptoms: Other related symptoms
        f) Time Course: Progression since onset
        g) Exacerbating/Relieving Factors: What makes it better/worse
        h) Severity: Quantitative measure (e.g., pain scale)

        3. Contextual Factors:
        - Impact on daily activities and work
        - Any previous treatments attempted and their effects
        - Relevant psychosocial factors
        - Occupational exposures or risk factors

        4. Summary:
        - Brief synthesis of key findings
        - Any red flags or urgent concerns

        Additional Instructions:
        - Use professional medical terminology but keep it clear
        - Organize information logically
        - Include pertinent positives and negatives
        - For pain complaints, use the OPQRST mnemonic if applicable
        - Highlight any findings that suggest urgent evaluation

        Please generate the HPI in full paragraph narrative format suitable for a medical record.
        """

    @staticmethod
    def generate_patient_summary(patient_data):
        """
        Generate a comprehensive patient summary from all available patient data
        """

        def _to_text(value) -> str:
            if value is None:
                return ""
            if isinstance(value, str):
                return value.strip()
            return str(value).strip()

        def _truthy_text(value) -> str:
            s = _to_text(value)
            if not s:
                return ""
            lowered = s.lower()
            if lowered in ("not documented", "not specified", "none", "none known", "n/a"):
                return ""
            return s

        def _clip(value, limit: int = 2000) -> str:
            if value is None:
                return ""
            text = value if isinstance(value, str) else str(value)
            text = text.strip()
            if len(text) <= limit:
                return text
            return text[:limit] + "..."

        try:
            summary_timeout = float(
                current_app.config.get('AI_SUMMARY_TIMEOUT_SECONDS')
                or current_app.config.get('AI_REQUEST_TIMEOUT_SECONDS')
                or 20.0
            )
        except Exception:
            summary_timeout = 20.0
        # Clamp to keep request under typical gateway limits.
        # NOTE: 29s is close to common 30s proxy/worker limits; use with care.
        summary_timeout = max(5.0, min(summary_timeout, 29.0))

        try:
            max_attempts = int(
                current_app.config.get('AI_SUMMARY_MAX_RETRIES')
                or 1
            )
        except Exception:
            max_attempts = 1
        # Interpret as total attempts (not retries). Keep small for interactive requests.
        max_attempts = max(1, min(max_attempts, 2))
        # If a single attempt can run close to gateway limits, do not stack retries.
        if summary_timeout > 20.0:
            max_attempts = 1

        try:
            summary_max_tokens = int(current_app.config.get('AI_SUMMARY_MAX_TOKENS') or 900)
        except Exception:
            summary_max_tokens = 900
        summary_max_tokens = max(200, min(summary_max_tokens, 1800))

        ros_json = json.dumps(patient_data.get('review_systems', {}), ensure_ascii=False)
        exam_json = json.dumps(patient_data.get('examination', {}), ensure_ascii=False)

        prompt = f"""
        You are an experienced medical professional. Create a comprehensive patient summary 
        by synthesizing all the available patient information into a coherent clinical narrative.
        
        PATIENT INFORMATION:
        
        Biodata:
        - Name: {patient_data.get('name', 'Not specified')}
        - Age: {patient_data.get('age', 'Not specified')}
        - Gender: {patient_data.get('gender', 'Not specified')}
        - Address: {patient_data.get('address', 'Not specified')}
        - Occupation: {patient_data.get('occupation', 'Not specified')}
        - Religion: {patient_data.get('religion', 'Not specified')}
        
        Chief Complaint:
        {_clip(patient_data.get('chief_complaint', 'Not documented'))}
        
        History of Present Illness (HPI):
        {_clip(patient_data.get('history_present_illness', 'Not documented'), 3500)}
        
        Review of Systems (ROS):
        {_clip(ros_json, 3500)}
        
        Medical History:
        - Social History: {_clip(patient_data.get('social_history', 'Not documented'))}
        - Medical History: {_clip(patient_data.get('medical_history', 'Not documented'))}
        - Surgical History: {_clip(patient_data.get('surgical_history', 'Not documented'))}
        - Family History: {_clip(patient_data.get('family_history', 'Not documented'))}
        - Allergies: {_clip(patient_data.get('allergies', 'None known'))}
        - Current Medications: {_clip(patient_data.get('medications', 'None'))}
        
        Physical Examination Findings:
        {_clip(exam_json, 3500)}
        
        Current Working Diagnosis:
        {_clip(patient_data.get('working_diagnosis', 'Not established'))}
        
        Please create a well-structured patient summary that includes:
        1. Patient demographics and presenting complaint
        2. Key findings from history and examination
        3. Assessment and current diagnosis
        4. Relevant positive and negative findings
        5. Clinical impression
        
        Format the summary in professional medical narrative style, suitable for inclusion in a medical record.
        Be concise but comprehensive, focusing on clinically relevant information.
        """

        last_exc = None
        for attempt in range(1, max_attempts + 1):
            try:
                client = AIService.get_client()
                response = client.chat.completions.create(
                    model=AIService.MODELS['primary'],
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.3,
                    max_tokens=summary_max_tokens,
                    timeout=summary_timeout,
                )
                return _to_text(response.choices[0].message.content)
            except (APITimeoutError, httpx.TimeoutException, TimeoutError) as e:
                last_exc = e
                # One quick retry at most (bounded by max_attempts).
                continue
        if last_exc:
            raise last_exc
        return None

    @staticmethod
    def generate_patient_summary_fallback(patient_data) -> str:
        """Deterministic fallback summary when upstream AI is slow/unavailable."""

        def _clean(value) -> str:
            if value is None:
                return ""
            if isinstance(value, str):
                return value.strip()
            return str(value).strip()

        def _fmt(label: str, value) -> str:
            v = _clean(value)
            if not v:
                return ""
            return f"{label}: {v}"

        name = _clean(patient_data.get('name'))
        age = _clean(patient_data.get('age'))
        gender = _clean(patient_data.get('gender'))
        address = _clean(patient_data.get('address'))
        occupation = _clean(patient_data.get('occupation'))
        religion = _clean(patient_data.get('religion'))

        cc = _clean(patient_data.get('chief_complaint'))
        hpi = _clean(patient_data.get('history_present_illness'))
        working_dx = _clean(patient_data.get('working_diagnosis'))

        allergies = _clean(patient_data.get('allergies'))
        meds = _clean(patient_data.get('medications'))
        pmh = _clean(patient_data.get('medical_history'))
        psh = _clean(patient_data.get('surgical_history'))
        fh = _clean(patient_data.get('family_history'))
        sh = _clean(patient_data.get('social_history'))

        # Try to extract vitals if present.
        vitals_text = ""
        exam = patient_data.get('examination')
        try:
            vitals = (exam or {}).get('vitals') if isinstance(exam, dict) else None
            if isinstance(vitals, dict) and vitals:
                parts = []
                for k in ('bp', 'temp', 'pulse', 'rr', 'spo2', 'weight', 'height', 'bmi'):
                    if k in vitals and _clean(vitals.get(k)):
                        parts.append(f"{k.upper()} {_clean(vitals.get(k))}")
                vitals_text = ", ".join(parts)
        except Exception:
            vitals_text = ""

        lines = []
        header = ""
        demo_bits = [b for b in [name, age and f"{age}y", gender] if b]
        if demo_bits:
            header = "Patient: " + " / ".join(demo_bits)
        if header:
            lines.append(header)
        lines.extend([s for s in [
            _fmt("Address", address),
            _fmt("Occupation", occupation),
            _fmt("Religion", religion),
        ] if s])

        if cc:
            lines.append(f"Chief complaint: {cc}")
        if hpi:
            lines.append(f"HPI: {hpi}")

        hx_lines = [s for s in [
            _fmt("Medical history", pmh),
            _fmt("Surgical history", psh),
            _fmt("Family history", fh),
            _fmt("Social history", sh),
            _fmt("Allergies", allergies or "None known"),
            _fmt("Medications", meds or "None"),
        ] if s]
        if hx_lines:
            lines.append("History:")
            lines.extend(["- " + s for s in hx_lines])

        if vitals_text:
            lines.append(f"Vitals: {vitals_text}")

        if working_dx:
            lines.append(f"Working diagnosis: {working_dx}")

        out = "\n".join([l for l in lines if _clean(l)])
        return out.strip() or "Clinical summary unavailable. Please document key findings and try again."

    @staticmethod
    def generate_diagnosis_from_summary(clinical_summary, patient_info=None):
        """
        Generate differential diagnosis based on clinical summary
        """
        try:
            model = AIService.MODELS['primary']
            
            # Build patient context
            patient_context = ""
            if patient_info:
                if patient_info.get('age'):
                    patient_context += f"Age: {patient_info['age']} years\n"
                if patient_info.get('gender'):
                    patient_context += f"Gender: {patient_info['gender']}\n"
                if patient_info.get('name'):
                    patient_context += f"Patient: {patient_info['name']}\n"
            
            prompt = f"""
            As an experienced medical diagnostician, analyze the following clinical summary and provide a comprehensive differential diagnosis.

            PATIENT CONTEXT:
            {patient_context}

            CLINICAL SUMMARY:
            {clinical_summary}

            Please provide a structured analysis with the following sections:

            1. PRIMARY WORKING DIAGNOSIS:
            - The most likely diagnosis based on the clinical presentation
            - Brief rationale explaining why this is the most likely

            2. DIFFERENTIAL DIAGNOSES (List 3-5 alternatives in order of likelihood):
            For each differential diagnosis include:
            - Condition name
            - Key supporting features from the clinical summary
            - Important distinguishing features from the working diagnosis

            3. KEY CLINICAL FINDINGS:
            - List the most significant positive findings from the summary
            - Note any important negative findings that help rule out alternatives

            4. RECOMMENDED INVESTIGATIONS:
            - Essential tests to confirm the working diagnosis
            - Tests to rule out key differential diagnoses
            - Any urgent investigations if red flags are present

            5. CLINICAL PEARLS:
            - Important considerations for management
            - Any red flags or urgent concerns
            - Specific follow-up recommendations

            Format your response in clear, clinical language suitable for medical records.
            Be concise but comprehensive.
            """

            # Explicit timeout + retries to reduce intermittent 503s.
            # Diagnosis generation can be slower than ROS/HPI due to longer output.
            # Use configured timeout to prevent Gunicorn worker timeout (default 30s)
            ai_timeout = current_app.config.get('AI_SUMMARY_TIMEOUT_SECONDS', 20)
            response = AIService._chat_completion(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=3800,
                temperature=0.4,
                timeout=ai_timeout,
            )

            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI Diagnosis from Summary Error: {str(e)}")
            return None

    @staticmethod
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry=(retry_if_exception_type(APITimeoutError) |
              retry_if_exception_type(APIError)),
        reraise=True,
    )
    def _chat_completion(*, model: str, messages: list[dict], max_tokens: int, temperature: float, timeout: int):
        client = AIService.get_client()
        return client.chat.completions.create(
            model=model,
            messages=messages,
            max_tokens=max_tokens,
            temperature=temperature,
            timeout=timeout,
        )


    # Keep your existing methods but update the main diagnosis method to use summary
    @staticmethod
    def generate_diagnosis(patient_data):
        """
        Updated to prioritize clinical summary if available
        """
        # Check if clinical summary is available in patient_data
        clinical_summary = patient_data.get('clinical_summary') or patient_data.get('patient_summary')
        
        if clinical_summary:
            # Use the summary-based diagnosis
            patient_info = {
                'age': patient_data.get('age'),
                'gender': patient_data.get('gender'),
                'name': patient_data.get('name')
            }
            return AIService.generate_diagnosis_from_summary(clinical_summary, patient_info)
        else:
            # Fall back to the original detailed diagnosis method
            return AIService._generate_detailed_diagnosis(patient_data)

    @staticmethod
    def _generate_detailed_diagnosis(patient_data):
        """
        Original detailed diagnosis method (fallback)
        """
        try:
            model = AIService.MODELS.get('primary') or os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Based on the following patient information, generate a differential diagnosis:
            
            Patient Demographics:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            
            Clinical Presentation:
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            - History of Present Illness: {patient_data.get('history_present_illness', 'Not documented')}
            
            Review of Systems:
            {json.dumps(patient_data.get('review_systems', {}), indent=2)}
            
            Medical History:
            - Social: {patient_data.get('social_history', 'Not documented')}
            - Medical: {patient_data.get('medical_history', 'Not documented')}
            - Surgical: {patient_data.get('surgical_history', 'Not documented')}
            - Family: {patient_data.get('family_history', 'Not documented')}
            - Allergies: {patient_data.get('allergies', 'None known')}
            - Medications: {patient_data.get('medications', 'None')}
            
            Physical Examination:
            {json.dumps(patient_data.get('examination', {}), indent=2)}
            
            Please provide:
            1. Most likely diagnosis (working diagnosis)
            2. 3-5 differential diagnoses in order of likelihood
            3. Brief rationale for each
            4. Suggested diagnostic tests to confirm
            """
            
            client = AIService.get_client()
            response = client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=3800,
                temperature=0.7,
            )
            
            return response.choices[0].message.content
        except Exception as e:
            AIService.log_ai_error("detailed_diagnosis", e, patient_data=patient_data)
            return None
        
    @staticmethod
    def generate_treatment_plan(patient_data, available_drugs):
        """
        Generate comprehensive treatment plan considering available drugs
        """
        drugs_list = "\n".join([f"- {drug.name} ({drug.specification})" for drug in available_drugs])
        
        prompt = f"""
        Create a treatment plan for this patient considering available medications:
        
        Patient: {patient_data['age']} year old {patient_data['gender']}
        Diagnosis: {patient_data['diagnosis']}
        Allergies: {patient_data.get('allergies', 'None known')}
        Current Medications: {patient_data.get('medications', 'None')}
        
        Available Drugs:
        {drugs_list}
        
        Provide:
        1. First-line treatment recommendations using available drugs
        2. Alternative options if first-line isn't available
        3. Specific dosages based on patient factors
        4. Duration of treatment
        5. Monitoring recommendations
        6. Patient education points
        7. Follow-up plan
        """

        # NOTE: "deepseek-medical" is not available on many DeepSeek accounts and
        # causes 400 "Model Not Exist". Use configured model, with safe fallbacks.
        model_candidates = [
            (os.getenv("DEEPSEEK_MODEL") or '').strip(),
            AIService.MODELS.get('primary') or 'deepseek-chat',
            'deepseek-chat',
            'deepseek-reasoner',
        ]
        # De-dupe while preserving order
        seen = set()
        models_to_try = []
        for m in model_candidates:
            if not m:
                continue
            if m in seen:
                continue
            seen.add(m)
            models_to_try.append(m)

        last_error = None
        # Use configured timeout to prevent Gunicorn worker timeout (default 30s)
        ai_timeout = current_app.config.get('AI_SUMMARY_TIMEOUT_SECONDS', 20)
        for model_name in models_to_try:
            try:
                response = AIService._chat_completion(
                    model=model_name,
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.3,
                    max_tokens=3800,
                    timeout=ai_timeout,
                )
                return response.choices[0].message.content
            except APIError as e:
                last_error = e
                msg = str(e)
                if 'Model Not Exist' in msg or 'invalid_request_error' in msg:
                    continue
                AIService.log_ai_error("treatment_plan", e, patient_data=patient_data)
                return None
            except Exception as e:
                last_error = e
                AIService.log_ai_error("treatment_plan", e, patient_data=patient_data)
                return None

        if last_error is not None:
            AIService.log_ai_error("treatment_plan", last_error, patient_data=patient_data)
        return None

class DebtPayment(db.Model):
    __tablename__ = 'debt_payments'
    
    id = db.Column(db.Integer, primary_key=True)
    debtor_id = db.Column(db.Integer, db.ForeignKey('debts.id'))
    amount = db.Column(db.Float, nullable=False)
    payment_date = db.Column(db.Date, nullable=False)
    payment_method = db.Column(db.String(50), nullable=False)
    notes = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))  # Added this line
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    user = db.relationship('User', backref='debt_payments')

class Service(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    price = db.Column(db.Float, nullable=False)
    description = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
class Prescription(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    doctor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    notes = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')  # pending, dispensed, cancelled
    dispensed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    dispensed_at = db.Column(db.DateTime)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
  
    items = db.relationship('PrescriptionItem', backref='prescription', lazy=True)  
    patient = db.relationship('Patient', backref='prescriptions')
    doctor = db.relationship('User', foreign_keys=[doctor_id], backref='prescriptions')
    dispenser = db.relationship('User', foreign_keys=[dispensed_by], backref='dispensed_prescriptions')

class PrescriptionItem(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    prescription_id = db.Column(db.Integer, db.ForeignKey('prescription.id'), nullable=False)
    drug_id = db.Column(db.Integer, db.ForeignKey('drug.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    dosage = db.Column(db.Text)
    frequency = db.Column(db.String(50))
    duration = db.Column(db.String(50))
    notes = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')  # pending, dispensed, cancelled
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    drug = db.relationship('Drug', backref='prescription_items')

class Sale(db.Model):
    __tablename__ = 'sales'
    
    id = db.Column(db.Integer, primary_key=True)
    sale_number = db.Column(db.String(50), unique=True, nullable=False)
    bulk_sale_number = db.Column(db.String(20))
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    pharmacist_name = db.Column(db.String(100))  # Store pharmacist name directly
    total_amount = db.Column(db.Float, nullable=False)
    discount = db.Column(db.Float, default=0)
    payment_method = db.Column(db.String(20))
    status = db.Column(db.String(20), default='completed')
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships
    patient = db.relationship('Patient', backref='patient_sales')
    user = db.relationship('User', foreign_keys=[user_id], backref='user_sales')
    items = db.relationship('SaleItem', back_populates='sale', lazy=True, cascade='all, delete-orphan')


class SaleItem(db.Model):
    __tablename__ = 'sale_items'
    
    id = db.Column(db.Integer, primary_key=True)
    sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'), nullable=False)
    drug_id = db.Column(db.Integer, db.ForeignKey('drug.id'))
    drug_name = db.Column(db.String(100))  # Store drug name directly
    drug_specification = db.Column(db.String(200))  # Store drug specs
    individual_sale_number = db.Column(db.String(100))
    service_id = db.Column(db.Integer, db.ForeignKey('service.id'))
    lab_test_id = db.Column(db.Integer, db.ForeignKey('lab_test.id'))
    imaging_test_id = db.Column(db.Integer, db.ForeignKey('imaging_test.id'))
    description = db.Column(db.String(200), nullable=False, default="Drug sale")
    quantity = db.Column(db.Integer, default=1)
    unit_price = db.Column(db.Float, nullable=False)
    total_price = db.Column(db.Float, nullable=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Relationships
    drug = db.relationship('Drug', backref='sale_items')
    service = db.relationship('Service', backref='sale_items')
    lab_test = db.relationship('LabTest', backref='sale_items')
    imaging_test = db.relationship('ImagingTest', backref='sale_items')
    sale = db.relationship('Sale', back_populates='items')

    def __init__(self, **kwargs):
        super(SaleItem, self).__init__(**kwargs)
        # Automatically set drug info when drug is assigned
        if self.drug:
            self.drug_name = self.drug.name
            self.drug_specification = self.drug.specification

class Refund(db.Model):
    __tablename__ = 'refunds'
    
    id = db.Column(db.Integer, primary_key=True)
    refund_number = db.Column(db.String(50), unique=True, nullable=False)
    sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    total_amount = db.Column(db.Float, nullable=False)
    reason = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    status = db.Column(db.String(20), default='completed')
    
    # Relationships
    sale = db.relationship('Sale', backref='refunds')
    user = db.relationship('User', backref='refunds')
    items = db.relationship('RefundItem', back_populates='refund')

class RefundItem(db.Model):
    __tablename__ = 'refund_items'  # Note the correct table name
    
    id = db.Column(db.Integer, primary_key=True)
    refund_id = db.Column(db.Integer, db.ForeignKey('refunds.id'), nullable=False)
    sale_item_id = db.Column(db.Integer, db.ForeignKey('sale_items.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    unit_price = db.Column(db.Float, nullable=False)
    total_price = db.Column(db.Float, nullable=False)
    
    # Relationships
    refund = db.relationship('Refund', back_populates='items')
    sale_item = db.relationship('SaleItem', backref='refund_items')

class Transaction(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    transaction_number = db.Column(db.String(50), unique=True, nullable=False)
    transaction_type = db.Column(db.String(50), nullable=False)  # sale, refund, payment, expense, etc.
    amount = db.Column(db.Float, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    reference_id = db.Column(db.Integer)  # ID of related record (sale, expense, etc.)
    # Optional metadata to make the ledger self-describing (kept nullable for backward-compat)
    reference_table = db.Column(db.String(80))
    # Optional linkage to higher-level payment records (kept nullable for backward-compat)
    payment_intent_id = db.Column(db.Integer)
    provider_txn_id = db.Column(db.Integer)
    direction = db.Column(db.String(3))  # IN / OUT
    status = db.Column(db.String(20))  # posted, void, draft
    department = db.Column(db.String(100))
    category = db.Column(db.String(100))
    payer = db.Column(db.String(120))
    payment_method = db.Column(db.String(50))
    notes = db.Column(db.Text)
    # Receipt storage for reprinting / audit
    receipt_number = db.Column(db.String(50))
    receipt_html = db.Column(db.Text)
    receipt_created_at = db.Column(db.DateTime)
    receipt_reprinted_at = db.Column(db.DateTime)
    receipt_reprint_count = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    user = db.relationship('User', backref='transactions')

    @property
    def clinic_transaction_code(self) -> str:
        """Human-facing unique clinic transaction code.

        Backward compatible: uses the existing transaction_number.
        """
        return str(self.transaction_number or '')


class MpesaPayment(db.Model):
    """Stores incoming M-Pesa payments (STK Push + C2B confirmations).

    This table is the system-of-record for the M-Pesa transaction code (receipt).
    """

    __tablename__ = 'mpesa_payments'

    id = db.Column(db.Integer, primary_key=True)

    # stk | c2b
    source = db.Column(db.String(10), nullable=False)

    # pending | success | failed
    status = db.Column(db.String(20), nullable=False, default='pending')

    # Links (optional) for auto-posting
    invoice_id = db.Column(db.Integer, db.ForeignKey('invoices.id'))
    invoice_number = db.Column(db.String(80))
    initiated_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    # Common payment fields
    phone_number = db.Column(db.String(20))
    amount_expected = db.Column(db.Numeric(10, 2))
    amount_received = db.Column(db.Numeric(10, 2))

    # STK identifiers
    merchant_request_id = db.Column(db.String(120), unique=True)
    checkout_request_id = db.Column(db.String(120), unique=True)
    result_code = db.Column(db.Integer)
    result_desc = db.Column(db.String(255))

    # The M-Pesa transaction code (receipt). For C2B it is TransID; for STK it is MpesaReceiptNumber.
    mpesa_receipt_number = db.Column(db.String(30), unique=True)

    # C2B fields (manual Till / reference)
    bill_ref_number = db.Column(db.String(120))
    trans_time = db.Column(db.String(32))
    business_short_code = db.Column(db.String(20))

    raw_payload = db.Column(db.Text)

    # Optional linkage to PaymentIntent/MpesaProviderTxn
    payment_intent_id = db.Column(db.Integer)
    provider_txn_id = db.Column(db.Integer)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    invoice = db.relationship('Invoice', backref='mpesa_payments')
    initiated_by = db.relationship('User', backref='mpesa_initiated_payments')


class MpesaPayout(db.Model):
    """Stores outgoing M-Pesa payments initiated by admin (B2C/B2B/B2Pochi).

    This is separate from Transaction ledger entries; the ledger entry is created when status is known.
    """

    __tablename__ = 'mpesa_payouts'

    id = db.Column(db.Integer, primary_key=True)

    # b2c | b2b | b2pochi
    payout_type = db.Column(db.String(10), nullable=False)
    status = db.Column(db.String(20), nullable=False, default='pending')  # pending|success|failed

    initiated_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)

    # Beneficiary details (one of these depends on type)
    beneficiary_msisdn = db.Column(db.String(20))
    beneficiary_paybill = db.Column(db.String(20))
    beneficiary_till = db.Column(db.String(20))
    beneficiary_pochi = db.Column(db.String(20))

    amount = db.Column(db.Numeric(10, 2), nullable=False)
    remarks = db.Column(db.String(255))
    occasion = db.Column(db.String(255))

    # Daraja async identifiers
    conversation_id = db.Column(db.String(120), unique=True)
    originator_conversation_id = db.Column(db.String(120), unique=True)
    response_code = db.Column(db.String(20))
    response_description = db.Column(db.String(255))

    # Result identifiers
    result_code = db.Column(db.Integer)
    result_desc = db.Column(db.String(255))
    mpesa_transaction_id = db.Column(db.String(30), unique=True)

    raw_request = db.Column(db.Text)
    raw_result = db.Column(db.Text)

    # Optional linkage to PaymentIntent/MpesaProviderTxn
    payment_intent_id = db.Column(db.Integer)
    provider_txn_id = db.Column(db.Integer)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    initiated_by = db.relationship('User', backref='mpesa_payouts')


class MpesaTransactionStatusQuery(db.Model):
    """Tracks Transaction Status API queries (used for manual Till verification + reconciliation)."""

    __tablename__ = 'mpesa_txn_status_queries'

    id = db.Column(db.Integer, primary_key=True)

    transaction_id = db.Column(db.String(30), nullable=False)  # TransID / receipt code being queried
    status = db.Column(db.String(20), nullable=False, default='pending')  # pending|success|failed

    requested_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    invoice_id = db.Column(db.Integer, db.ForeignKey('invoices.id'))
    invoice_number = db.Column(db.String(80))

    amount_expected = db.Column(db.Numeric(10, 2))
    payer_phone_number = db.Column(db.String(20))

    conversation_id = db.Column(db.String(120), unique=True)
    originator_conversation_id = db.Column(db.String(120), unique=True)

    result_code = db.Column(db.Integer)
    result_desc = db.Column(db.String(255))

    raw_request = db.Column(db.Text)
    raw_result = db.Column(db.Text)

    # Optional linkage to PaymentIntent/MpesaProviderTxn
    payment_intent_id = db.Column(db.Integer)
    provider_txn_id = db.Column(db.Integer)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    requested_by = db.relationship('User', backref='mpesa_txn_status_queries')
    invoice = db.relationship('Invoice', backref='mpesa_txn_status_queries')


class PaymentIntent(db.Model):
    """High-level payment attempt (what the user is trying to do).

    This is the stable anchor for: reports, audit, and receipt consistency.
    """

    __tablename__ = 'payment_intents'

    id = db.Column(db.Integer, primary_key=True)
    intent_code = db.Column(db.String(60), unique=True, nullable=False)

    # IN / OUT
    direction = db.Column(db.String(3), nullable=False)

    # STK_C2B, MANUAL_TILL, B2C, B2B, B2POCHI, RATIBA_RUN
    intent_type = db.Column(db.String(20), nullable=False)

    amount = db.Column(db.Numeric(10, 2), nullable=False)
    currency = db.Column(db.String(10), nullable=False, default='KES')

    # Human reference (invoice number / sale number / supplier id / etc)
    reference = db.Column(db.String(120))

    # Optional linkage to business records
    invoice_id = db.Column(db.Integer, db.ForeignKey('invoices.id'))
    invoice_number = db.Column(db.String(80))
    sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'))
    sale_number = db.Column(db.String(80))

    initiated_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    initiated_by_role = db.Column(db.String(40))
    department = db.Column(db.String(40))  # pharmacy/frontdesk/admin

    # pending/success/failed/cancelled
    status = db.Column(db.String(20), nullable=False, default='pending')

    notes = db.Column(db.Text)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    initiated_by = db.relationship('User', backref='payment_intents')
    invoice = db.relationship('Invoice', backref='payment_intents')
    sale = db.relationship('Sale', backref='payment_intents')


class MpesaProviderTxn(db.Model):
    """Provider-level transaction record for M-Pesa, linked to PaymentIntent.

    Stores raw requests/callbacks for audit and idempotency.
    """

    __tablename__ = 'mpesa_provider_txns'

    id = db.Column(db.Integer, primary_key=True)
    payment_intent_id = db.Column(db.Integer, db.ForeignKey('payment_intents.id'), nullable=False)

    # IN / OUT
    direction = db.Column(db.String(3), nullable=False)
    provider_action = db.Column(db.String(30))  # stk_push | c2b_confirmation | txn_status_query | b2c | b2b | b2pochi

    # pending/success/failed/cancelled
    status = db.Column(db.String(20), nullable=False, default='pending')

    # Incoming identifiers
    mpesa_receipt_number = db.Column(db.String(30))
    checkout_request_id = db.Column(db.String(120))
    merchant_request_id = db.Column(db.String(120))

    # Outgoing identifiers
    conversation_id = db.Column(db.String(120))
    originator_conversation_id = db.Column(db.String(120))
    mpesa_transaction_id = db.Column(db.String(30))

    result_code = db.Column(db.Integer)
    result_desc = db.Column(db.String(255))

    raw_request = db.Column(db.Text)
    raw_callback = db.Column(db.Text)

    initiated_at = db.Column(db.DateTime, default=get_eat_now)
    callback_received_at = db.Column(db.DateTime)
    completed_at = db.Column(db.DateTime)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    payment_intent = db.relationship('PaymentIntent', backref='mpesa_provider_txns')


class RatibaSchedule(db.Model):
    """Recurrent M-Pesa payouts (Ratiba-style) managed by the clinic."""

    __tablename__ = 'ratiba_schedules'

    id = db.Column(db.Integer, primary_key=True)
    schedule_code = db.Column(db.String(60), unique=True, nullable=False)

    # active/paused/cancelled
    status = db.Column(db.String(20), nullable=False, default='active')

    # b2c | b2b | b2pochi
    payout_type = db.Column(db.String(10), nullable=False)

    # Beneficiary details
    beneficiary_msisdn = db.Column(db.String(20))
    beneficiary_paybill = db.Column(db.String(20))
    beneficiary_till = db.Column(db.String(20))
    beneficiary_pochi = db.Column(db.String(20))

    amount = db.Column(db.Numeric(10, 2), nullable=False)
    currency = db.Column(db.String(10), nullable=False, default='KES')

    # daily/weekly/monthly
    frequency = db.Column(db.String(12), nullable=False)
    start_at = db.Column(db.DateTime)
    end_at = db.Column(db.DateTime)
    next_run_at = db.Column(db.DateTime)

    remarks = db.Column(db.String(255))
    account_reference = db.Column(db.String(120))

    created_by_user_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    created_by = db.relationship('User', backref='ratiba_schedules')


class RatibaRun(db.Model):
    """One execution/run of a RatibaSchedule (creates PaymentIntent + provider txn + payout)."""

    __tablename__ = 'ratiba_runs'

    id = db.Column(db.Integer, primary_key=True)
    schedule_id = db.Column(db.Integer, db.ForeignKey('ratiba_schedules.id'), nullable=False)

    # pending/success/failed
    status = db.Column(db.String(20), nullable=False, default='pending')

    payment_intent_id = db.Column(db.Integer)
    provider_txn_id = db.Column(db.Integer)
    mpesa_payout_id = db.Column(db.Integer)

    started_at = db.Column(db.DateTime, default=get_eat_now)
    completed_at = db.Column(db.DateTime)

    error = db.Column(db.Text)

    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    schedule = db.relationship('RatibaSchedule', backref='runs')

def generate_transaction_number():
    return f"TXN-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def generate_receipt_number(prefix: str = 'RCPT'):
    return f"{prefix}-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def generate_payment_intent_code(prefix: str = 'PI') -> str:
    return f"{prefix}-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def generate_ratiba_code(prefix: str = 'RAT') -> str:
    return f"{prefix}-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def _infer_department_for_user(user: 'User') -> str | None:
    try:
        role = (getattr(user, 'role', None) or '').strip().lower()
    except Exception:
        role = ''
    if role == 'pharmacist':
        return 'pharmacy'
    if role == 'receptionist':
        return 'frontdesk'
    if role == 'admin':
        return 'admin'
    return None


def _payment_intents_supported() -> bool:
    try:
        return database_has_table('payment_intents') and database_has_table('mpesa_provider_txns')
    except Exception:
        return False


def _maybe_set_link_fields(obj, **fields):
    if not obj:
        return
    for k, v in (fields or {}).items():
        try:
            setattr(obj, k, v)
        except Exception:
            pass


def _create_payment_intent(
    *,
    direction: str,
    intent_type: str,
    amount: Decimal,
    currency: str = 'KES',
    reference: str | None = None,
    invoice: 'Invoice' | None = None,
    sale: 'Sale' | None = None,
    initiated_by_user_id: int | None = None,
    status: str = 'pending',
    notes: str | None = None,
) -> 'PaymentIntent' | None:
    if not database_has_table('payment_intents'):
        return None

    initiated_by_role = None
    department = None
    try:
        if initiated_by_user_id:
            u = _db_get(User, int(initiated_by_user_id))
            if u:
                initiated_by_role = getattr(u, 'role', None)
                department = _infer_department_for_user(u)
    except Exception:
        pass

    pi = PaymentIntent(
        intent_code=generate_payment_intent_code(),
        direction=(direction or '').strip().upper(),
        intent_type=(intent_type or '').strip().upper(),
        amount=_to_decimal_2dp(amount),
        currency=(currency or 'KES').strip().upper(),
        reference=(reference or None),
        invoice_id=getattr(invoice, 'id', None) if invoice else None,
        invoice_number=getattr(invoice, 'invoice_number', None) if invoice else None,
        sale_id=getattr(sale, 'id', None) if sale else None,
        sale_number=getattr(sale, 'sale_number', None) if sale else None,
        initiated_by_user_id=int(initiated_by_user_id) if initiated_by_user_id else None,
        initiated_by_role=(initiated_by_role or None),
        department=(department or None),
        status=(status or 'pending').strip().lower(),
        notes=notes,
    )
    db.session.add(pi)
    db.session.flush()
    return pi


def _create_mpesa_provider_txn(
    *,
    payment_intent_id: int,
    direction: str,
    provider_action: str,
    status: str = 'pending',
    mpesa_receipt_number: str | None = None,
    checkout_request_id: str | None = None,
    merchant_request_id: str | None = None,
    conversation_id: str | None = None,
    originator_conversation_id: str | None = None,
    mpesa_transaction_id: str | None = None,
    result_code: int | None = None,
    result_desc: str | None = None,
    raw_request: str | None = None,
    raw_callback: str | None = None,
) -> 'MpesaProviderTxn' | None:
    if not database_has_table('mpesa_provider_txns'):
        return None

    txn = MpesaProviderTxn(
        payment_intent_id=int(payment_intent_id),
        direction=(direction or '').strip().upper(),
        provider_action=(provider_action or '').strip(),
        status=(status or 'pending').strip().lower(),
        mpesa_receipt_number=mpesa_receipt_number,
        checkout_request_id=checkout_request_id,
        merchant_request_id=merchant_request_id,
        conversation_id=conversation_id,
        originator_conversation_id=originator_conversation_id,
        mpesa_transaction_id=mpesa_transaction_id,
        result_code=result_code,
        result_desc=(result_desc or None),
        raw_request=raw_request,
        raw_callback=raw_callback,
    )
    db.session.add(txn)
    db.session.flush()
    return txn


def _receipt_clinic_name() -> str:
    return (app.config.get('CLINIC_NAME') or os.getenv('CLINIC_NAME') or 'Makokha Medical Centre').strip()


def _build_mpesa_receipt_html(
    *,
    receipt_title: str,
    direction: str,
    clinic_txn_code: str | None,
    mpesa_code: str | None,
    party_label: str,
    party_name: str | None,
    party_phone: str | None,
    amount: Decimal,
    currency: str = 'KES',
    purpose: str | None = None,
    served_by_user_id: int | None = None,
    served_by_label: str | None = None,
    created_at: datetime | None = None,
) -> str:
    dt = created_at or get_eat_now()

    served_by = served_by_label
    if not served_by and served_by_user_id:
        try:
            u = _db_get(User, int(served_by_user_id))
            if u:
                served_by = getattr(u, 'username', None) or getattr(u, 'name', None) or None
                try:
                    role = getattr(u, 'role', None)
                    if role:
                        served_by = f"{served_by} ({role})" if served_by else str(role)
                except Exception:
                    pass
        except Exception:
            served_by = None

    parts = [
        "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
        f"<h2 style='margin:0 0 6px 0;'>{escape(_receipt_clinic_name())}</h2>",
        f"<div style='color:#555;margin-bottom:10px;'>{escape(dt.strftime('%Y-%m-%d %H:%M'))}</div>",
        f"<h3 style='margin:0 0 10px 0;'>{escape(str(receipt_title or 'Receipt'))}</h3>",
        "<table style='width:100%;border-collapse:collapse;'>",
    ]

    def row(k: str, v: str | None):
        if v is None or str(v).strip() == '':
            return
        parts.append(
            "<tr>"
            "<td style='padding:6px 8px;border:1px solid #eee;width:38%;background:#fafafa;'><strong>" + escape(str(k)) + "</strong></td>"
            "<td style='padding:6px 8px;border:1px solid #eee;'>" + escape(str(v)) + "</td>"
            "</tr>"
        )

    row('Clinic Transaction Code', clinic_txn_code)
    row('Direction', (direction or '').upper())
    row('M-Pesa Code / Reference', mpesa_code)
    row(party_label, (party_name or '').strip() if party_name else None)
    row('Phone', party_phone)
    row('Amount', f"{(currency or 'KES').upper()} {str(_to_decimal_2dp(amount))}")
    row('What it was for', purpose)
    row('Served by', served_by)
    parts.append("</table>")
    parts.append("<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />")
    parts.append("<div style='color:#777;font-size:12px;'>Receipt snapshot stored for audit/reprint.</div>")
    parts.append("</div>")
    return "".join(parts)


def _inject_reprint_banner(html, reprinted_at=None, reprint_count=None):
    if not html:
        return html
    stamp = ''
    try:
        if reprinted_at:
            stamp = reprinted_at.strftime('%Y-%m-%d %H:%M')
    except Exception:
        stamp = ''
    count = int(reprint_count or 0)
    parts = [
        "<div class='no-print' style='max-width:700px;margin:0 auto 10px auto;'>",
        "<div style='border:1px solid #ffc107;background:#fff8e1;color:#7a5a00;padding:10px;border-radius:6px;'>",
        "<strong>REPRINT COPY</strong>",
    ]
    if stamp:
        parts.append(f" &mdash; Reprinted: {stamp}")
    if count:
        parts.append(f" &mdash; Reprint count: {count}")
    parts.append("</div></div>")
    banner = "".join(parts)
    return banner + html


_TX_META_SUPPORTED = None


_SALE_ITEM_IMAGING_ID_SUPPORTED = None


def _sale_item_supports_imaging_test_id() -> bool:
    """Return True if the database has SaleItem.imaging_test_id.

    Keeps the app from breaking when code is deployed before the migration is applied.
    """
    global _SALE_ITEM_IMAGING_ID_SUPPORTED
    if _SALE_ITEM_IMAGING_ID_SUPPORTED is not None:
        return bool(_SALE_ITEM_IMAGING_ID_SUPPORTED)
    try:
        from sqlalchemy import inspect as sqlalchemy_inspect

        inspector = sqlalchemy_inspect(db.engine)
        cols = [c.get('name') for c in (inspector.get_columns('sale_items') or [])]
        _SALE_ITEM_IMAGING_ID_SUPPORTED = ('imaging_test_id' in cols)
        return bool(_SALE_ITEM_IMAGING_ID_SUPPORTED)
    except Exception:
        _SALE_ITEM_IMAGING_ID_SUPPORTED = False
        return False


def _transaction_supports_metadata() -> bool:
    """Return True if the database has the new Transaction metadata columns.

    This keeps the app from breaking when code is deployed before the migration is applied.
    """
    global _TX_META_SUPPORTED
    if _TX_META_SUPPORTED is not None:
        return bool(_TX_META_SUPPORTED)
    try:
        from sqlalchemy import inspect as sqlalchemy_inspect

        inspector = sqlalchemy_inspect(db.engine)
        cols = [c.get('name') for c in (inspector.get_columns('transaction') or [])]
        _TX_META_SUPPORTED = ('reference_table' in cols)
        return bool(_TX_META_SUPPORTED)
    except Exception:
        _TX_META_SUPPORTED = False
        return False


def _maybe_set_transaction_meta(transaction: 'Transaction', **fields):
    if not transaction:
        return
    if not _transaction_supports_metadata():
        return
    for key, value in (fields or {}).items():
        try:
            setattr(transaction, key, value)
        except Exception:
            pass


def _get_transaction_for_sale(sale_id: int):
    q = Transaction.query.filter(
        Transaction.transaction_type == 'sale',
        Transaction.reference_id == sale_id,
    )
    if _transaction_supports_metadata():
        # Legacy rows may not have reference_table set.
        q = q.filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'sales'))
    return q.order_by(Transaction.created_at.desc()).first()


def _get_transaction_for_refund(refund_id: int):
    q = Transaction.query.filter(
        Transaction.transaction_type == 'refund',
        Transaction.reference_id == refund_id,
    )
    if _transaction_supports_metadata():
        q = q.filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'refunds'))
    return q.order_by(Transaction.created_at.desc()).first()


def _ensure_controlled_sale_transaction(sale: 'ControlledSale', receipt_html: Optional[str] = None):
    """Ensure controlled-drug sales are posted into Transaction (golden rule).

    Uses transaction_type='sale' but sets reference_table='controlled_sales' to avoid
    colliding with normal pharmacy sales.
    """
    if not sale:
        return None

    meta_supported = _transaction_supports_metadata()
    tx_type = 'sale' if meta_supported else 'controlled_sale'

    try:
        q = Transaction.query.filter(
            Transaction.transaction_type == tx_type,
            Transaction.reference_id == sale.id,
        )
        if meta_supported:
            q = q.filter(Transaction.reference_table == 'controlled_sales')
        existing = q.order_by(Transaction.created_at.desc()).first()
        if existing:
            if receipt_html:
                if not existing.receipt_number:
                    existing.receipt_number = getattr(sale, 'sale_number', None) or existing.receipt_number
                _ensure_transaction_receipt(existing, receipt_html, prefix='CTRL', force=False)
            db.session.add(existing)
            db.session.commit()
            return existing

        tx = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type=tx_type,
            amount=float(getattr(sale, 'total_amount', 0) or 0),
            user_id=int(getattr(sale, 'user_id', None) or 0) or (
                current_user.id
                if current_user and getattr(current_user, 'is_authenticated', False)
                else None
            ),
            reference_id=sale.id,
            notes=f"Controlled sale #{getattr(sale, 'sale_number', sale.id)}",
            created_at=getattr(sale, 'created_at', None) or get_eat_now(),
        )
        if meta_supported:
            _maybe_set_transaction_meta(
                tx,
                reference_table='controlled_sales',
                direction='IN',
                status='posted',
                department='pharmacy',
                category='controlled_drugs',
            )

            pay_method = None
            payer = None
            try:
                pay_method = getattr(sale, 'payment_method', None)
            except Exception:
                pay_method = None
            try:
                payer = getattr(sale, 'customer_name', None) or (sale.patient.name if getattr(sale, 'patient', None) else None)
            except Exception:
                payer = None
            _maybe_set_transaction_meta(tx, payment_method=pay_method, payer=payer)

        try:
            if getattr(sale, 'sale_number', None):
                tx.receipt_number = sale.sale_number
        except Exception:
            pass

        if receipt_html:
            _ensure_transaction_receipt(tx, receipt_html, prefix='CTRL', force=True)
        db.session.add(tx)
        db.session.commit()
        return tx
    except Exception as e:
        db.session.rollback()
        raise


def _ensure_sale_transaction(sale, receipt_html=None):
    """Ensure sales are posted into Transaction (golden rule).
    
    For lab tests, imaging tests, and other service sales.
    """
    if not sale:
        return None

    meta_supported = _transaction_supports_metadata()
    tx_type = 'sale'

    try:
        q = Transaction.query.filter(
            Transaction.transaction_type == tx_type,
            Transaction.reference_id == sale.id,
        )
        if meta_supported:
            q = q.filter(Transaction.reference_table == 'sales')
        existing = q.order_by(Transaction.created_at.desc()).first()
        if existing:
            if receipt_html:
                if not existing.receipt_number:
                    existing.receipt_number = getattr(sale, 'sale_number', None) or existing.receipt_number
                _ensure_transaction_receipt(existing, receipt_html, prefix='SALE', force=False)
            db.session.add(existing)
            db.session.commit()
            return existing

        tx = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type=tx_type,
            amount=float(getattr(sale, 'total_amount', 0) or 0),
            user_id=int(getattr(sale, 'user_id', None) or 0) or (
                current_user.id
                if current_user and getattr(current_user, 'is_authenticated', False)
                else None
            ),
            reference_id=sale.id,
            notes=f"Sale #{getattr(sale, 'sale_number', sale.id)}",
            created_at=getattr(sale, 'created_at', None) or get_eat_now(),
        )
        if meta_supported:
            _maybe_set_transaction_meta(
                tx,
                reference_table='sales',
                direction='IN',
                status='posted',
            )

        try:
            if getattr(sale, 'sale_number', None):
                tx.receipt_number = sale.sale_number
        except Exception:
            pass

        if receipt_html:
            _ensure_transaction_receipt(tx, receipt_html, prefix='SALE', force=True)
        db.session.add(tx)
        db.session.commit()
        return tx
    except Exception as e:
        current_app.logger.error(f'Failed to ensure sale transaction: {str(e)}', exc_info=True)
        db.session.rollback()
        return None


_RECEIPT_ALLOWED_TAGS = [
    'html', 'head', 'body', 'meta', 'title', 'style', 'link',
    'p', 'br', 'b', 'i', 'u', 'strong', 'small',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'div', 'span',
    'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td',
    'hr',
    'img',
    'button',
    'script',
]

_RECEIPT_ALLOWED_ATTRS = {
    '*': ['style', 'class', 'id'],
    'img': ['src', 'alt'],
    'link': ['rel', 'href'],
    'meta': ['name', 'content', 'charset'],
    'button': ['type', 'id'],
    'script': ['type'],
}

# CSS sanitizer to allow safe inline styles (if available)
if HAS_CSS_SANITIZER:
    _RECEIPT_CSS_SANITIZER = CSSSanitizer(
        allowed_css_properties=[
            'color', 'background-color', 'background', 'border', 'border-collapse',
            'font-family', 'font-size', 'font-weight', 'font-style',
            'text-align', 'text-decoration', 'text-transform',
            'margin', 'margin-top', 'margin-bottom', 'margin-left', 'margin-right',
            'padding', 'padding-top', 'padding-bottom', 'padding-left', 'padding-right',
            'width', 'max-width', 'height', 'min-height',
            'display', 'position', 'top', 'bottom', 'left', 'right',
            'border-radius', 'box-shadow',
        ]
    )
else:
    _RECEIPT_CSS_SANITIZER = None


def _sanitize_receipt_html(raw_html: str) -> str:
    clean_params = {
        'tags': _RECEIPT_ALLOWED_TAGS,
        'attributes': _RECEIPT_ALLOWED_ATTRS,
        'strip': True,
        'strip_comments': True,
    }
    
    # Only add css_sanitizer if it's available
    if HAS_CSS_SANITIZER and _RECEIPT_CSS_SANITIZER:
        clean_params['css_sanitizer'] = _RECEIPT_CSS_SANITIZER
    
    return bleach.clean(raw_html or '', **clean_params)


def _ensure_transaction_receipt(transaction: 'Transaction', html: str, prefix: str = 'RCPT', force: bool = False):
    if not transaction:
        return
    if not transaction.receipt_number:
        transaction.receipt_number = generate_receipt_number(prefix=prefix)
    if not transaction.receipt_created_at:
        transaction.receipt_created_at = get_eat_now()
    if html and (force or not transaction.receipt_html):
        transaction.receipt_html = _sanitize_receipt_html(html)
    db.session.add(transaction)


class Appointment(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    doctor_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    date = db.Column(db.Date, nullable=False)
    time = db.Column(db.Time, nullable=False)
    purpose = db.Column(db.String(200))
    status = db.Column(db.String(20), default='scheduled')  # scheduled, confirmed, cancelled, completed
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    patient = db.relationship('Patient', backref='appointments')
    doctor = db.relationship('User', backref='appointments')

class Debt(db.Model):
    __tablename__ = 'debts'
    
    id = db.Column(db.Integer, primary_key=True)
    debt_number = db.Column(db.String(50), unique=True, nullable=False)
    debt_type = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    creditor = db.Column(db.String(100), nullable=False)
    due_date = db.Column(db.Date)
    interest_rate = db.Column(db.Float, default=0.0)
    description = db.Column(db.Text)
    status = db.Column(db.String(20), default='active')
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    payments = db.relationship('DebtPayment', backref='debt', lazy=True)

    @property
    def amount_paid(self):
        try:
            return float(sum([(p.amount or 0) for p in (self.payments or [])]))
        except Exception:
            return 0.0

    @property
    def balance(self):
        try:
            return max(0.0, float(self.amount or 0) - float(self.amount_paid or 0))
        except Exception:
            return 0.0

    @property
    def last_payment_date(self):
        try:
            dates = [p.payment_date for p in (self.payments or []) if getattr(p, 'payment_date', None)]
            return max(dates) if dates else None
        except Exception:
            return None


def generate_debt_number():
    return f"DEBT-{datetime.now().strftime('%Y%m%d')}-{generate_random_string(4)}"

class Expense(db.Model):
    __tablename__ = 'expenses'
    
    id = db.Column(db.Integer, primary_key=True)
    expense_number = db.Column(db.String(50), unique=True, nullable=False)
    expense_type = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    description = db.Column(db.Text)
    due_date = db.Column(db.Date)
    payment_method = db.Column(db.String(20))
    status = db.Column(db.String(20), default='paid')  # paid, pending, cancelled
    paid_date = db.Column(db.Date)
    vendor_id = db.Column(db.Integer, db.ForeignKey('vendors.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    user = db.relationship('User', backref='expenses')
    vendor = db.relationship('Vendor', backref='expenses')

    @property
    def date(self):
        return self.paid_date or self.created_at

    @property
    def category(self):
        return self.expense_type

def generate_expense_number():
    return f"EXP-{datetime.now().strftime('%Y%m%d')}-{generate_random_string(4)}"

class Purchase(db.Model):
    __tablename__ = 'purchases'
    
    id = db.Column(db.Integer, primary_key=True)
    purchase_number = db.Column(db.String(50), unique=True, nullable=False)
    purchase_type = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    purchase_date = db.Column(db.Date, nullable=False)
    supplier = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

def generate_purchase_number():
    return f"PUR-{datetime.now().strftime('%Y%m%d')}-{generate_random_string(4)}"

class Employee(db.Model):
    __tablename__ = 'employees'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    position = db.Column(db.String(100))
    salary = db.Column(db.Float)
    hire_date = db.Column(db.Date)
    contact = db.Column(db.String(100))
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    payrolls = db.relationship('Payroll', backref='employee', lazy=True)
    user = db.relationship('User', backref='employee')


class Payroll(db.Model):
    __tablename__ = 'payrolls'
    
    id = db.Column(db.Integer, primary_key=True)
    payroll_number = db.Column(db.String(50), unique=True, nullable=False)
    employee_id = db.Column(db.Integer, db.ForeignKey('employees.id'))
    amount = db.Column(db.Float, nullable=False)
    payment_date = db.Column(db.Date, nullable=False)
    pay_period = db.Column(db.String(50))
    notes = db.Column(db.Text)
    status = db.Column(db.String(20), default='pending')
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    # Backward-compatible aliases used by templates/older UI.
    @property
    def salary(self) -> float:
        return float(self.amount or 0.0)

    @property
    def amount_paid(self) -> float:
        try:
            if getattr(self, 'payments', None):
                return float(sum([p.amount for p in self.payments]))
        except Exception:
            pass
        return 0.0

    @property
    def arrears(self) -> float:
        try:
            due = float(self.amount or 0.0)
            paid = float(self.amount_paid or 0.0)
            return float(max(0.0, due - paid))
        except Exception:
            return 0.0


def generate_payroll_number():
    return f"PAY-{datetime.now().strftime('%Y%m%d')}-{generate_random_string(4)}"

class Debtor(db.Model):
    __tablename__ = 'debtor'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    contact = db.Column(db.String(100))
    email = db.Column(db.String(100))
    Total_debt = db.Column(db.Float, nullable=False)
    amount_paid = db.Column(db.Float, nullable=False, default=0.0)
    amount_owed = db.Column(db.Float, default=0.0)
    last_payment_date = db.Column(db.Date)
    next_payment_date = db.Column(db.Date)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    payments = db.relationship('DebtorPayment', backref='debtor', lazy=True)


class PayrollPayment(db.Model):
    __tablename__ = 'payroll_payments'

    id = db.Column(db.Integer, primary_key=True)
    payroll_id = db.Column(db.Integer, db.ForeignKey('payrolls.id'), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    paid_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    payment_date = db.Column(db.DateTime, default=get_eat_now)
    notes = db.Column(db.Text)

    payroll = db.relationship('Payroll', backref=db.backref('payments', lazy=True))
    user = db.relationship('User', backref='payroll_payments')

class DebtorPayment(db.Model):
    __tablename__ = 'debtor_payments'
    
    id = db.Column(db.Integer, primary_key=True)
    debtor_id = db.Column(db.Integer, db.ForeignKey('debtor.id'))
    amount = db.Column(db.Float, nullable=False)
    payment_date = db.Column(db.Date, nullable=False)
    payment_method = db.Column(db.String(50), nullable=False)
    reference = db.Column(db.String(100))
    notes = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

class PatientService(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    service_id = db.Column(db.Integer, db.ForeignKey('service.id'), nullable=False)
    notes = db.Column(db.Text)
    # Lifecycle
    # requested -> billed -> in_progress -> done (or cancelled)
    status = db.Column(db.String(20), default='requested')
    requested_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    billed_sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'))
    billed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    billed_at = db.Column(db.DateTime)
    completed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    completed_at = db.Column(db.DateTime)
    performed_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    patient = db.relationship('Patient', backref='services')
    service = db.relationship('Service', backref='patient_services')
    performer = db.relationship('User', foreign_keys=[performed_by])
    requester = db.relationship('User', foreign_keys=[requested_by])
    biller = db.relationship('User', foreign_keys=[billed_by])
    completer = db.relationship('User', foreign_keys=[completed_by])
    billed_sale = db.relationship('Sale', foreign_keys=[billed_sale_id])


class AuditLog(db.Model):
    __tablename__ = 'audit_logs'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    action = db.Column(db.String(50), nullable=False)
    table_name = db.Column(db.String(50))  # Tracks which table was affected
    record_id = db.Column(db.Integer)      # ID of the affected record
    description = db.Column(db.String(255))  # For backward compatibility
    changes = db.Column(db.JSON)           # Structured change data
    old_values = db.Column(db.JSON)        # Previous values before change
    new_values = db.Column(db.JSON)        # Values after change
    ip_address = db.Column(db.String(50))  # IP address of the requester
    created_at = db.Column(db.DateTime, default=get_eat_now)


    # Relationship
    user = db.relationship('User', backref='audit_log_entries')

    def __init__(self, **kwargs):
        if 'description' not in kwargs and 'changes' in kwargs:
            kwargs['description'] = str(kwargs.get('changes'))
        super().__init__(**kwargs)

    def to_dict(self):
        """Returns audit log entry as dictionary"""
        return {
            'id': self.id,
            'user_id': self.user_id,
            'action': self.action,
            'table_name': self.table_name,
            'record_id': self.record_id,
            'description': self.description,
            'changes': self.changes,
            'old_values': self.old_values,
            'new_values': self.new_values,
            'ip_address': self.ip_address,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'user': {
                'id': self.user.id,
                'username': self.user.username
            } if self.user else None
        }

def generate_random_string(length=6):
    """Helper function to generate random strings"""
    chars = string.ascii_uppercase + string.digits
    return ''.join(random.choice(chars) for _ in range(length))


# ==================== REPORTING ENHANCEMENT MODELS ====================

class Invoice(db.Model):
    __tablename__ = 'invoices'

    id = db.Column(db.Integer, primary_key=True)
    invoice_number = db.Column(db.String(80), unique=True, nullable=False)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    date_issued = db.Column(db.DateTime, default=get_eat_now)
    due_date = db.Column(db.DateTime)
    total_amount = db.Column(db.Numeric(10, 2), nullable=False)
    paid_amount = db.Column(db.Numeric(10, 2), default=0.0)
    status = db.Column(db.String(20), default='unpaid')  # unpaid, paid, overdue, void
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    patient = db.relationship('Patient', backref='invoices')
    items = db.relationship('InvoiceItem', backref='invoice', lazy=True, cascade='all, delete-orphan')

class InvoiceItem(db.Model):
    __tablename__ = 'invoice_items'

    id = db.Column(db.Integer, primary_key=True)
    invoice_id = db.Column(db.Integer, db.ForeignKey('invoices.id'), nullable=False)
    description = db.Column(db.String(255), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    unit_price = db.Column(db.Numeric(10, 2), nullable=False)
    total_price = db.Column(db.Numeric(10, 2), nullable=False)

class FinancialReport(db.Model):
    __tablename__ = 'financial_reports'

    id = db.Column(db.Integer, primary_key=True)
    report_type = db.Column(db.String(50), nullable=False)  # e.g., 'daily', 'monthly', 'yearly'
    start_date = db.Column(db.Date, nullable=False)
    end_date = db.Column(db.Date, nullable=False)
    total_revenue = db.Column(db.Numeric(10, 2), default=0.0)
    total_expenses = db.Column(db.Numeric(10, 2), default=0.0)
    net_profit = db.Column(db.Numeric(10, 2), default=0.0)
    generated_at = db.Column(db.DateTime, default=get_eat_now)
    generated_by_id = db.Column(db.Integer, db.ForeignKey('user.id'))

    generated_by = db.relationship('User', backref='financial_reports')
    items = db.relationship('ReportItem', backref='financial_report', lazy=True, cascade='all, delete-orphan')

class ReportItem(db.Model):
    __tablename__ = 'report_items'

    id = db.Column(db.Integer, primary_key=True)
    report_id = db.Column(db.Integer, db.ForeignKey('financial_reports.id'), nullable=False)
    item_type = db.Column(db.String(50), nullable=False)  # 'revenue', 'expense'
    description = db.Column(db.String(255))
    amount = db.Column(db.Numeric(10, 2), nullable=False)
    date = db.Column(db.Date, nullable=False)
    reference_id = db.Column(db.Integer)
    reference_table = db.Column(db.String(50))

# =================================================================================================
# FINANCIAL DASHBOARD MODELS
# =================================================================================================

class FinancialMetrics(db.Model):
    """Stores pre-calculated financial metrics for dashboard performance"""
    __tablename__ = 'financial_metrics'
    
    id = db.Column(db.Integer, primary_key=True)
    metric_date = db.Column(db.Date, nullable=False, index=True)
    period_type = db.Column(db.String(20), nullable=False)  # 'daily', 'weekly', 'monthly', 'yearly'
    
    # Revenue by category
    pharmacy_revenue = db.Column(db.Float, default=0)
    lab_revenue = db.Column(db.Float, default=0)
    imaging_revenue = db.Column(db.Float, default=0)
    consultation_revenue = db.Column(db.Float, default=0)
    admission_revenue = db.Column(db.Float, default=0)
    other_revenue = db.Column(db.Float, default=0)
    total_revenue = db.Column(db.Float, default=0)
    
    # Expenses by category
    payroll_expense = db.Column(db.Float, default=0)
    pharmacy_expense = db.Column(db.Float, default=0)
    equipment_expense = db.Column(db.Float, default=0)
    utilities_expense = db.Column(db.Float, default=0)
    debt_payment = db.Column(db.Float, default=0)
    other_expense = db.Column(db.Float, default=0)
    total_expense = db.Column(db.Float, default=0)
    
    # Refunds and adjustments
    refunds = db.Column(db.Float, default=0)
    adjustments = db.Column(db.Float, default=0)
    
    # Net metrics
    gross_profit = db.Column(db.Float, default=0)
    net_profit = db.Column(db.Float, default=0)
    profit_margin = db.Column(db.Float, default=0)  # percentage
    
    # Cash flow
    cash_in = db.Column(db.Float, default=0)
    cash_out = db.Column(db.Float, default=0)
    cash_balance = db.Column(db.Float, default=0)
    
    # Patient metrics
    total_patients_served = db.Column(db.Integer, default=0)
    new_patients = db.Column(db.Integer, default=0)
    
    # Outstanding
    outstanding_invoices = db.Column(db.Float, default=0)
    overdue_amount = db.Column(db.Float, default=0)
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    __table_args__ = (
        db.UniqueConstraint('metric_date', 'period_type', name='uq_financial_metrics'),
    )


class DepartmentRevenue(db.Model):
    """Tracks revenue by department"""
    __tablename__ = 'department_revenue'
    
    id = db.Column(db.Integer, primary_key=True)
    metric_date = db.Column(db.Date, nullable=False, index=True)
    period_type = db.Column(db.String(20), nullable=False)  # 'daily', 'weekly', 'monthly', 'yearly'
    department = db.Column(db.String(100), nullable=False)  # pharmacy, lab, imaging, etc
    revenue_amount = db.Column(db.Float, default=0)
    transaction_count = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    
    __table_args__ = (
        db.UniqueConstraint('metric_date', 'period_type', 'department', name='uq_dept_revenue'),
    )


class DepartmentExpense(db.Model):
    """Tracks expenses by department"""
    __tablename__ = 'department_expense'
    
    id = db.Column(db.Integer, primary_key=True)
    metric_date = db.Column(db.Date, nullable=False, index=True)
    period_type = db.Column(db.String(20), nullable=False)  # 'daily', 'weekly', 'monthly', 'yearly'
    department = db.Column(db.String(100), nullable=False)  # payroll, pharmacy, equipment, etc
    expense_amount = db.Column(db.Float, default=0)
    transaction_count = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    
    __table_args__ = (
        db.UniqueConstraint('metric_date', 'period_type', 'department', name='uq_dept_expense'),
    )


class CashFlowDaily(db.Model):
    """Daily cash flow summary"""
    __tablename__ = 'cash_flow_daily'
    
    id = db.Column(db.Integer, primary_key=True)
    flow_date = db.Column(db.Date, nullable=False, unique=True, index=True)
    
    cash_receipts = db.Column(db.Float, default=0)
    mpesa_receipts = db.Column(db.Float, default=0)
    card_receipts = db.Column(db.Float, default=0)
    bank_receipts = db.Column(db.Float, default=0)
    total_receipts = db.Column(db.Float, default=0)
    
    cash_payments = db.Column(db.Float, default=0)
    mpesa_payments = db.Column(db.Float, default=0)
    card_payments = db.Column(db.Float, default=0)
    bank_payments = db.Column(db.Float, default=0)
    total_payments = db.Column(db.Float, default=0)
    
    opening_balance = db.Column(db.Float, default=0)
    closing_balance = db.Column(db.Float, default=0)
    net_change = db.Column(db.Float, default=0)
    
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    
# =================================================================================================
# INSURANCE MODELS
# =================================================================================================

class ReportAuditLog(db.Model):
    """Logs all report generation for compliance and audit trails"""
    __tablename__ = 'report_audit_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    report_type = db.Column(db.String(50), nullable=False)  # drug_sales, patients, department, etc
    filters = db.Column(db.JSON)  # {"start_date": "2026-01-01", "end_date": "2026-01-03", "granularity": "daily", ...}
    data_count = db.Column(db.Integer)  # Number of records in report
    generated_at = db.Column(db.DateTime, default=get_eat_now)
    ip_address = db.Column(db.String(50))
    status = db.Column(db.String(20), default='success')  # success, error, timeout
    error_message = db.Column(db.Text)  # If status is error
    
    user = db.relationship('User', backref='report_audits')


class DepartmentBudget(db.Model):
    """Tracks budgets per department for variance analysis"""
    __tablename__ = 'department_budgets'
    __table_args__ = (
        db.UniqueConstraint('department_name', 'fiscal_year', name='uq_department_budgets_department_year'),
    )
    
    id = db.Column(db.Integer, primary_key=True)
    department_name = db.Column(db.String(100), nullable=False)
    fiscal_year = db.Column(db.Integer, nullable=False)
    budgeted_amount = db.Column(db.Float, nullable=False)
    actual_amount = db.Column(db.Float, default=0)
    variance = db.Column(db.Float, default=0)  # actual - budgeted
    variance_percentage = db.Column(db.Float, default=0)  # variance / budgeted * 100
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)


class InsuranceProvider(db.Model):
    __tablename__ = 'insurance_providers'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(150), nullable=False, unique=True)
    phone = db.Column(db.String(50))
    email = db.Column(db.String(120))
    address = db.Column(db.String(200))
    created_at = db.Column(db.DateTime, default=get_eat_now)


class InsurancePolicy(db.Model):
    __tablename__ = 'insurance_policies'

    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    provider_id = db.Column(db.Integer, db.ForeignKey('insurance_providers.id'), nullable=False)
    policy_number = db.Column(db.String(80))
    member_number = db.Column(db.String(80))
    active = db.Column(db.Boolean, default=True)
    start_date = db.Column(db.Date)
    end_date = db.Column(db.Date)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    patient = db.relationship('Patient', backref='insurance_policies')
    provider = db.relationship('InsuranceProvider', backref='policies')


class InsuranceClaim(db.Model):
    __tablename__ = 'insurance_claims'

    id = db.Column(db.Integer, primary_key=True)
    claim_number = db.Column(db.String(60), nullable=False, unique=True)
    sale_id = db.Column(db.Integer, db.ForeignKey('sales.id'), nullable=False)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    provider_id = db.Column(db.Integer, db.ForeignKey('insurance_providers.id'), nullable=False)
    policy_id = db.Column(db.Integer, db.ForeignKey('insurance_policies.id'))
    status = db.Column(db.String(20), default='draft')  # draft, submitted, approved, rejected, paid
    claimed_amount = db.Column(db.Float, default=0)
    approved_amount = db.Column(db.Float)
    paid_amount = db.Column(db.Float, default=0)
    # Minimal approval/NHIF workflow fields (best-effort; migrations add columns)
    external_reference = db.Column(db.String(80))
    approved_by = db.Column(db.Integer)
    approved_at = db.Column(db.DateTime)
    rejected_at = db.Column(db.DateTime)
    rejected_reason = db.Column(db.Text)
    created_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    submitted_at = db.Column(db.DateTime)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)

    sale = db.relationship('Sale', backref='insurance_claims')
    patient = db.relationship('Patient', backref='insurance_claims')
    provider = db.relationship('InsuranceProvider', backref='claims')
    policy = db.relationship('InsurancePolicy', backref='claims')
    creator = db.relationship('User', backref='insurance_claims_created', foreign_keys=[created_by])


class InsuranceClaimItem(db.Model):
    __tablename__ = 'insurance_claim_items'
    __table_args__ = (
        db.UniqueConstraint('claim_id', 'sale_item_id', name='uq_insurance_claim_items_claim_sale_item'),
    )

    id = db.Column(db.Integer, primary_key=True)
    claim_id = db.Column(db.Integer, db.ForeignKey('insurance_claims.id'), nullable=False)
    sale_item_id = db.Column(db.Integer, db.ForeignKey('sale_items.id'), nullable=False)
    item_type = db.Column(db.String(30))  # drug, service, lab_test, imaging_test, other
    description = db.Column(db.String(255))
    quantity = db.Column(db.Integer, default=1)
    unit_price = db.Column(db.Float)
    total_price = db.Column(db.Float)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    claim = db.relationship('InsuranceClaim', backref=db.backref('items', lazy=True, cascade='all, delete-orphan'))
    sale_item = db.relationship('SaleItem', backref=db.backref('insurance_claim_items', lazy=True))


class InsuranceClaimPayment(db.Model):
    __tablename__ = 'insurance_claim_payments'

    id = db.Column(db.Integer, primary_key=True)
    claim_id = db.Column(db.Integer, db.ForeignKey('insurance_claims.id'), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    payment_method = db.Column(db.String(50))
    paid_at = db.Column(db.DateTime, default=get_eat_now)
    received_by = db.Column(db.Integer, db.ForeignKey('user.id'))
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)

    claim = db.relationship('InsuranceClaim', backref='payments')
    receiver = db.relationship('User', backref='insurance_claim_payments_received', foreign_keys=[received_by])


# Model aliases for backwards compatibility
PatientInsurance = InsurancePolicy
Claim = InsuranceClaim


# Insurance policy metadata helpers (no schema changes).
# We store structured flags in InsurancePolicy.notes to avoid breaking existing DBs.
_INS_META_PREFIX = 'INS_META:'


def _insurance_meta_from_notes(notes_text: str) -> dict:
    try:
        if not notes_text:
            return {}
        for line in str(notes_text).splitlines():
            if line.strip().startswith(_INS_META_PREFIX):
                raw = line.strip()[len(_INS_META_PREFIX):].strip()
                return json.loads(raw) if raw else {}
    except Exception:
        return {}
    return {}


def _insurance_notes_with_meta(existing_notes: str, meta: dict) -> str:
    try:
        meta_line = f"{_INS_META_PREFIX} {json.dumps(meta, ensure_ascii=False)}"
        lines = []
        if existing_notes:
            for line in str(existing_notes).splitlines():
                if line.strip().startswith(_INS_META_PREFIX):
                    continue
                lines.append(line)
        # Keep human notes first, meta last
        lines = [l for l in lines if str(l).strip()]
        lines.append(meta_line)
        return '\n'.join(lines).strip()
    except Exception:
        return existing_notes or ''


def _insurance_policy_meta(policy: 'InsurancePolicy') -> dict:
    try:
        return _insurance_meta_from_notes(getattr(policy, 'notes', None) or '')
    except Exception:
        return {}


def _insurance_policy_covers_inpatient(policy: 'InsurancePolicy') -> bool:
    meta = _insurance_policy_meta(policy)
    # Backward-compat: if unset, assume True so we don't block existing records.
    return bool(meta.get('covers_inpatient', True))


def _insurance_policy_set_covers_inpatient(policy: 'InsurancePolicy', covers: bool):
    meta = _insurance_policy_meta(policy)
    meta['covers_inpatient'] = bool(covers)
    policy.notes = _insurance_notes_with_meta(getattr(policy, 'notes', None) or '', meta)


def _insurance_policy_mark_verified(policy: 'InsurancePolicy', user_id: int):
    meta = _insurance_policy_meta(policy)
    meta['verified_by'] = int(user_id) if user_id else None
    meta['verified_at'] = get_eat_now().isoformat() if callable(get_eat_now) else datetime.utcnow().isoformat()
    meta['verification_status'] = 'verified'
    policy.notes = _insurance_notes_with_meta(getattr(policy, 'notes', None) or '', meta)


# Notification model - create if it doesn't already exist
class Notification(db.Model):
    __tablename__ = 'notifications'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    title = db.Column(db.String(200), nullable=False)
    message = db.Column(db.Text, nullable=False)
    is_read = db.Column(db.Boolean, default=False)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    
    user = db.relationship('User', backref='notifications')


# Vendor model - create if it doesn't already exist
class Vendor(db.Model):
    __tablename__ = 'vendors'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(150), nullable=False)
    contact = db.Column(db.String(50))
    email = db.Column(db.String(120))
    address = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)


class PurchaseOrder(db.Model):
    __tablename__ = 'purchase_orders'
    
    id = db.Column(db.Integer, primary_key=True)
    po_number = db.Column(db.String(50), unique=True, nullable=False)
    vendor_id = db.Column(db.Integer, db.ForeignKey('vendors.id'), nullable=True)
    date_ordered = db.Column(db.DateTime, default=get_eat_now)
    total_amount = db.Column(db.Float, default=0.0)
    status = db.Column(db.String(20), default='pending')  # pending, received, cancelled
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    created_by_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    
    vendor = db.relationship('Vendor', backref=db.backref('purchase_orders', lazy=True))
    items = db.relationship('PurchaseOrderItem', backref='purchase_order', cascade='all, delete-orphan')
    creator = db.relationship('User', foreign_keys=[created_by_id])

class PurchaseOrderItem(db.Model):
    __tablename__ = 'purchase_order_items'
    
    id = db.Column(db.Integer, primary_key=True)
    purchase_order_id = db.Column(db.Integer, db.ForeignKey('purchase_orders.id'), nullable=False)
    description = db.Column(db.String(255), nullable=False)
    quantity = db.Column(db.Integer, default=1)
    unit_price = db.Column(db.Float, default=0.0)
    total_price = db.Column(db.Float, default=0.0)


def generate_insurance_claim_number():
    return f"CLM-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def _ensure_insurance_claims_schema_best_effort():
    """Best-effort schema patching for SQLite when migrations weren't run."""
    try:
        if getattr(db.engine, 'dialect', None) is None:
            return
        if (db.engine.dialect.name or '').lower() != 'sqlite':
            return

        with db.engine.connect() as conn:
            res = conn.execute(text("PRAGMA table_info('insurance_claims')"))
            cols = [r[1] for r in res.fetchall()]

            if 'external_reference' not in cols:
                conn.execute(text("ALTER TABLE insurance_claims ADD COLUMN external_reference VARCHAR(80)"))
            if 'approved_by' not in cols:
                conn.execute(text("ALTER TABLE insurance_claims ADD COLUMN approved_by INTEGER"))
            if 'approved_at' not in cols:
                conn.execute(text("ALTER TABLE insurance_claims ADD COLUMN approved_at DATETIME"))
            if 'rejected_at' not in cols:
                conn.execute(text("ALTER TABLE insurance_claims ADD COLUMN rejected_at DATETIME"))
            if 'rejected_reason' not in cols:
                conn.execute(text("ALTER TABLE insurance_claims ADD COLUMN rejected_reason TEXT"))
    except Exception as schema_exc:
        try:
            current_app.logger.debug(f"Insurance claims schema check/alter failed: {schema_exc}")
        except Exception:
            pass


def _insurance_claim_items_table_exists() -> bool:
    try:
        from sqlalchemy import inspect as sqlalchemy_inspect
        inspector = sqlalchemy_inspect(db.engine)
        return bool(inspector.has_table('insurance_claim_items'))
    except Exception:
        return False


class PatientSegment(db.Model):
    """Patient segmentation for analytics (insurance type, VIP status, etc)"""
    __tablename__ = 'patient_segments'
    
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False, unique=True)
    insurance_type = db.Column(db.String(50))
    vip_status = db.Column(db.Boolean, default=False)
    referral_source = db.Column(db.String(100)) 
    patient_lifetime_value = db.Column(db.Float, default=0)
    visit_frequency = db.Column(db.Integer, default=0)
    average_transaction = db.Column(db.Float, default=0)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    patient = db.relationship('Patient', backref='segment')


class ProviderPerformance(db.Model):
    """Tracks provider (doctor) performance metrics"""
    __tablename__ = 'provider_performance'
    
    id = db.Column(db.Integer, primary_key=True)
    provider_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    fiscal_period = db.Column(db.String(20), nullable=False)
    patients_seen = db.Column(db.Integer, default=0)
    total_revenue = db.Column(db.Float, default=0)
    average_patient_value = db.Column(db.Float, default=0)
    procedures_completed = db.Column(db.Integer, default=0)
    readmission_count = db.Column(db.Integer, default=0)
    satisfaction_score = db.Column(db.Float)
    quality_score = db.Column(db.Float)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    provider = db.relationship('User', backref='performance_metrics')


class QualityMetric(db.Model):
    """Clinical quality metrics (readmission, mortality, outcomes)"""
    __tablename__ = 'quality_metrics'
    
    id = db.Column(db.Integer, primary_key=True)
    patient_id = db.Column(db.Integer, db.ForeignKey('patient.id'), nullable=False)
    admission_date = db.Column(db.DateTime, nullable=False)
    discharge_date = db.Column(db.DateTime)
    discharge_status = db.Column(db.String(20))
    length_of_stay = db.Column(db.Integer)
    readmitted_within_30d = db.Column(db.Boolean, default=False)
    readmission_date = db.Column(db.DateTime)
    primary_diagnosis = db.Column(db.String(200))
    adverse_events = db.Column(db.Integer, default=0)
    infections_acquired = db.Column(db.Boolean, default=False)
    notes = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=get_eat_now)
    updated_at = db.Column(db.DateTime, default=get_eat_now, onupdate=get_eat_now)
    
    patient = db.relationship('Patient', backref='quality_metrics')

@login_manager.user_loader
def load_user(user_id):
    return db.session.get(User, int(user_id))

_db_initialized = False
_db_schema_synced = False


def _quote_ident(name: str) -> str:
    # Safe for SQLite/PostgreSQL/MySQL identifier quoting.
    return '"' + str(name).replace('"', '""') + '"'


def _ensure_all_tables_and_columns(engine) -> tuple[int, int]:
    """Best-effort schema sync for existing DBs.

    - Creates any missing tables declared in db.metadata
    - Adds any missing columns declared in db.metadata tables

    Important: for compatibility/safety, added columns are created WITHOUT
    NOT NULL / UNIQUE / FK constraints, even if the ORM model has them.
    This avoids breaking existing SQLite databases. Proper constraints should
    still be managed via Alembic migrations in production.

    Returns: (tables_created, columns_added)
    """
    tables_created = 0
    columns_added = 0
    try:
        inspector = sa_inspect(engine)
        existing_tables = set(inspector.get_table_names())
        dialect = (getattr(engine, 'dialect', None) and engine.dialect.name) or ''

        # 1) Ensure all tables exist
        for table in db.metadata.sorted_tables:
            if table.name in existing_tables:
                continue
            try:
                table.create(bind=engine, checkfirst=True)
                tables_created += 1
            except Exception:
                try:
                    current_app.logger.exception('Schema sync: failed creating table %s', table.name)
                except Exception:
                    pass

        # Refresh inspector after potential table creation
        inspector = sa_inspect(engine)
        existing_tables = set(inspector.get_table_names())

        # 2) Ensure all columns exist for each table
        for table in db.metadata.sorted_tables:
            table_name = table.name
            if table_name not in existing_tables:
                continue

            try:
                existing_cols = {c.get('name') for c in inspector.get_columns(table_name)}
            except Exception:
                continue

            for col in table.columns:
                col_name = col.name
                if col_name in existing_cols:
                    continue

                # Compile SQL type for this engine.
                try:
                    col_type_sql = col.type.compile(dialect=engine.dialect)
                except Exception:
                    col_type_sql = str(col.type)
                if not col_type_sql:
                    col_type_sql = 'TEXT'

                table_sql = _quote_ident(table_name)
                col_sql = _quote_ident(col_name)

                try:
                    with engine.begin() as conn:
                        if dialect == 'postgresql':
                            conn.execute(sa_text(
                                f"ALTER TABLE {table_sql} ADD COLUMN IF NOT EXISTS {col_sql} {col_type_sql}"
                            ))
                        else:
                            conn.execute(sa_text(
                                f"ALTER TABLE {table_sql} ADD COLUMN {col_sql} {col_type_sql}"
                            ))
                    columns_added += 1
                except Exception:
                    # Don't block startup; log and continue.
                    try:
                        current_app.logger.exception(
                            'Schema sync: failed adding column %s.%s', table_name, col_name
                        )
                    except Exception:
                        pass

        return tables_created, columns_added
    except Exception:
        try:
            current_app.logger.exception('Schema sync failed')
        except Exception:
            pass
        return tables_created, columns_added


def _ensure_table_columns(engine, table_name: str, columns: dict[str, str]) -> int:
    """Best-effort, idempotent column creation for existing tables.

    This is primarily to keep older SQLite databases usable when we add new
    nullable columns to models without running Alembic migrations.
    """
    try:
        inspector = sa_inspect(engine)
        existing_tables = set(inspector.get_table_names())
        if table_name not in existing_tables:
            return 0

        existing_cols = {c.get('name') for c in inspector.get_columns(table_name)}
        missing = [name for name in columns.keys() if name not in existing_cols]
        if not missing:
            return 0

        dialect = (getattr(engine, 'dialect', None) and engine.dialect.name) or ''
        preparer = getattr(engine.dialect, 'identifier_preparer', None)
        quote = (preparer.quote if preparer else (lambda x: f'"{x}"'))
        table_sql = quote(table_name)
        with engine.begin() as conn:
            for col_name in missing:
                col_type = columns[col_name]
                col_sql = quote(col_name)
                if dialect == 'postgresql':
                    conn.execute(sa_text(f"ALTER TABLE {table_sql} ADD COLUMN IF NOT EXISTS {col_sql} {col_type}"))
                else:
                    conn.execute(sa_text(f"ALTER TABLE {table_sql} ADD COLUMN {col_sql} {col_type}"))

        return len(missing)
    except Exception:
        # Don't block app startup for best-effort schema fixes.
        try:
            current_app.logger.exception('Schema column ensure failed for %s', table_name)
        except Exception:
            pass
        return 0


def _ensure_known_backward_compat_columns(engine) -> None:
    # Keep Bed model compatible with older DBs (common on SQLite deployments).
    _ensure_table_columns(
        engine,
        'beds',
        {
            'assigned_at': 'DATETIME',
            'released_at': 'DATETIME',
        },
    )

    # Keep Ward model compatible.
    _ensure_table_columns(
        engine,
        'wards',
        {
            'daily_rate': 'REAL',
        },
    )

    # Keep Transaction model compatible.
    _ensure_table_columns(
        engine,
        'transaction',
        {
            'reference_table': 'VARCHAR(80)',
            'payment_intent_id': 'INTEGER',
            'provider_txn_id': 'INTEGER',
            'direction': 'VARCHAR(3)',
            'status': 'VARCHAR(20)',
            'department': 'VARCHAR(100)',
            'category': 'VARCHAR(100)',
            'payer': 'VARCHAR(120)',
            'payment_method': 'VARCHAR(50)',
            'notes': 'TEXT',
            'receipt_number': 'VARCHAR(50)',
            'receipt_html': 'TEXT',
            'receipt_created_at': 'DATETIME',
            'receipt_reprinted_at': 'DATETIME',
            'receipt_reprint_count': 'INTEGER DEFAULT 0',
            'updated_at': 'DATETIME',
        },
    )

    # Keep M-Pesa tables compatible with optional PaymentIntent/ProviderTxn linking.
    _ensure_table_columns(
        engine,
        'mpesa_payments',
        {
            'payment_intent_id': 'INTEGER',
            'provider_txn_id': 'INTEGER',
        },
    )
    _ensure_table_columns(
        engine,
        'mpesa_payouts',
        {
            'payment_intent_id': 'INTEGER',
            'provider_txn_id': 'INTEGER',
        },
    )
    _ensure_table_columns(
        engine,
        'mpesa_txn_status_queries',
        {
            'payment_intent_id': 'INTEGER',
            'provider_txn_id': 'INTEGER',
        },
    )

    # Keep PatientService compatible (requested services lifecycle).
    _ensure_table_columns(
        engine,
        'patient_service',
        {
            'status': 'VARCHAR(20)',
            'requested_by': 'INTEGER',
            'billed_sale_id': 'INTEGER',
            'billed_by': 'INTEGER',
            'billed_at': 'DATETIME',
            'completed_by': 'INTEGER',
            'completed_at': 'DATETIME',
        },
    )

    # Keep Patient compatible (discharge workflow for inpatients).
    _ensure_table_columns(
        engine,
        'patient',
        {
            'discharge_state': 'VARCHAR(20)',
            'discharge_requested_at': 'DATETIME',
            'discharge_requested_by': 'INTEGER',
            'discharged_at': 'DATETIME',
            'discharged_by': 'INTEGER',
        },
    )

@app.before_request
def ensure_database_initialized():
    """Ensure database schema exists and default users are created before handling any request."""
    global _db_initialized, _db_schema_synced
    if not _db_initialized:
        _db_initialized = True
        try:
            from sqlalchemy import inspect as sa_inspect
            import time
            
            engine = db.engine
            
            # Retry logic for database connection with exponential backoff
            max_retries = 3
            retry_delay = 1  # seconds
            
            for attempt in range(max_retries):
                try:
                    inspector = sa_inspect(engine)
                    existing_tables = set(inspector.get_table_names())
                    break  # Success, exit retry loop
                except Exception as conn_err:
                    if attempt < max_retries - 1:
                        app.logger.warning(f"Database connection attempt {attempt + 1}/{max_retries} failed. Retrying in {retry_delay}s...")
                        time.sleep(retry_delay)
                        retry_delay *= 2  # Exponential backoff
                    else:
                        # All retries exhausted
                        raise conn_err
            
            expected_tables = set(db.metadata.tables.keys())
            missing_tables = sorted(expected_tables - existing_tables)
            
            if missing_tables:
                app.logger.warning(f"Database missing {len(missing_tables)} tables. Creating them now...")
                # db.create_all()
                inspector = sa_inspect(engine)
                new_tables = set(inspector.get_table_names())
                # app.logger.info(f"✓ Database schema initialized successfully. Created {len(new_tables)} tables.")
            else:
                pass  # Database schema verification silent

            # Ensure all tables/columns exist (runtime-safe migration for older DBs).
            if not _db_schema_synced:
                _db_schema_synced = True
                created_tables, added_cols = _ensure_all_tables_and_columns(engine)
                # Silently skip schema sync logs
                # if created_tables or added_cols:
                #     app.logger.info(
                #         "✓ Schema sync applied: created %d tables, added %d columns.",
                #         created_tables,
                #         added_cols,
                #     )
                # else:
                #     app.logger.info("✓ Schema sync: no changes needed.")
            
            # Create default users if they don't exist
            _create_default_users()
            
        except Exception as e:
            app.logger.error(f"✗ Database initialization failed: {str(e)}", exc_info=True)
            # In development, show a clear error
            if app.config.get('DEBUG'):
                raise
            # In production, try to continue but the app will likely fail on DB queries
            abort(503)


def _create_default_users():
    """Create default admin user from .env only if no users exist. Runs only on initial DB setup."""
    try:
        user_count = User.query.count()
        if user_count > 0:
            app.logger.info("Users already exist. Skipping default admin creation.")
            return
        from dotenv import load_dotenv
        load_dotenv()
        admin_username = os.getenv('DEFAULT_ADMIN_USERNAME')
        admin_email = os.getenv('DEFAULT_ADMIN_EMAIL')
        admin_password = os.getenv('DEFAULT_ADMIN_PASSWORD')
        admin_role = 'admin'
        if not (admin_username and admin_email and admin_password):
            app.logger.warning("Default admin credentials not set in .env. Skipping admin creation.")
            return
        user = User(
            username=admin_username,
            email=admin_email,
            role=admin_role,
            is_active=True,
            is_email_verified=True
        )
        user.set_password(admin_password)
        db.session.add(user)
        db.session.commit()
        app.logger.info(f"✓ Default admin user created: {admin_email}")
    except Exception as e:
        app.logger.error(f"✗ Failed to create default admin: {str(e)}")
        db.session.rollback()


def _remove_duplicate_users():
    """Remove duplicate users keeping only the most recent one by ID."""
    try:
        # Get all users grouped by email
        all_users = User.query.all()
        emails_seen = {}
        duplicates_to_delete = []
        
        for user in all_users:
            try:
                user_email = str(user.email).strip().lower()
                
                if user_email in emails_seen:
                    # Keep the user with smaller ID (created first), delete the newer one
                    existing_user = emails_seen[user_email]
                    if user.id > existing_user.id:
                        duplicates_to_delete.append(user)
                    else:
                        # Current user has smaller ID, so keep it and mark old one for deletion
                        duplicates_to_delete.append(existing_user)
                        emails_seen[user_email] = user
                else:
                    emails_seen[user_email] = user
            except Exception as e:
                app.logger.warning(f"Error processing user {user.id}: {e}")
                continue
        
        # Delete duplicates
        if duplicates_to_delete:
            deleted_count = 0
            for duplicate in duplicates_to_delete:
                try:
                    app.logger.warning(f"Removing duplicate user: ID={duplicate.id}, email={duplicate.email}")
                    db.session.delete(duplicate)
                    deleted_count += 1
                except Exception as e:
                    app.logger.error(f"Failed to delete duplicate user {duplicate.id}: {e}")
                    db.session.rollback()
            
            if deleted_count > 0:
                db.session.commit()
                app.logger.info(f"✓ Removed {deleted_count} duplicate user(s)")
    
    except Exception as e:
        app.logger.error(f"✗ Failed to remove duplicates: {str(e)}")
        db.session.rollback()

# Audit logging function
def log_audit(action, table=None, record_id=None, user_id=None, changes=None, 
             old_values=None, new_values=None, ip_address=None):
    """
    Logs an audit trail entry with comprehensive tracking
    
    Args:
        action (str): The action performed (e.g., 'create', 'update', 'delete')
        table (str): Name of the database table affected
        record_id: ID of the affected record
        user_id: ID of the user performing the action
        changes (dict): Summary of changes made (for complex operations)
        old_values: Previous values before change (for updates)
        new_values: New values after change (for updates)
        ip_address: IP address of the requester
    """
    try:
        user_id = user_id if user_id is not None else (
            current_user.id if current_user.is_authenticated else None
        )
        
        ip_address = ip_address if ip_address is not None else request.remote_addr
        
        # Serialize changes to JSON if it's a dict
        changes_json = None
        if changes:
            if isinstance(changes, dict):
                changes_json = json.dumps(changes, default=str)
            else:
                changes_json = changes  # Already a string or JSON
        elif new_values is not None:
            if isinstance(new_values, dict):
                changes_json = json.dumps({'new_values': new_values}, default=str)
            else:
                changes_json = str(new_values)
        
        # Serialize old_values to JSON string if dict
        old_values_json = None
        if old_values:
            if isinstance(old_values, dict):
                old_values_json = json.dumps(old_values, default=str)
            else:
                old_values_json = str(old_values)
        
        # Serialize new_values to JSON string if dict
        new_values_json = None
        if new_values:
            if isinstance(new_values, dict):
                new_values_json = json.dumps(new_values, default=str)
            else:
                new_values_json = str(new_values)
        
        log = AuditLog(
            user_id=user_id,
            action=action,
            table_name=table,
            record_id=record_id,
            changes=changes_json,
            old_values=old_values_json,
            new_values=new_values_json,
            ip_address=ip_address,
            created_at=get_eat_now()
        )
        
        db.session.add(log)
        db.session.commit()
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to log audit trail: {str(e)}")

# Admin JSON decorator and helpers

def admin_required_json(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        if not current_user.is_authenticated or current_user.role != 'admin':
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        return f(*args, **kwargs)
    return wrapper


def roles_required_json(*allowed_roles: str):
    """Require an authenticated user whose role is in allowed_roles."""

    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            if not current_user.is_authenticated:
                return jsonify({'success': False, 'error': 'Unauthorized'}), 403
            role = getattr(current_user, 'role', None)
            if role not in set([r for r in allowed_roles if r]):
                return jsonify({'success': False, 'error': 'Forbidden'}), 403
            return f(*args, **kwargs)

        return wrapper

    return decorator


def parse_price(value):
    try:
        amount = Decimal(str(value))
        if amount < 0:
            return None, 'Price must be non-negative'
        amount = amount.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
        return amount, None
    except (InvalidOperation, TypeError):
        return None, 'Invalid price'


def parse_bool(value):
    if value is None:
        return False
    if isinstance(value, bool):
        return value
    return str(value).lower() in ('1', 'true', 'on', 'yes')


def bad_request(message):
    return jsonify({'success': False, 'error': message}), 400


def success_response(data=None, status=200):
    payload = {'success': True}
    if data is not None:
        payload['data'] = data
    return jsonify(payload), status

# Utility functions
def _normalize_patient_type(patient_type: str | None) -> str:
    pt = (patient_type or '').strip().upper()
    return pt if pt in {'OP', 'IP'} else 'OP'


def _extract_mnc_suffix_int(number_value: str | None) -> int | None:
    """Extract integer suffix after 'MNC' from legacy or current formats.

    Supports:
    - 'OP MNC001'
    - 'OPMNC001'
    - 'IP MNC12'
    """
    if not number_value:
        return None
    s = str(number_value).strip().upper()
    if 'MNC' not in s:
        return None
    try:
        tail = s.split('MNC', 1)[-1].strip()
        # Keep only digits from tail (defensive against accidental suffixes).
        digits = ''.join(ch for ch in tail if ch.isdigit())
        if not digits:
            return None
        return int(digits)
    except Exception:
        return None


def _recent_patient_number_max(patient_type: str, limit: int = 2500) -> int:
    """Best-effort max-seq discovery, optimized for large datasets.

    We read the most recently inserted rows (by id) and parse the numeric suffix.
    This avoids slow full-table scans and avoids lexicographic ordering issues
    once the sequence grows beyond 999.
    """
    pt = _normalize_patient_type(patient_type)
    col = Patient.op_number if pt == 'OP' else Patient.ip_number
    prefix = pt

    rows = (
        db.session.query(col)
        .filter(col.isnot(None))
        .filter(col.ilike(f'{prefix}%'))
        .order_by(Patient.id.desc())
        .limit(int(limit))
        .all()
    )
    best = 0
    for (val,) in rows:
        seq = _extract_mnc_suffix_int(val)
        if seq and seq > best:
            best = seq
    return int(best)


def peek_patient_number(patient_type: str | None) -> str:
    """Return the next OP/IP number for display, without reserving it."""
    pt = _normalize_patient_type(patient_type)
    prefix = pt

    counter = db.session.get(PatientNumberCounter, pt)
    if counter and isinstance(counter.last_value, int):
        next_value = int(counter.last_value) + 1
    else:
        next_value = _recent_patient_number_max(pt) + 1

    return f"{prefix} MNC{next_value:03d}"


def generate_patient_number(patient_type):
    """Reserve and return a unique patient number (collision-safe).

    Uses a row-locked counter so multiple concurrent requests can't collide.
    """
    pt = _normalize_patient_type(patient_type)
    prefix = pt

    # Retry in case two workers try to create the counter row at the same time.
    for attempt in (1, 2, 3):
        try:
            with db.session.begin_nested():
                counter = (
                    PatientNumberCounter.query
                    .filter_by(kind=pt)
                    .with_for_update()
                    .first()
                )

                if not counter:
                    seed = _recent_patient_number_max(pt)
                    counter = PatientNumberCounter(kind=pt, last_value=int(seed))
                    db.session.add(counter)
                    db.session.flush()

                # Drift protection (manual inserts / imports): ensure counter is at least current max.
                try:
                    recent_max = _recent_patient_number_max(pt, limit=200)
                    if recent_max > int(counter.last_value or 0):
                        counter.last_value = int(recent_max)
                except Exception:
                    pass

                counter.last_value = int(counter.last_value or 0) + 1
                next_value = int(counter.last_value)

            return f"{prefix} MNC{next_value:03d}"
        except IntegrityError:
            # Counter row insert race: rollback nested transaction and retry.
            try:
                db.session.rollback()
            except Exception:
                pass
            if attempt >= 3:
                raise
            continue

# Preserve a reference to the robust implementation so any legacy/duplicate
# definitions later in this file can safely delegate without recursion.
_generate_patient_number_impl = generate_patient_number

def generate_sale_number():
    now = datetime.now()
    return f"SALE-{now.strftime('%Y%m%d')}-{random.randint(1000, 9999)}"

def generate_bulk_sale_number():
    now = datetime.now()
    return f"BULK-{now.strftime('%Y%m%d')}-{random.randint(1000, 9999)}"

def generate_individual_sale_number():
    now = datetime.now()
    return f"ITEM-{now.strftime('%Y%m%d')}-{random.randint(100, 999)}"

def database_is_sqlite():
    try:
        inspector = sa_inspect(db.engine)
        return inspector.dialect.name == 'sqlite'
    except:
        return False

def database_is_postgresql():
    try:
        inspector = sa_inspect(db.engine)
        return inspector.dialect.name == 'postgresql'
    except:
        return False

def get_database_dialect():
    try:
        inspector = sa_inspect(db.engine)
        return inspector.dialect.name
    except:
        return 'unknown'


def database_has_table(table_name: str) -> bool:
    try:
        inspector = sa_inspect(db.engine)
        return table_name in (inspector.get_table_names() or [])
    except Exception:
        return False

@app.route('/keep-alive', methods=['GET'])
def keep_alive():
    """Fast keep-alive endpoint that performs no database writes."""
    return jsonify({'status': 'ok'}), 200

@app.route('/')
def home():
    if current_user.is_authenticated:
        # Compare roles as strings (handles EncryptedType)
        user_role = str(current_user.role).lower().strip() if current_user.role else ''
        if user_role == 'admin':
            return redirect(url_for('admin_dashboard'))
        elif user_role == 'doctor':
            return redirect(url_for('doctor_restore_last'))
        elif user_role == 'pharmacist':
            return redirect(url_for('pharmacist_dashboard'))
        elif user_role == 'receptionist':
            return redirect(url_for('receptionist_dashboard'))
    return redirect(url_for('auth.login'))
@app.route('/profile', methods=['GET', 'POST'])
@login_required
def profile():
    if request.method == 'POST':
        # ...existing code for saving patient...
        db.session.commit()
        flash('Patient saved successfully!', 'success')
        if 'profile_picture' in request.files:
            file = request.files['profile_picture']
            if file and file.filename != '' and allowed_file(file.filename):
                os.makedirs(PROFILE_PICTURE_FOLDER, exist_ok=True)
                filename = secure_filename(file.filename)
                timestamp = str(int(time.time()))
                filename = f"user_{current_user.id}_{timestamp}_{filename}"
                filepath = os.path.join(PROFILE_PICTURE_FOLDER, filename)
                file.save(filepath)
                if current_user.profile_picture:
                    old_path = os.path.join(app.root_path, 'static', current_user.profile_picture)
                    if os.path.exists(old_path):
                        try:
                            os.remove(old_path)
                        except Exception as e:
                            app.logger.error(f"Error deleting old profile picture: {str(e)}")

                current_user.profile_picture = os.path.join('uploads', 'profile_pictures', filename).replace('\\', '/')

        current_user.username = request.form.get('username', current_user.username)
        current_user.email = request.form.get('email', current_user.email)
        
        new_password = request.form.get('new_password')
        if new_password:
            if check_password_hash(current_user.password, request.form.get('current_password')):
                current_user.set_password(new_password)
                flash('Password updated successfully!', 'success')
            else:
                flash('Current password is incorrect', 'danger')
        
        db.session.commit()
        flash('Profile updated successfully!', 'success')
        return redirect(url_for('profile'))
    
    return render_template('profile.html', user=current_user)

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in {'png', 'jpg', 'jpeg', 'gif'}


# ============================================
# Access Control Helper Functions
# ============================================

def get_user_accessible_ward_ids(user):
    """Get IDs of wards accessible by the user."""
    if not user or user.role not in ['doctor', 'nurse']:
        return []
    
    ward_assignments = UserWardAssignment.query.filter_by(user_id=user.id).all()
    return [a.ward_id for a in ward_assignments]


def get_user_accessible_department_ids(user):
    """Get IDs of outpatient departments accessible by the user."""
    if not user or user.role != 'doctor':
        return []
    
    department_assignments = UserDepartmentAssignment.query.filter_by(user_id=user.id).all()
    return [a.department_id for a in department_assignments]


def filter_accessible_patients(query, user):
    """
    Filter patient query based on user's ward and department assignments.
    
    Args:
        query: SQLAlchemy query object for Patient model
        user: Current user object
        
    Returns:
        Filtered query object
    """
    # Admin can see all patients
    if user.role == 'admin':
        return query
    
    # If user has no assignments, return empty query for safety (or all patients for backward compatibility)
    ward_ids = get_user_accessible_ward_ids(user)
    dept_ids = get_user_accessible_department_ids(user)
    
    # If no assignments, show all patients (backward compatibility with existing system)
    if not ward_ids and not dept_ids:
        return query
    
    # Build filter conditions
    conditions = []
    
    # For doctors and nurses: filter inpatients by ward
    if ward_ids and user.role in ['doctor', 'nurse']:
        # Inpatients are those with IP numbers and currently admitted (have a bed)
        inpatient_condition = db.and_(
            Patient.ip_number.isnot(None),
            Patient.id.in_(
                db.select([Bed.patient_id]).where(
                    db.and_(
                        Bed.patient_id.isnot(None),
                        Bed.ward_id.in_(ward_ids)
                    )
                )
            )
        )
        conditions.append(inpatient_condition)
    
    # For doctors: filter outpatients by department
    if dept_ids and user.role == 'doctor':
        # Outpatients are those with OP numbers and assigned to a department
        outpatient_condition = db.and_(
            Patient.op_number.isnot(None),
            Patient.department_id.in_(dept_ids)
        )
        conditions.append(outpatient_condition)
    
    # Apply OR condition if we have any filters
    if conditions:
        query = query.filter(db.or_(*conditions))
    
    return query


def get_accessible_inpatients(user):
    """Get inpatients accessible by the user based on ward assignments."""
    base_query = Patient.query.filter(Patient.ip_number.isnot(None))
    
    # Admin sees all inpatients
    if user.role == 'admin':
        return base_query.all()
    
    # Get user's ward assignments
    ward_ids = get_user_accessible_ward_ids(user)
    
    # If no assignments, return all inpatients (backward compatibility)
    if not ward_ids:
        return base_query.all()
    
    # Filter inpatients by ward
    accessible_patients = base_query.join(Bed, Bed.patient_id == Patient.id).filter(
        Bed.ward_id.in_(ward_ids),
        Bed.patient_id.isnot(None)
    ).all()
    
    return accessible_patients


def get_accessible_outpatients(user):
    """Get outpatients accessible by the user based on department assignments."""
    base_query = Patient.query.filter(Patient.op_number.isnot(None))
    
    # Admin sees all outpatients
    if user.role == 'admin':
        return base_query.all()
    
    # Only doctors have department assignments
    if user.role != 'doctor':
        return base_query.all()
    
    # Get user's department assignments
    dept_ids = get_user_accessible_department_ids(user)
    
    # If no assignments, return all outpatients (backward compatibility)
    if not dept_ids:
        return base_query.all()
    
    # Filter outpatients by department
    accessible_patients = base_query.filter(
        Patient.department_id.in_(dept_ids)
    ).all()
    
    return accessible_patients


def can_user_access_patient(user, patient):
    """Check if user can access a specific patient."""
    # Admin can access all patients
    if user.role == 'admin':
        return True
    
    # Get user assignments
    ward_ids = get_user_accessible_ward_ids(user)
    dept_ids = get_user_accessible_department_ids(user)
    
    # If no assignments, allow access (backward compatibility)
    if not ward_ids and not dept_ids:
        return True
    
    # Check if patient is an inpatient in user's ward
    if patient.ip_number and ward_ids:
        if patient.bed_assignment and patient.bed_assignment.ward_id in ward_ids:
            return True
    
    # Check if patient is an outpatient in user's department
    if patient.op_number and patient.department_id and dept_ids:
        if patient.department_id in dept_ids:
            return True
    
    return False



@auth_bp.route('/login', methods=['GET', 'POST'])
@limiter.limit("5 per minute")
def login():
    if current_user.is_authenticated:
        return redirect(url_for('home'))

    # Allow verification flow to remain on the login page.
    prefill_email = (request.args.get('verify_email') or '').strip()
    show_email_verification = bool(prefill_email)
    
    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password')
        role = request.form.get('role')
        remember = True if request.form.get('remember') else False
        
        current_app.logger.info(f"Login attempt - email/username: {email}, role: {role}")
        
        # Since email and username are encrypted, we must fetch all users and check in Python
        user = None
        for candidate in User.query.all():
            # Compare roles as strings (handles EncryptedType comparison properly)
            candidate_role = str(candidate.role).lower().strip() if candidate.role else ''
            target_role = str(role).lower().strip() if role else ''
            
            # Compare email/username as strings (handles EncryptedType)
            candidate_email = str(candidate.email).lower().strip() if candidate.email else ''
            candidate_username = str(candidate.username).lower().strip() if candidate.username else ''
            input_email = str(email).lower().strip() if email else ''
            
            current_app.logger.debug(f"Checking candidate - username: {candidate_username}, email: {candidate_email}, role: {candidate_role}, active: {candidate.is_active}")
            
            if (candidate_email == input_email or candidate_username == input_email) and candidate.is_active and candidate_role == target_role:
                current_app.logger.info(f"Found matching user: {candidate_username}")
                if candidate.check_password(password):
                    user = candidate
                    current_app.logger.info(f"Password verified for user: {candidate_username}")
                    break
                else:
                    current_app.logger.warning(f"Password mismatch for user: {candidate_username}")
        
        if user:
            if not getattr(user, 'is_email_verified', True):
                # Keep the user on the login page and let them request + verify OTP.
                verification_email = (str(getattr(user, 'email', '') or '')).strip()
                flash('Your email is not verified. Request an OTP to continue.', 'warning')
                return render_template(
                    'auth/login.html',
                    show_email_verification=True,
                    prefill_email=verification_email,
                    prefill_role=role,
                )

            current_app.logger.info(f"Logging in user: {user.username}, role: {user.role}")
            login_user(user, remember=remember, fresh=True)
            user.last_login = get_eat_now()
            try:
                db.session.commit()
            except Exception as e:
                current_app.logger.error(f"Error committing user login: {str(e)}")
                db.session.rollback()
            
            flash('Login successful!', 'success')
            
            # Get the redirect target based on user role (compare as strings)
            user_role = str(user.role).lower().strip() if user.role else ''
            next_page = request.args.get('next')
            if not next_page or not next_page.startswith('/'):
                if user_role == 'admin':
                    next_page = url_for('admin_dashboard')
                elif user_role == 'doctor':
                    next_page = url_for('doctor_restore_last')
                elif user_role == 'nurse':
                    next_page = url_for('nurse_dashboard')
                elif user_role == 'pharmacist':
                    next_page = url_for('pharmacist_dashboard')
                elif user_role == 'receptionist':
                    next_page = url_for('receptionist_dashboard')
                elif user_role == 'labtech':
                    next_page = url_for('labtech_dashboard')
                else:
                    next_page = url_for('home')
            
            current_app.logger.info(f"Redirecting to: {next_page}")
            return redirect(next_page)
        
        current_app.logger.warning(f"Login failed for email/username: {email}, role: {role}")
        flash('Invalid credentials or role', 'danger')
    
    return render_template(
        'auth/login.html',
        show_email_verification=show_email_verification,
        prefill_email=prefill_email,
    )

@app.context_processor
def inject_current_date():
    return {'current_date': get_eat_today().strftime('%Y-%m-%d')}

@app.context_processor
def inject_csrf_token():
    """Expose csrf_token() in all Jinja templates"""
    return dict(csrf_token=generate_csrf, csrf_value=generate_csrf())

@app.context_processor
def inject_stamp_signature_functions():
    """Make stamp and signature generators available in all templates"""
    from utils.stamp_signature import (
        generate_rubber_stamp, 
        generate_digital_signature,
        get_current_stamp_date,
        get_current_signature_date,
        get_stamp_typography,
    )
    return dict(
        generate_rubber_stamp=generate_rubber_stamp,
        generate_digital_signature=generate_digital_signature,
        get_current_stamp_date=get_current_stamp_date,
        get_current_signature_date=get_current_signature_date,
        stamp_typography=get_stamp_typography(),
    )

@csrf.exempt
@app.route('/logout', methods=['POST'])
@login_required
def logout():
    log_audit('logout')
    logout_user()
    flash('You have been logged out.', 'info')
    return redirect(url_for('auth.login'))


def _send_system_email(
    *,
    recipient: str,
    subject: str,
    html: str,
    text_body: str | None = None,
    attachments: list[tuple[str, str, bytes]] | None = None,
) -> None:
    """Send system emails (user OTP, password reset) via Resend."""
    if app.config.get('FAST_DEV'):
        app.logger.info("FAST_DEV enabled: system email sending skipped.")
        return
    # Validate inputs
    if not recipient or '@' not in recipient:
        app.logger.error(f"Invalid recipient email for system email: {recipient}")
        return
    
    if not subject or not subject.strip():
        app.logger.error("Cannot send system email with empty subject")
        return
    
    if not html or not html.strip():
        app.logger.error("Cannot send system email with empty body")
        return
    
    # Log email send attempt
    app.logger.info(f"Attempting to send email to: {recipient}, Subject: {subject}")
    
    # Prepare text body
    text_content = text_body or 'Your email client does not support HTML.'
    
    def _send_with_audit():
        try:
            with app.app_context():
                if not _email_sender.is_healthy():
                    app.logger.warning("Resend not configured; system email not sent.")
                    return
                
                app.logger.info(f"Sending email via Resend to {recipient}")
                result = _email_sender.send(
                    recipient=recipient,
                    subject=subject,
                    html_body=html,
                    text_body=text_content,
                    attachments=attachments,
                )
                _email_audit_logger.log_send(result)
                
                if result.success:
                    app.logger.info(f"✓ Email sent successfully to {recipient}")
                else:
                    app.logger.error(
                        f"✗ Email send failed to {recipient} after {result.attempt_count} attempts: {result.error}"
                    )
                    # Check if using test domain
                    if 'onboarding@resend.dev' in _resend_config.from_address.lower():
                        app.logger.error(
                            f"⚠ You are using Resend's test domain. "
                            f"If {recipient} is not verified in your Resend dashboard, "
                            f"the email will be silently rejected. "
                            f"Solution: Add and verify your own domain at https://resend.com/domains"
                        )
        except Exception as e:
            try:
                with app.app_context():
                    app.logger.exception(f"Email send failed with exception: {e}")
            except:
                pass
    
    # Send async to avoid blocking HTTP response
    try:
        Thread(target=_send_with_audit, daemon=True, name="system-email").start()
    except Exception as e:
        app.logger.error(f"Failed to start email thread: {e}")
        # Last resort: try synchronous send
        try:
            _send_with_audit()
        except Exception as e2:
            app.logger.error(f"Email send failed completely: {e2}")


def _is_valid_email_address(value: str | None) -> bool:
    s = (value or '').strip()
    if not s or len(s) > 254:
        return False
    # Simple sanity check; avoid strict RFC validation.
    return bool(re.match(r'^[^\s@]+@[^\s@]+\.[^\s@]+$', s))


def _get_instance_path(filename: str) -> str:
    instance_dir = Path(app.root_path) / 'instance'
    instance_dir.mkdir(parents=True, exist_ok=True)
    return str((instance_dir / filename).resolve())


def _load_instance_json(filename: str, default):
    path = _get_instance_path(filename)
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception:
        return default


def _save_instance_json(filename: str, data) -> None:
    path = _get_instance_path(filename)
    tmp = path + '.tmp'
    with open(tmp, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    os.replace(tmp, path)


def _get_admin_recipient_emails() -> list[str]:
    """Collect admin recipients.

    Note: User.role/email are EncryptedType; queries may not be deterministic.
    We scan in Python.
    """
    recipients: list[str] = []
    try:
        for u in User.query.all():
            try:
                role = str(getattr(u, 'role', '') or '').strip().lower()
                if role != 'admin':
                    continue
                email_addr = str(getattr(u, 'email', '') or '').strip()
                if _is_valid_email_address(email_addr):
                    recipients.append(email_addr)
            except Exception:
                continue
    except Exception:
        return []
    # De-dupe while preserving order
    seen = set()
    ordered: list[str] = []
    for r in recipients:
        key = r.lower()
        if key in seen:
            continue
        seen.add(key)
        ordered.append(r)
    return ordered


def _send_email_best_effort_async(*, recipient: str, subject: str, html: str, text_body: str | None = None) -> None:
    """Best-effort email sender for receipts and reports.

    - Never raises
    - Sends on a background thread to avoid delaying HTTP responses.
    - Includes audit logging and production error handling
    """
    if app.config.get('FAST_DEV'):
        app.logger.info("FAST_DEV enabled: best-effort email sending skipped.")
        return
    if not _is_valid_email_address(recipient):
        app.logger.warning(f"Skipping email to invalid address: {recipient}")
        return

    def _worker():
        try:
            with app.app_context():
                # Use production email sender if available
                if _email_sender.is_healthy():
                    result = _email_sender.send(
                        recipient=recipient,
                        subject=subject,
                        html_body=html,
                        text_body=text_body or 'Your email client does not support HTML.',
                    )
                    _email_audit_logger.log_send(result)
                    if result.success:
                        return
                
                # Fallback to system email
                _send_system_email(recipient=recipient, subject=subject, html=html, text_body=text_body)
        except Exception as e:
            try:
                app.logger.error(f"Best-effort email to {recipient} failed: {e}")
            except Exception:
                pass

    try:
        Thread(target=_worker, daemon=True, name=f"best-effort-email-{recipient}").start()
    except Exception as e:
        # If threads cannot start, just drop it.
        try:
            app.logger.warning(f"Could not start email thread: {e}")
        except Exception:
            pass


def _find_user_by_email_plain(email: str) -> User | None:
    target = (email or '').strip().lower()
    if not target:
        return None
    try:
        # EncryptedType may not support deterministic query; fall back to Python scan.
        for candidate in User.query.all():
            try:
                if (str(candidate.email or '').strip().lower()) == target:
                    return candidate
            except Exception:
                continue
    except Exception:
        return None
    return None


def _user_otp_hash(*, user_id: int, code: str) -> str:
    secret = (app.config.get('SECRET_KEY') or '').encode('utf-8')
    payload = f"user-email-otp|{user_id}|{str(code or '').strip()}".encode('utf-8')
    return hashlib.sha256(secret + b'|' + payload).hexdigest()


def _admin_add_user_otp_hash(*, email: str, code: str) -> str:
    secret = (app.config.get('SECRET_KEY') or '').encode('utf-8')
    payload = f"admin-add-user-email-otp|{(email or '').strip().lower()}|{str(code or '').strip()}".encode('utf-8')
    return hashlib.sha256(secret + b'|' + payload).hexdigest()


def _parse_iso_dt(val: str | None) -> datetime | None:
    if not val:
        return None
    try:
        dt = datetime.fromisoformat(str(val))
        if dt.tzinfo is None:
            # Treat stored naive timestamps as EAT.
            dt = dt.replace(tzinfo=EAT)
        return dt
    except Exception:
        return None


def _parse_dt_any(val) -> datetime | None:
    """Best-effort datetime parser.

    Unlike _parse_iso_dt(), this does NOT assume a timezone for naive values.
    """
    if val is None:
        return None
    if isinstance(val, datetime):
        return val
    s = str(val).strip()
    if not s:
        return None
    # Support ISO 'Z'
    if s.endswith('Z'):
        s = s[:-1] + '+00:00'
    try:
        return datetime.fromisoformat(s)
    except Exception:
        return None


def _parse_age_years(value) -> int | None:
    """Parse human age inputs into integer years.

    Accepts inputs like:
    - "2", "2.5" (truncates decimals)
    - "2 weeks", "6 months", "1 year"
    - "1½ years", "1 year 6 months", "18 months"

    Storage stays as whole years (int), so any fractional years are truncated.
    """
    if value is None:
        return None

    try:
        s = str(value).strip().lower()
    except Exception:
        return None

    if not s:
        return None

    # Normalize separators and compact formats like "1y6m".
    s = s.replace(',', ' ').replace(';', ' ').replace('_', ' ')
    s = re.sub(r'(?<=\d)(?=[a-z])', ' ', s)
    s = re.sub(r'(?<=[a-z])(?=\d)', ' ', s)
    s = re.sub(r'\s+', ' ', s).strip()

    fraction_chars = '¼½¾⅓⅔⅛⅜⅝⅞'
    fraction_map = {
        '¼': 0.25,
        '½': 0.5,
        '¾': 0.75,
        '⅛': 0.125,
        '⅜': 0.375,
        '⅝': 0.625,
        '⅞': 0.875,
        '⅓': 1.0 / 3.0,
        '⅔': 2.0 / 3.0,
    }

    def _parse_number_token(tok: str) -> float | None:
        t = (tok or '').strip()
        if not t:
            return None
        try:
            if '/' in t:
                parts = t.split('/', 1)
                if len(parts) == 2:
                    num = float(parts[0]) if parts[0] else 0.0
                    den = float(parts[1])
                    if den == 0:
                        return None
                    return num / den
        except Exception:
            pass

        try:
            last = t[-1]
            if last in fraction_map:
                base = float(t[:-1]) if t[:-1].strip() else 0.0
                return base + float(fraction_map[last])
        except Exception:
            pass

        try:
            return float(t)
        except Exception:
            return None

    # If units are present, parse as a sum of components.
    num_re = rf"(?:\d+(?:\.\d+)?(?:/\d+)?(?:[{fraction_chars}])?|[{fraction_chars}])"
    pattern = re.compile(
        rf"(?P<num>{num_re})\s*(?P<unit>years?|yrs?|yr|y|months?|mos?|mo|m|weeks?|wks?|wk|w)\b"
    )

    total_years = 0.0
    found_unit = False
    for m in pattern.finditer(s):
        found_unit = True
        num = _parse_number_token(m.group('num'))
        if num is None:
            continue

        unit = (m.group('unit') or '').strip().lower()
        if unit.startswith('y'):
            total_years += num
        elif unit.startswith('m'):
            total_years += (num / 12.0)
        elif unit.startswith('w'):
            total_years += (num / 52.0)

    if found_unit:
        try:
            return int(total_years)
        except Exception:
            return None

    # No units: try plain numeric/fraction parsing.
    # Drop common trailing words like "years" accidentally typed without spacing.
    s = re.sub(rf"\b(years?|yrs?|yr|y|months?|mos?|mo|m|weeks?|wks?|wk|w)\b", '', s).strip()
    # If after stripping units it's still a combined token (e.g., "1½"), parse it.
    val = _parse_number_token(s)
    if val is None:
        return None
    try:
        return int(val)
    except Exception:
        return None


def _parse_int(value) -> int | None:
    try:
        s = str(value).strip()
        if not s:
            return None
        try:
            return int(s)
        except Exception:
            return int(float(s))
    except Exception:
        return None


def _utcnow_naive() -> datetime:
    """Get current time in EAT timezone without timezone info (naive)."""
    return datetime.now(EAT).replace(tzinfo=None)


def _as_eat_naive(dt) -> datetime | None:
    """Coerce datetime-like values to EAT-naive for safe comparisons."""
    parsed = _parse_dt_any(dt)
    if parsed is None:
        return None
    try:
        if parsed.tzinfo is None:
            # Treat naive as already EAT.
            return parsed
        return parsed.astimezone(EAT).replace(tzinfo=None)
    except Exception:
        return None


def _as_eat_aware(dt) -> datetime | None:
    """Coerce datetimes to EAT-aware for safe comparison.

    Many DB DateTime columns are stored without tzinfo (naive). When loaded,
    comparing against timezone-aware datetimes raises TypeError.
    """
    if dt is None:
        return None
    # SQLite (and some drivers/configs) may return DateTime columns as strings.
    if isinstance(dt, str):
        return _parse_iso_dt(dt)
    try:
        if not isinstance(dt, datetime):
            parsed = _parse_iso_dt(str(dt))
            return parsed
        if dt.tzinfo is None:
            return dt.replace(tzinfo=EAT)
        return dt.astimezone(EAT)
    except Exception:
        return None


def _generate_user_otp_code() -> str:
    return f"{secrets.randbelow(1_000_000):06d}"


def _send_user_verification_otp(user: User) -> None:
    """Send email verification OTP with production-ready error handling.
    
    - Generates 6-digit OTP with 10-minute expiration
    - Validates user email before sending
    - Logs all attempts for audit trail
    - Provides clear error messages
    """
    from utils.email_templates import OTPEmailTemplate
    
    try:
        # Validate user and email
        if not user or not user.id:
            app.logger.error("Cannot send OTP: Invalid user object")
            raise ValueError("Invalid user")
        
        user_email = str(user.email or '').strip()
        if not _is_valid_email_address(user_email):
            app.logger.error(f"Cannot send OTP: Invalid user email format: {user_email}")
            raise ValueError("Invalid email address")
        
        # Generate OTP code
        code = _generate_user_otp_code()
        user.is_email_verified = False
        user.email_otp_hash = _user_otp_hash(user_id=int(user.id), code=code)
        # Store as EAT-naive to avoid timezone conversion issues across DB backends.
        user.email_otp_expires_at = _utcnow_naive() + timedelta(minutes=10)
        db.session.commit()
        
        app.logger.info(f"Generated OTP for user {user.id}: {user_email}", extra={'user_id': user.id})

        # Use template for consistent formatting
        html, text_body = OTPEmailTemplate.verification_otp(code, minutes_valid=10)
        
        _send_system_email(
            recipient=user_email,
            subject='Verify Your Email Address (OTP)',
            html=html,
            text_body=text_body,
        )
        
        app.logger.info(f"OTP email sent successfully to {user_email}")
        
    except Exception as e:
        app.logger.exception(f"Failed to send OTP to user {user.id if user else 'unknown'}: {e}")
        raise

def _generate_password_reset_token(user: User) -> str:
    # Rotate per-user nonce to invalidate previous tokens.
    user.password_reset_nonce = secrets.token_hex(16)
    user.password_reset_sent_at = get_eat_now()
    db.session.commit()
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    return serializer.dumps(
        {'uid': int(user.id), 'nonce': str(user.password_reset_nonce)},
        salt=current_app.config['SECURITY_PASSWORD_SALT']
    )


def _verify_password_reset_token(token: str) -> User | None:
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        data = serializer.loads(
            token,
            salt=current_app.config['SECURITY_PASSWORD_SALT'],
            max_age=int(current_app.config.get('RESET_TOKEN_EXPIRATION', 3600))
        )
        uid = int(data.get('uid'))
        nonce = str(data.get('nonce') or '')
    except Exception:
        return None

    user = db.session.get(User, uid)
    if not user:
        return None
    if not user.password_reset_nonce or str(user.password_reset_nonce) != nonce:
        return None
    return user


def send_password_reset_email(user_email: str, reset_url: str) -> None:
    """Send password reset email with production-ready error handling.
    
    - Validates email format before sending
    - Includes clear instructions and security warnings
    - Logs all attempts for audit trail
    - Uses production email sender with retries
    """
    from utils.email_templates import PasswordResetEmailTemplate
    
    try:
        # Validate email
        user_email = str(user_email or '').strip()
        if not _is_valid_email_address(user_email):
            app.logger.error(f"Cannot send reset email: Invalid email format: {user_email}")
            raise ValueError(f"Invalid email address: {user_email}")
        
        # Validate reset URL
        reset_url = str(reset_url or '').strip()
        if not reset_url.startswith(('http://', 'https://')):
            app.logger.error(f"Invalid reset URL format: {reset_url}")
            raise ValueError("Invalid reset URL")
        
        # Use template
        html, text_body = PasswordResetEmailTemplate.reset_request(reset_url, hours_valid=1)
        
        _send_system_email(
            recipient=user_email,
            subject='Reset Your Password',
            html=html,
            text_body=text_body,
        )
        
        app.logger.info(f"Password reset email sent to {user_email}")
        
    except Exception as e:
        app.logger.exception(f"Failed to send password reset email to {user_email}: {e}")
        raise


@auth_bp.route('/reset-password', methods=['GET', 'POST'])
@limiter.limit("5 per minute")
def reset_password():
    form = ResetPasswordRequestForm()
    if form.validate_on_submit():
        email = (form.email.data or '').strip()
        user = _find_user_by_email_plain(email)

        # Avoid email enumeration: always show generic success message.
        if user:
            token = _generate_password_reset_token(user)
            reset_url = url_for('auth.reset_with_token', token=token, _external=True)
            try:
                send_password_reset_email(str(user.email), reset_url)
            except Exception as e:
                current_app.logger.error(f'Password reset email send failed: {e}', exc_info=True)
                flash('Failed to send reset email. Check email configuration and try again.', 'danger')
                return redirect(url_for('auth.reset_password'))

        flash('If this email exists in our system, a reset link has been sent.', 'info')
        return redirect(url_for('auth.login'))

    return render_template('auth/reset.html', form=form)


@auth_bp.route('/reset/<token>', methods=['GET', 'POST'])
@limiter.limit("5 per minute")
def reset_with_token(token):
    user = _verify_password_reset_token(token)
    if not user:
        flash('The reset link is invalid or has expired.', 'danger')
        return redirect(url_for('auth.reset_password'))

    form = ResetPasswordForm()
    if form.validate_on_submit():
        user.set_password(form.password.data)
        # Invalidate token after use.
        user.password_reset_nonce = None
        user.password_reset_sent_at = None
        db.session.commit()
        flash('Your password has been updated successfully!', 'success')
        return redirect(url_for('auth.login'))

    return render_template('auth/reset_with_token.html', form=form, token=token)


@auth_bp.route('/verify-email', methods=['GET', 'POST'])
@limiter.limit("10 per minute")
def verify_email():
    # Optional redirect target so OTP verification can be completed from the login page.
    next_target = (request.values.get('next') or '').strip().lower()
    def _redirect_back(email_val: str):
        if next_target == 'login':
            return redirect(url_for('auth.login', verify_email=(email_val or '').strip()))
        return redirect(url_for('auth.verify_email'))

    if request.method == 'POST':
        email = (request.form.get('email') or '').strip()
        code = (request.form.get('code') or '').strip()
        user = _find_user_by_email_plain(email)
        if not user:
            flash('Invalid email or OTP.', 'danger')
            return _redirect_back(email)

        if user.is_email_verified:
            flash('Email already verified. You can login.', 'info')
            return redirect(url_for('auth.login'))

        now = _utcnow_naive()
        expires_at = _as_eat_naive(user.email_otp_expires_at)
        if not user.email_otp_hash or not expires_at or expires_at < now:
            flash('OTP expired. Please request a new code.', 'danger')
            return _redirect_back(email)

        if _user_otp_hash(user_id=int(user.id), code=code) != (user.email_otp_hash or ''):
            flash('Invalid OTP code. Please try again.', 'danger')
            return _redirect_back(email)

        user.is_email_verified = True
        user.email_otp_hash = None
        user.email_otp_expires_at = None
        db.session.commit()
        flash('Email verified successfully. Please login.', 'success')
        return redirect(url_for('auth.login'))

    # GET
    return render_template('auth/verify_email.html')


@auth_bp.route('/verify-email/resend', methods=['POST'])
@limiter.limit("5 per minute")
def resend_verify_email():
    next_target = (request.values.get('next') or '').strip().lower()
    def _redirect_back(email_val: str):
        if next_target == 'login':
            return redirect(url_for('auth.login', verify_email=(email_val or '').strip()))
        return redirect(url_for('auth.verify_email'))

    email = (request.form.get('email') or '').strip()
    user = _find_user_by_email_plain(email)
    if not user:
        flash('If this email exists in our system, a new OTP has been sent.', 'info')
        return _redirect_back(email)
    if user.is_email_verified:
        flash('Email already verified. You can login.', 'info')
        return redirect(url_for('auth.login'))
    try:
        _send_user_verification_otp(user)
    except Exception as e:
        current_app.logger.error(f'User OTP send failed: {e}', exc_info=True)
        flash('Failed to send OTP email. Check email configuration and try again.', 'danger')
        return _redirect_back(email)
    flash('A new OTP has been sent to your email.', 'success')
    return _redirect_back(email)



@app.route('/admin')
@login_required
def admin_dashboard():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        total_drugs = db.session.query(func.count(Drug.id)).scalar()
        low_stock = db.session.query(func.count(Drug.id)).filter(
            Drug.stocked_quantity - Drug.sold_quantity < 10
        ).scalar()
        
        expiring_soon = db.session.query(func.count(Drug.id)).filter(
            Drug.expiry_date <= date.today() + timedelta(days=30)
        ).scalar()
        
        # Today's sales
        today_sales = db.session.query(func.sum(Sale.total_amount)).filter(
            func.date(Sale.created_at) == date.today()
        ).scalar() or 0
        
        # UNIVERSAL FIX: Use extract for month and year - works on all databases
        current_date = datetime.now()
        monthly_sales = db.session.query(func.sum(Sale.total_amount)).filter(
            func.extract('year', Sale.created_at) == current_date.year,
            func.extract('month', Sale.created_at) == current_date.month
        ).scalar() or 0
        
        pending_bills = db.session.query(func.sum(Debtor.amount_owed)).scalar() or 0
        
        last_backup = BackupRecord.query.filter_by(status='completed')\
            .order_by(BackupRecord.timestamp.desc()).first()
        last_backup_time = last_backup.timestamp if last_backup else 'Never'
        
        backup_stats = {
            'total_backups': BackupRecord.query.count(),
            'successful_backups': BackupRecord.query.filter_by(status='completed').count(),
            'failed_backups': BackupRecord.query.filter_by(status='failed').count(),
            'total_size_mb': db.session.query(
                func.coalesce(func.sum(BackupRecord.size_bytes), 0) / (1024 * 1024)
            ).scalar()
        }
        
        active_users = db.session.query(func.count(User.id)).filter_by(is_active=True).scalar()
        
        # Get doctor statistics - ensure these are called
        daily_stats = get_doctor_stats('daily')
        monthly_stats = get_doctor_stats('monthly')
        yearly_stats = get_doctor_stats('yearly')
        
        # Get recent activity
        recent_activity = db.session.query(
            AuditLog.id,
            AuditLog.action,
            AuditLog.created_at.label('created_at'),
            literal('audit').label('type')
        ).union_all(
            db.session.query(
                BackupRecord.id,
                literal('backup').label('action'),
                BackupRecord.timestamp.label('created_at'),
                literal('backup').label('type')
            )
        ).order_by(text('created_at DESC')).limit(10).all()
        
        return render_template('admin/dashboard.html',
            total_drugs=total_drugs,
            low_stock=low_stock,
            expiring_soon=expiring_soon,
            today_sales=today_sales,
            monthly_sales=monthly_sales,
            pending_bills=pending_bills,
            last_backup_time=last_backup_time,
            backup_stats=backup_stats,
            active_users=active_users,
            daily_stats=daily_stats,
            monthly_stats=monthly_stats,
            yearly_stats=yearly_stats,
            recent_activity=recent_activity
        )
    
    except Exception as e:
        app.logger.error(f"Error in admin dashboard: {str(e)}")
        flash('An error occurred while loading the dashboard', 'danger')
        return redirect(url_for('home'))

def get_total_beds():
    return Bed.query.count()

def get_available_beds():
    return Bed.query.filter_by(status='available').count()

def get_occupied_beds():
    return Bed.query.filter_by(status='occupied').count()

def get_doctor_stats(timeframe='daily'):
    """Get statistics for doctors based on timeframe (daily, monthly, yearly)"""
    today = date.today()
    
    if timeframe == 'daily':
        start_date = today
        end_date = today + timedelta(days=1)
    elif timeframe == 'monthly':
        start_date = date(today.year, today.month, 1)
        end_date = date(today.year, today.month + 1, 1) if today.month < 12 else date(today.year + 1, 1, 1)
    elif timeframe == 'yearly':
        start_date = date(today.year, 1, 1)
        end_date = date(today.year + 1, 1, 1)
    else:
        start_date = today
        end_date = today + timedelta(days=1)

    # Get inpatient and outpatient counts - using date comparisons compatible with PostgreSQL
    inpatients = db.session.query(Patient).filter(
        Patient.ip_number.isnot(None),
        Patient.date_of_admission >= start_date,
        Patient.date_of_admission < end_date
    ).count()

    outpatients = db.session.query(Patient).filter(
        Patient.op_number.isnot(None),
        Patient.date_of_admission >= start_date,
        Patient.date_of_admission < end_date
    ).count()

    # Get discharged patients - using date comparisons
    discharged = db.session.query(Patient).filter(
        Patient.status == 'completed',
        Patient.updated_at >= start_date,
        Patient.updated_at < end_date
    ).count()

    # Get bed statistics with zero division protection
    total_beds = get_total_beds()
    occupied_beds = get_occupied_beds()
    available_beds = get_available_beds()
    
    # Calculate occupancy rate with zero division protection
    occupancy_rate = 0
    if total_beds > 0:
        occupancy_rate = (occupied_beds / total_beds) * 100

    return {
        'inpatients': inpatients,
        'outpatients': outpatients,
        'discharged': discharged,
        'occupied_beds': occupied_beds,
        'available_beds': available_beds,
        'total_beds': total_beds,
        'occupancy_rate': occupancy_rate,
        'timeframe': timeframe,
        'start_date': start_date,
        'end_date': end_date - timedelta(days=1)  # Subtract 1 day to show inclusive end data
    }


# =================================================================================================
# FINANCIAL DASHBOARD AGGREGATION FUNCTIONS
# =================================================================================================

def get_financial_metrics(start_date: date, end_date: date, period_type: str = 'daily'):
    """Calculate comprehensive financial metrics for a date range"""
    try:
        metrics = {
            'period_type': period_type,
            'start_date': start_date,
            'end_date': end_date,
            'date_range': f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}"
        }
        
        # REVENUE CALCULATIONS
        metrics.update(_calculate_revenue_metrics(start_date, end_date))
        
        # EXPENSE CALCULATIONS
        metrics.update(_calculate_expense_metrics(start_date, end_date))
        
        # REFUNDS AND ADJUSTMENTS
        metrics['refunds'] = float(db.session.query(func.sum(Refund.total_amount)).filter(
            Refund.created_at >= datetime.combine(start_date, datetime.min.time()),
            Refund.created_at < datetime.combine(end_date, datetime.max.time())
        ).scalar() or 0)
        
        # NET CALCULATIONS
        total_revenue = metrics.get('total_revenue', 0)
        total_expense = metrics.get('total_expense', 0)
        refunds = metrics.get('refunds', 0)
        
        metrics['gross_profit'] = total_revenue - refunds
        metrics['net_profit'] = metrics['gross_profit'] - total_expense
        metrics['profit_margin'] = (metrics['net_profit'] / total_revenue * 100) if total_revenue > 0 else 0
        
        # CASH FLOW
        metrics.update(_calculate_cashflow_metrics(start_date, end_date))
        
        # OUTSTANDING AND OVERDUE
        metrics.update(_calculate_outstanding_metrics(start_date, end_date))
        
        # PATIENT METRICS
        metrics.update(_calculate_patient_metrics(start_date, end_date))
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating financial metrics: {str(e)}")
        return {}


def _calculate_revenue_metrics(start_date: date, end_date: date) -> dict:
    """Calculate revenue by category"""
    try:
        metrics = {}
        
        # Pharmacy revenue
        pharmacy_revenue = db.session.query(func.sum(SaleItem.total_price)).join(Sale).filter(
            SaleItem.drug_id.isnot(None),
            Sale.created_at >= datetime.combine(start_date, datetime.min.time()),
            Sale.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Sale.status == 'completed'
        ).scalar() or 0
        metrics['pharmacy_revenue'] = float(pharmacy_revenue)
        
        # Lab revenue
        lab_revenue = db.session.query(func.sum(SaleItem.total_price)).join(Sale).filter(
            SaleItem.lab_test_id.isnot(None),
            Sale.created_at >= datetime.combine(start_date, datetime.min.time()),
            Sale.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Sale.status == 'completed'
        ).scalar() or 0
        metrics['lab_revenue'] = float(lab_revenue)
        
        # Imaging revenue
        imaging_revenue = db.session.query(func.sum(SaleItem.total_price)).join(Sale).filter(
            SaleItem.imaging_test_id.isnot(None),
            Sale.created_at >= datetime.combine(start_date, datetime.min.time()),
            Sale.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Sale.status == 'completed'
        ).scalar() or 0
        metrics['imaging_revenue'] = float(imaging_revenue)
        
        # Service/Consultation revenue
        consultation_revenue = db.session.query(func.sum(SaleItem.total_price)).join(Sale).filter(
            SaleItem.service_id.isnot(None),
            Sale.created_at >= datetime.combine(start_date, datetime.min.time()),
            Sale.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Sale.status == 'completed'
        ).scalar() or 0
        metrics['consultation_revenue'] = float(consultation_revenue)
        
        # Insurance claims paid
        insurance_revenue = db.session.query(func.sum(InsuranceClaim.paid_amount)).filter(
            InsuranceClaim.created_at >= datetime.combine(start_date, datetime.min.time()),
            InsuranceClaim.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            InsuranceClaim.status == 'paid'
        ).scalar() or 0
        metrics['insurance_revenue'] = float(insurance_revenue)
        
        # Other/Misc revenue from transactions marked as revenue
        other_revenue = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'IN',
            Transaction.transaction_type.notin_(['sale', 'lab', 'imaging', 'insurance']),
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['other_revenue'] = float(other_revenue)
        
        metrics['total_revenue'] = (
            metrics['pharmacy_revenue'] + 
            metrics['lab_revenue'] + 
            metrics['imaging_revenue'] + 
            metrics['consultation_revenue'] + 
            metrics.get('insurance_revenue', 0) + 
            metrics['other_revenue']
        )
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating revenue metrics: {str(e)}")
        return {
            'pharmacy_revenue': 0, 'lab_revenue': 0, 'imaging_revenue': 0,
            'consultation_revenue': 0, 'insurance_revenue': 0, 'other_revenue': 0,
            'total_revenue': 0
        }


def _calculate_expense_metrics(start_date: date, end_date: date) -> dict:
    """Calculate expenses by category"""
    try:
        metrics = {}
        
        # Payroll expenses
        payroll_expense = db.session.query(func.sum(Payroll.amount)).filter(
            Payroll.created_at >= datetime.combine(start_date, datetime.min.time()),
            Payroll.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Payroll.status == 'pending'
        ).scalar() or 0
        metrics['payroll_expense'] = float(payroll_expense)
        
        # Drug procurement/inventory costs
        pharmacy_expense = db.session.query(func.sum(Purchase.amount)).filter(
            Purchase.purchase_type.ilike('%drug%'),
            Purchase.purchase_date >= start_date,
            Purchase.purchase_date <= end_date
        ).scalar() or 0
        metrics['pharmacy_expense'] = float(pharmacy_expense)
        
        # Equipment and maintenance
        equipment_expense = db.session.query(func.sum(Expense.amount)).filter(
            Expense.expense_type.ilike('%equipment%'),
            Expense.created_at >= datetime.combine(start_date, datetime.min.time()),
            Expense.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Expense.status == 'paid'
        ).scalar() or 0
        metrics['equipment_expense'] = float(equipment_expense)
        
        # Utilities
        utilities_expense = db.session.query(func.sum(Expense.amount)).filter(
            Expense.expense_type.ilike('%utilit%'),
            Expense.created_at >= datetime.combine(start_date, datetime.min.time()),
            Expense.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Expense.status == 'paid'
        ).scalar() or 0
        metrics['utilities_expense'] = float(utilities_expense)
        
        # Debt payments
        debt_payment = db.session.query(func.sum(DebtorPayment.amount)).filter(
            DebtorPayment.created_at >= datetime.combine(start_date, datetime.min.time()),
            DebtorPayment.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time())
        ).scalar() or 0
        metrics['debt_payment'] = float(debt_payment)
        
        # Other expenses
        other_expense = db.session.query(func.sum(Expense.amount)).filter(
            Expense.expense_type.notin_(['equipment', 'utility', 'payroll']),
            Expense.created_at >= datetime.combine(start_date, datetime.min.time()),
            Expense.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Expense.status == 'paid'
        ).scalar() or 0
        metrics['other_expense'] = float(other_expense)
        
        metrics['total_expense'] = (
            metrics['payroll_expense'] + 
            metrics['pharmacy_expense'] + 
            metrics['equipment_expense'] + 
            metrics['utilities_expense'] + 
            metrics['debt_payment'] + 
            metrics['other_expense']
        )
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating expense metrics: {str(e)}")
        return {
            'payroll_expense': 0, 'pharmacy_expense': 0, 'equipment_expense': 0,
            'utilities_expense': 0, 'debt_payment': 0, 'other_expense': 0,
            'total_expense': 0
        }


def _calculate_cashflow_metrics(start_date: date, end_date: date) -> dict:
    """Calculate cash flow by payment method"""
    try:
        metrics = {}
        
        # Cash receipts
        cash_in = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'IN',
            Transaction.payment_method == 'cash',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['cash_in'] = float(cash_in)
        
        # MPESA receipts
        mpesa_in = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'IN',
            Transaction.payment_method == 'mpesa',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['mpesa_in'] = float(mpesa_in)
        
        # Card receipts
        card_in = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'IN',
            Transaction.payment_method == 'card',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['card_in'] = float(card_in)
        
        # Bank transfers
        bank_in = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'IN',
            Transaction.payment_method == 'bank',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['bank_in'] = float(bank_in)
        
        metrics['total_cash_in'] = metrics['cash_in'] + metrics['mpesa_in'] + metrics['card_in'] + metrics['bank_in']
        
        # Similar for OUT
        cash_out = db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'OUT',
            Transaction.payment_method == 'cash',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0
        metrics['cash_out'] = float(cash_out)
        
        metrics['mpesa_out'] = float(db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'OUT',
            Transaction.payment_method == 'mpesa',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0)
        
        metrics['card_out'] = float(db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'OUT',
            Transaction.payment_method == 'card',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0)
        
        metrics['bank_out'] = float(db.session.query(func.sum(Transaction.amount)).filter(
            Transaction.direction == 'OUT',
            Transaction.payment_method == 'bank',
            Transaction.created_at >= datetime.combine(start_date, datetime.min.time()),
            Transaction.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Transaction.status == 'posted'
        ).scalar() or 0)
        
        metrics['total_cash_out'] = metrics['cash_out'] + metrics['mpesa_out'] + metrics['card_out'] + metrics['bank_out']
        
        # Create cashflow breakdown object for template
        metrics['cashflow_breakdown'] = {
            'cash': {
                'inflow': metrics['cash_in'],
                'outflow': metrics['cash_out'],
                'net': metrics['cash_in'] - metrics['cash_out']
            },
            'mpesa': {
                'inflow': metrics['mpesa_in'],
                'outflow': metrics['mpesa_out'],
                'net': metrics['mpesa_in'] - metrics['mpesa_out']
            },
            'card': {
                'inflow': metrics['card_in'],
                'outflow': metrics['card_out'],
                'net': metrics['card_in'] - metrics['card_out']
            },
            'bank': {
                'inflow': metrics['bank_in'],
                'outflow': metrics['bank_out'],
                'net': metrics['bank_in'] - metrics['bank_out']
            }
        }
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating cashflow metrics: {str(e)}")
        return {
            'cash_in': 0, 'mpesa_in': 0, 'card_in': 0, 'bank_in': 0, 'total_cash_in': 0,
            'cash_out': 0, 'mpesa_out': 0, 'card_out': 0, 'bank_out': 0, 'total_cash_out': 0
        }


def _calculate_outstanding_metrics(start_date: date, end_date: date) -> dict:
    """Calculate outstanding invoices and overdue amounts"""
    try:
        metrics = {}
        
        # Outstanding invoices (unpaid)
        outstanding = db.session.query(func.sum(Invoice.total_amount)).filter(
            Invoice.status == 'unpaid',
            Invoice.date_issued >= datetime.combine(start_date, datetime.min.time()),
            Invoice.date_issued < datetime.combine(end_date + timedelta(days=1), datetime.min.time())
        ).scalar() or 0
        metrics['outstanding_invoices'] = float(outstanding)
        
        # Overdue amount
        overdue = db.session.query(func.sum(Invoice.total_amount - Invoice.paid_amount)).filter(
            Invoice.status == 'overdue',
            Invoice.date_issued >= datetime.combine(start_date, datetime.min.time()),
            Invoice.date_issued < datetime.combine(end_date + timedelta(days=1), datetime.min.time())
        ).scalar() or 0
        metrics['overdue_amount'] = float(overdue)
        
        # Overdue debtor amount
        overdue_debtors = db.session.query(func.sum(Debtor.amount_owed)).filter(
            Debtor.next_payment_date < start_date
        ).scalar() or 0
        metrics['overdue_debtors'] = float(overdue_debtors)
        
        # Outstanding debtor balances
        outstanding_debtor = db.session.query(func.sum(Debtor.amount_owed)).filter(
            Debtor.amount_owed > 0
        ).scalar() or 0
        metrics['outstanding_debtor'] = float(outstanding_debtor)
        
        # Count of debtors with outstanding balance
        outstanding_debtor_count = db.session.query(func.count(Debtor.id)).filter(
            Debtor.amount_owed > 0
        ).scalar() or 0
        metrics['outstanding_debtor_count'] = int(outstanding_debtor_count)
        
        # Outstanding insurance claims
        outstanding_insurance = db.session.query(func.sum(InsuranceClaim.claimed_amount)).filter(
            InsuranceClaim.status == 'pending'
        ).scalar() or 0
        metrics['outstanding_insurance'] = float(outstanding_insurance)
        
        # Count of outstanding insurance claims
        outstanding_insurance_count = db.session.query(func.count(InsuranceClaim.id)).filter(
            InsuranceClaim.status == 'pending'
        ).scalar() or 0
        metrics['outstanding_insurance_count'] = int(outstanding_insurance_count)
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating outstanding metrics: {str(e)}")
        return {
            'outstanding_invoices': 0, 'overdue_amount': 0, 'overdue_debtors': 0,
            'outstanding_debtor': 0, 'outstanding_debtor_count': 0,
            'outstanding_insurance': 0, 'outstanding_insurance_count': 0
        }


def _calculate_patient_metrics(start_date: date, end_date: date) -> dict:
    """Calculate patient-related metrics"""
    try:
        metrics = {}
        
        # Total patients served (those with transactions in this period)
        patients_served = db.session.query(func.count(func.distinct(Sale.patient_id))).filter(
            Sale.created_at >= datetime.combine(start_date, datetime.min.time()),
            Sale.created_at < datetime.combine(end_date + timedelta(days=1), datetime.min.time()),
            Sale.status == 'completed'
        ).scalar() or 0
        metrics['total_patients_served'] = int(patients_served)
        
        # New patients (registration date in period)
        new_patients = db.session.query(func.count(Patient.id)).filter(
            Patient.date_of_admission >= start_date,
            Patient.date_of_admission <= end_date
        ).scalar() or 0
        metrics['new_patients'] = int(new_patients)
        
        # Returning patients
        all_patients = db.session.query(func.count(Patient.id)).filter(
            Patient.date_of_admission <= end_date
        ).scalar() or 0
        metrics['returning_patients'] = max(0, int(all_patients) - int(new_patients))
        
        return metrics
    except Exception as e:
        app.logger.error(f"Error calculating patient metrics: {str(e)}")
        return {
            'total_patients_served': 0, 'new_patients': 0, 'returning_patients': 0
        }


def get_daily_financial_summary(target_date: date = None) -> dict:
    """Get complete daily financial summary"""
    if target_date is None:
        target_date = date.today()
    
    return get_financial_metrics(target_date, target_date, 'daily')


def get_weekly_financial_summary(target_date: date = None) -> dict:
    """Get complete weekly financial summary"""
    if target_date is None:
        target_date = date.today()
    
    # Get start of week (Monday)
    start = target_date - timedelta(days=target_date.weekday())
    end = start + timedelta(days=6)
    
    return get_financial_metrics(start, end, 'weekly')


def get_monthly_financial_summary(year: int = None, month: int = None) -> dict:
    """Get complete monthly financial summary"""
    today = date.today()
    if year is None:
        year = today.year
    if month is None:
        month = today.month
    
    # First day of month
    start = date(year, month, 1)
    # Last day of month
    if month == 12:
        end = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        end = date(year, month + 1, 1) - timedelta(days=1)
    
    return get_financial_metrics(start, end, 'monthly')


def get_yearly_financial_summary(year: int = None) -> dict:
    """Get complete yearly financial summary"""
    if year is None:
        year = date.today().year
    
    start = date(year, 1, 1)
    end = date(year, 12, 31)
    
    return get_financial_metrics(start, end, 'yearly')


# Backup utility functions (implementation is below under BACKUP IMPLEMENTATION)

@app.route('/admin/beds', methods=['GET', 'POST'])
@login_required
def manage_beds():
    # Simple admin check
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Rest of your function code remains the same
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add_ward':
            try:
                ward = Ward(
                    name=request.form.get('ward_name'),
                    description=request.form.get('ward_description')
                )
                try:
                    rate_raw = request.form.get('ward_daily_rate')
                    if rate_raw is not None and str(rate_raw).strip() != '':
                        ward.daily_rate = float(rate_raw)
                except Exception:
                    pass
                db.session.add(ward)
                db.session.commit()
                flash('Ward added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding ward: {str(e)}', 'danger')

        elif action == 'edit_ward':
            try:
                ward_id = request.form.get('ward_id')
                ward = _db_get(Ward, ward_id)
                if not ward:
                    flash('Ward not found', 'danger')
                else:
                    ward.name = request.form.get('ward_name')
                    ward.description = request.form.get('ward_description')
                    try:
                        rate_raw = request.form.get('ward_daily_rate')
                        if rate_raw is not None and str(rate_raw).strip() != '':
                            ward.daily_rate = float(rate_raw)
                    except Exception:
                        pass
                    db.session.commit()
                    flash('Ward updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating ward: {str(e)}', 'danger')
        
        elif action == 'add_bed':
            try:
                bed = Bed(
                    bed_number=request.form.get('bed_number'),
                    ward_id=request.form.get('ward_id'),
                    status='available'
                )
                db.session.add(bed)
                db.session.commit()
                flash('Bed added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding bed: {str(e)}', 'danger')
        
        elif action == 'assign_bed':
            try:
                bed_id = request.form.get('bed_id')
                patient_id = request.form.get('patient_id')
                
                bed = _db_get(Bed, bed_id)
                if bed.status == 'occupied':
                    flash('Bed is already occupied', 'danger')
                else:
                    bed.status = 'occupied'
                    bed.patient_id = patient_id
                    try:
                        now = get_eat_now()
                        bed.assigned_at = now
                        bed.released_at = None
                    except Exception:
                        now = get_eat_now()
                        pass

                    try:
                        db.session.add(BedAssignment(
                            bed_id=int(bed.id),
                            patient_id=int(patient_id),
                            assigned_at=now,
                            released_at=None,
                        ))
                    except Exception:
                        pass
                    db.session.commit()
                    flash('Bed assigned successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error assigning bed: {str(e)}', 'danger')
        
        elif action == 'release_bed':
            try:
                bed_id = request.form.get('bed_id')
                bed = _db_get(Bed, bed_id)
                bed.status = 'available'
                try:
                    now = get_eat_now()
                    bed.released_at = now
                except Exception:
                    now = get_eat_now()
                    pass

                # Capture the patient before clearing the bed assignment
                released_patient_id = bed.patient_id
                bed.patient_id = None

                try:
                    if released_patient_id:
                        last_assign = (
                            BedAssignment.query
                            .filter_by(bed_id=bed.id, patient_id=released_patient_id)
                            .filter(BedAssignment.released_at.is_(None))
                            .order_by(BedAssignment.assigned_at.desc())
                            .first()
                        )
                        if last_assign:
                            last_assign.released_at = now
                            db.session.add(last_assign)
                except Exception:
                    pass
                db.session.commit()
                flash('Bed released successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error releasing bed: {str(e)}', 'danger')

        elif action == 'delete_ward':
            try:
                ward_id = request.form.get('ward_id')
                ward = _db_get(Ward, ward_id)
                if not ward:
                    flash('Ward not found', 'danger')
                else:
                    # Delete beds first (relationship may not be configured with cascade)
                    Bed.query.filter_by(ward_id=ward.id).delete(synchronize_session=False)
                    db.session.delete(ward)
                    db.session.commit()
                    flash('Ward deleted successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error deleting ward: {str(e)}', 'danger')

        elif action == 'delete_bed':
            try:
                bed_id = request.form.get('bed_id')
                bed = _db_get(Bed, bed_id)
                if not bed:
                    flash('Bed not found', 'danger')
                else:
                    db.session.delete(bed)
                    db.session.commit()
                    flash('Bed deleted successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error deleting bed: {str(e)}', 'danger')
        
        return redirect(url_for('manage_beds'))
    
    wards = Ward.query.all()
    beds = Bed.query.order_by(Bed.ward_id, Bed.bed_number).all()
    patients = Patient.query.filter_by(status='active').all()
    
    return render_template('admin/beds.html',
        wards=wards,
        beds=beds,
        patients=patients,
        total_beds=get_total_beds(),
        occupied_beds=get_occupied_beds(),
        available_beds=get_available_beds()
    )

@app.route('/admin/drugs', methods=['GET', 'POST'])
@login_required
def manage_drugs():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            try:
                drug = Drug(
                    drug_number=generate_drug_number(),
                    name=request.form.get('name'),
                    specification=request.form.get('specification'),
                    buying_price=float(request.form.get('buying_price')),
                    selling_price=float(request.form.get('selling_price')),
                    stocked_quantity=int(request.form.get('stocked_quantity')),
                    expiry_date=datetime.strptime(request.form.get('expiry_date'), '%Y-%m-%d').date()
                )
                db.session.add(drug)
                db.session.commit()
                
                log_audit('create', 'Drug', drug.id, None, {
                    'drug_number': drug.drug_number,
                    'name': drug.name,
                    'specification': drug.specification,
                    'buying_price': drug.buying_price,
                    'selling_price': drug.selling_price,
                    'stocked_quantity': drug.stocked_quantity,
                    'expiry_date': drug.expiry_date
                })
                
                flash('Drug added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding drug: {str(e)}', 'danger')
        
        elif action == 'edit':
            drug_id = request.form.get('drug_id')
            drug = db.session.get(Drug, drug_id)  # Updated to use session.get()
            if drug:
                try:
                    old_values = {
                        'drug_number': drug.drug_number,
                        'name': drug.name,
                        'specification': drug.specification,
                        'buying_price': drug.buying_price,
                        'selling_price': drug.selling_price,
                        'stocked_quantity': drug.stocked_quantity,
                        'expiry_date': drug.expiry_date
                    }
                    
                    drug.name = request.form.get('name')
                    drug.specification = request.form.get('specification')
                    drug.buying_price = float(request.form.get('buying_price'))
                    drug.selling_price = float(request.form.get('selling_price'))
                    drug.stocked_quantity = int(request.form.get('stocked_quantity'))
                    drug.expiry_date = datetime.strptime(request.form.get('expiry_date'), '%Y-%m-%d').date()
                    
                    db.session.commit()
                    
                    log_audit('update', 'Drug', drug.id, old_values, {
                        'drug_number': drug.drug_number,
                        'name': drug.name,
                        'specification': drug.specification,
                        'buying_price': drug.buying_price,
                        'selling_price': drug.selling_price,
                        'stocked_quantity': drug.stocked_quantity,
                        'expiry_date': drug.expiry_date
                    })
                    
                    flash('Drug updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating drug: {str(e)}', 'danger')
            else:
                flash('Drug not found', 'danger')
        
        elif action == 'delete':
            drug_id = request.form.get('drug_id')
            drug = db.session.get(Drug, drug_id)  # Updated to use session.get()
            if drug:
                try:
                    log_audit('delete', 'Drug', drug.id, {
                        'drug_number': drug.drug_number,
                        'name': drug.name,
                        'specification': drug.specification,
                        'buying_price': drug.buying_price,
                        'selling_price': drug.selling_price,
                        'stocked_quantity': drug.stocked_quantity,
                        'expiry_date': drug.expiry_date
                    }, None)
                    
                    db.session.delete(drug)
                    db.session.commit()
                    flash('Drug deleted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error deleting drug: {str(e)}', 'danger')
            else:
                flash('Drug not found', 'danger')
        
        return redirect(url_for('manage_drugs'))
    
    # Handle filter requests
    filter_type = request.args.get('filter', 'all')
    
    # Base query
    query = db.select(Drug)
    
    if filter_type == 'low_stock':
        # Drugs with less than 10 remaining
        query = query.where(Drug.remaining_quantity < 10)
    elif filter_type == 'expiring_soon':
        # Drugs expiring in the next 30 days or already expired
        today = datetime.now().date()
        thirty_days_later = today + timedelta(days=30)
        query = query.where(Drug.expiry_date <= thirty_days_later).order_by(Drug.expiry_date)
    elif filter_type == 'out_of_stock':
        # Drugs with zero or negative remaining quantity
        query = query.where(Drug.remaining_quantity <= 0)
    elif filter_type == 'expired':
        # Only expired drugs
        today = datetime.now().date()
        query = query.where(Drug.expiry_date < today)
    
    # Execute the query
    drugs = db.session.execute(query).scalars().all()
    
    total_value = sum(drug.selling_price * drug.remaining_quantity for drug in drugs)
    return render_template('admin/drugs.html', 
                         drugs=drugs, 
                         total_value=total_value, 
                         current_filter=filter_type,
                         today=datetime.now().date())

@app.route('/admin/drugs/<int:drug_id>')
def get_drug(drug_id):

    drug = db.session.get(Drug, drug_id)  # Updated to use session.get()
    if not drug:
        return jsonify({'error': 'Drug not found'}), 404
    
    return jsonify({
        'id': drug.id,
        'drug_number': drug.drug_number,
        'name': drug.name,
        'specification': drug.specification,
        'buying_price': drug.buying_price,
        'selling_price': drug.selling_price,
        'stocked_quantity': drug.stocked_quantity,
        'sold_quantity': drug.sold_quantity,
        'expiry_date': drug.expiry_date.strftime('%Y-%m-%d'),
        'remaining_quantity': drug.remaining_quantity,
        'is_expired': drug.expiry_date < datetime.now().date(),
        'expires_soon': drug.expiry_date <= (datetime.now().date() + timedelta(days=30))
    })


@app.route('/admin/drugs/<int:drug_id>/export-to-controlled', methods=['POST'])
@login_required
def export_drug_to_controlled(drug_id):
    """Export a regular drug to controlled drugs table with all dosages."""
    if current_user.role != 'admin':
        return jsonify({'success': False, 'message': 'Unauthorized access'}), 403
    
    try:
        # Get the drug to export (with relationships loaded)
        drug = db.session.get(Drug, drug_id)
        if not drug:
            return jsonify({'success': False, 'message': 'Drug not found'}), 404
        
        # Store drug data for logging before deletion
        drug_name = drug.name
        drug_number = drug.drug_number
        
        # Check if controlled drug with same number already exists
        existing = db.session.query(ControlledDrug).filter_by(
            controlled_drug_number=drug.drug_number
        ).first()
        
        if existing:
            return jsonify({
                'success': False, 
                'message': f'Controlled drug with number {drug.drug_number} already exists'
            }), 400
        
        # Step 1: Create controlled drug with same data (excluding drug ID, will auto-generate)
        controlled_drug = ControlledDrug(
            controlled_drug_number=drug.drug_number,
            name=drug.name,
            specification=drug.specification,
            buying_price=drug.buying_price,
            selling_price=drug.selling_price,
            stocked_quantity=drug.stocked_quantity,
            sold_quantity=drug.sold_quantity,
            expiry_date=drug.expiry_date,
            created_at=drug.created_at,
            updated_at=drug.updated_at
        )
        
        db.session.add(controlled_drug)
        db.session.flush()  # Flush to get the controlled_drug.id without committing
        
        # Step 2: Copy all drug dosages to controlled drug dosages (excluding drug_id, only copy dosage details)
        dosages = db.session.query(DrugDosage).filter_by(drug_id=drug_id).all()
        dosage_count = len(dosages)
        
        for dosage in dosages:
            controlled_dosage = ControlledDrugDosage(
                controlled_drug_id=controlled_drug.id,
                source=dosage.source,
                indication=dosage.indication,
                contraindication=dosage.contraindication,
                interaction=dosage.interaction,
                side_effects=dosage.side_effects,
                dosage_peds=dosage.dosage_peds,
                dosage_adults=dosage.dosage_adults,
                dosage_geriatrics=dosage.dosage_geriatrics,
                important_notes=dosage.important_notes,
                created_at=dosage.created_at,
                updated_at=dosage.updated_at
            )
            db.session.add(controlled_dosage)
        
        # Step 3: Delete the original drug (cascade will delete related DrugDosage records)
        db.session.delete(drug)
        
        # Step 4: Log the export action
        log_audit(
            action='export',
            table='Drug',
            record_id=drug_id,
            changes={
                'drug_number': drug_number,
                'name': drug_name,
                'dosage_count': dosage_count,
                'action': 'exported_to_controlled_drugs',
                'new_controlled_drug_id': controlled_drug.id
            },
            new_values={
                'controlled_drug_id': controlled_drug.id,
                'status': 'successfully_migrated',
                'dosages_migrated': dosage_count
            }
        )
        
        # Commit all changes
        db.session.commit()
        
        app.logger.info(f"Drug '{drug_name}' (#{drug_number}, ID: {drug_id}) successfully exported to controlled drugs (New ID: {controlled_drug.id}) with {dosage_count} dosages")
        
        return jsonify({
            'success': True,
            'message': f'Drug "{drug_name}" successfully exported to Controlled Drugs with {dosage_count} dosages',
            'controlled_drug_id': controlled_drug.id,
            'dosages_migrated': dosage_count
        }), 200
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error exporting drug {drug_id} to controlled: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'message': f'Error exporting drug: {str(e)}'
        }), 500


@app.route('/admin/controlled-drugs', methods=['GET', 'POST'])
@login_required
def manage_controlled_drugs():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    embed = request.args.get('embed') == '1'

    if request.method == 'POST':
        action = request.form.get('action')

        if action == 'add':
            try:
                controlled = ControlledDrug(
                    controlled_drug_number=generate_controlled_drug_number(),
                    name=request.form.get('name'),
                    specification=request.form.get('specification'),
                    buying_price=float(request.form.get('buying_price')),
                    selling_price=float(request.form.get('selling_price')),
                    stocked_quantity=int(request.form.get('stocked_quantity')),
                    expiry_date=datetime.strptime(request.form.get('expiry_date'), '%Y-%m-%d').date(),
                )
                db.session.add(controlled)
                db.session.commit()

                log_audit('create', 'ControlledDrug', controlled.id, None, {
                    'controlled_drug_number': controlled.controlled_drug_number,
                    'name': controlled.name,
                    'specification': controlled.specification,
                    'buying_price': float(controlled.buying_price),
                    'selling_price': float(controlled.selling_price),
                    'stocked_quantity': controlled.stocked_quantity,
                    'expiry_date': controlled.expiry_date.isoformat(),
                })

                flash('Controlled drug added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding controlled drug: {str(e)}', 'danger')

        elif action == 'edit':
            controlled_id = request.form.get('controlled_drug_id')
            controlled = db.session.get(ControlledDrug, controlled_id)
            if controlled:
                try:
                    old_values = {
                        'controlled_drug_number': controlled.controlled_drug_number,
                        'name': controlled.name,
                        'specification': controlled.specification,
                        'buying_price': float(controlled.buying_price),
                        'selling_price': float(controlled.selling_price),
                        'stocked_quantity': controlled.stocked_quantity,
                        'sold_quantity': controlled.sold_quantity,
                        'expiry_date': controlled.expiry_date.isoformat(),
                    }

                    controlled.name = request.form.get('name')
                    controlled.specification = request.form.get('specification')
                    controlled.buying_price = float(request.form.get('buying_price'))
                    controlled.selling_price = float(request.form.get('selling_price'))
                    controlled.stocked_quantity = int(request.form.get('stocked_quantity'))
                    controlled.expiry_date = datetime.strptime(request.form.get('expiry_date'), '%Y-%m-%d').date()

                    db.session.commit()

                    log_audit('update', 'ControlledDrug', controlled.id, old_values, {
                        'controlled_drug_number': controlled.controlled_drug_number,
                        'name': controlled.name,
                        'specification': controlled.specification,
                        'buying_price': float(controlled.buying_price),
                        'selling_price': float(controlled.selling_price),
                        'stocked_quantity': controlled.stocked_quantity,
                        'sold_quantity': controlled.sold_quantity,
                        'expiry_date': controlled.expiry_date.isoformat(),
                    })

                    flash('Controlled drug updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating controlled drug: {str(e)}', 'danger')
            else:
                flash('Controlled drug not found', 'danger')

        elif action == 'delete':
            controlled_id = request.form.get('controlled_drug_id')
            controlled = db.session.get(ControlledDrug, controlled_id)
            if controlled:
                try:
                    log_audit('delete', 'ControlledDrug', controlled.id, {
                        'controlled_drug_number': controlled.controlled_drug_number,
                        'name': controlled.name,
                        'specification': controlled.specification,
                        'buying_price': float(controlled.buying_price),
                        'selling_price': float(controlled.selling_price),
                        'stocked_quantity': controlled.stocked_quantity,
                        'sold_quantity': controlled.sold_quantity,
                        'expiry_date': controlled.expiry_date.isoformat(),
                    }, None)

                    db.session.delete(controlled)
                    db.session.commit()
                    flash('Controlled drug deleted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error deleting controlled drug: {str(e)}', 'danger')
            else:
                flash('Controlled drug not found', 'danger')

        return redirect(url_for('manage_controlled_drugs', embed='1' if embed else None))

    filter_type = request.args.get('filter', 'all')
    query = db.select(ControlledDrug)

    if filter_type == 'low_stock':
        query = query.where(ControlledDrug.remaining_quantity < 10)
    elif filter_type == 'expiring_soon':
        today = datetime.now().date()
        thirty_days_later = today + timedelta(days=30)
        query = query.where(ControlledDrug.expiry_date <= thirty_days_later).order_by(ControlledDrug.expiry_date)
    elif filter_type == 'out_of_stock':
        query = query.where(ControlledDrug.remaining_quantity <= 0)
    elif filter_type == 'expired':
        today = datetime.now().date()
        query = query.where(ControlledDrug.expiry_date < today)

    controlled_drugs = db.session.execute(query).scalars().all()
    total_value = sum(float(d.selling_price) * float(d.remaining_quantity) for d in controlled_drugs)

    template_name = 'admin/controlled_drugs_embed.html' if embed else 'admin/controlled_drugs_full.html'
    return render_template(
        template_name,
        controlled_drugs=controlled_drugs,
        total_value=total_value,
        current_filter=filter_type,
        today=datetime.now().date(),
        expires_soon_cutoff=datetime.now().date() + timedelta(days=30),
    )


@app.route('/admin/controlled-drugs/<int:controlled_drug_id>')
@login_required
def get_controlled_drug(controlled_drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    drug = db.session.get(ControlledDrug, controlled_drug_id)
    if not drug:
        return jsonify({'error': 'Controlled drug not found'}), 404

    return jsonify({
        'id': drug.id,
        'controlled_drug_number': drug.controlled_drug_number,
        'name': drug.name,
        'specification': drug.specification,
        'buying_price': float(drug.buying_price),
        'selling_price': float(drug.selling_price),
        'stocked_quantity': drug.stocked_quantity,
        'sold_quantity': drug.sold_quantity,
        'expiry_date': drug.expiry_date.strftime('%Y-%m-%d'),
        'remaining_quantity': drug.remaining_quantity,
        'is_expired': drug.expiry_date < datetime.now().date(),
        'expires_soon': drug.expiry_date <= (datetime.now().date() + timedelta(days=30)),
    })


@app.route('/api/controlled-drugs/next-number', methods=['GET'])
@login_required
def get_next_controlled_drug_number():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        next_number = generate_controlled_drug_number()
        return jsonify({'controlled_drug_number': next_number}), 200
    except Exception as e:
        app.logger.error(f'Error generating controlled drug number: {str(e)}')
        return jsonify({'error': str(e)}), 500

@app.route('/api/drugs/next-number', methods=['GET'])
@login_required
def get_next_drug_number():
    """Generate the next drug number based on the last added drug"""
    try:
        # Get the last drug by ID (most recently added)
        last_drug = db.session.query(Drug).order_by(Drug.id.desc()).first()
        
        if last_drug:
            # Extract the numeric part from the drug number (e.g., DRG-0001 -> 1)
            drug_num_str = last_drug.drug_number
            if drug_num_str.startswith('DRG-'):
                try:
                    num = int(drug_num_str.replace('DRG-', ''))
                    next_num = num + 1
                except:
                    next_num = 1
            else:
                next_num = 1
        else:
            next_num = 1
        
        # Format the next number as DRG-0001, DRG-0002, etc.
        next_drug_number = f'DRG-{next_num:04d}'
        
        return jsonify({'drug_number': next_drug_number}), 200
    
    except Exception as e:
        app.logger.error(f'Error generating next drug number: {str(e)}')
        return jsonify({'error': str(e)}), 500
    
@app.route('/rs/<int:user_id>', methods=['GET'])
@login_required
def get_user_details(user_id):
    if current_user.role != 'admin':
        return {'error': 'Unauthorized'}, 403
    user = _db_get(User, user_id)
    if not user:
        return {'error': 'User not found'}, 404
    return {
        'id': user.id,
        'username': user.username,
        'email': user.email,
        'role': user.role,
        'is_active': user.is_active,
        'last_login': (user.last_login_dt or user.last_login).strftime('%Y-%m-%d %H:%M') if user.last_login_dt else (user.last_login if user.last_login else None)
    }
@app.route('/admin/users', methods=['GET', 'POST'])
@login_required
def manage_users():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    def _render_users_with_add_modal(add_user_state: dict) -> str:
        users = User.query.order_by(User.last_login.desc().nullslast(), User.username.asc()).all()
        return render_template('admin/users.html', users=users, open_add_user_modal=True, add_user_state=add_user_state)
    
    if request.method == 'POST':
        action = request.form.get('action')

        if action in {'add_request_otp', 'add_verify_otp', 'add_resend_otp'}:
            email_in = (request.form.get('email') or '').strip()
            email_norm = email_in.lower()

            add_user_state: dict = {
                'stage': 'start',
                'email': email_in,
                'username': (request.form.get('username') or '').strip(),
                'role': (request.form.get('role') or '').strip(),
                'is_active': bool(request.form.get('is_active')),
            }

            if not email_in or '@' not in email_in:
                flash('Please enter a valid email address.', 'danger')
                return _render_users_with_add_modal(add_user_state)

            if User.query.filter_by(email=email_in).first() or any(str(u.email).strip().lower() == email_norm for u in User.query.all()):
                flash('Email already exists', 'danger')
                return _render_users_with_add_modal(add_user_state)

            if action in {'add_request_otp', 'add_resend_otp'}:
                code = _generate_user_otp_code()
                now = get_eat_now()
                expires_at = now + timedelta(minutes=10)

                session['admin_add_user_otp_email'] = email_norm
                session['admin_add_user_otp_hash'] = _admin_add_user_otp_hash(email=email_in, code=code)
                session['admin_add_user_otp_expires_at'] = expires_at.isoformat()
                session['admin_add_user_otp_verified'] = False
                session.pop('admin_add_user_otp_verified_at', None)

                try:
                    _send_system_email(
                        recipient=email_in,
                        subject='Makokha Medical Centre - Email OTP Verification',
                        html=(
                            f"<p>Your OTP code is <b>{code}</b>.</p>"
                            f"<p>This code expires in 10 minutes.</p>"
                        ),
                        text_body=f"Your OTP code is {code}. It expires in 10 minutes.",
                    )
                    if action == 'add_resend_otp':
                        flash('OTP resent to the email. Enter it to continue.', 'success')
                    else:
                        flash('OTP sent to the entered email. Enter it to continue.', 'success')
                except Exception as mail_exc:
                    app.logger.error(f'Failed to send admin add-user OTP: {mail_exc}', exc_info=True)
                    flash('Failed to send OTP email. Check email configuration and try again.', 'danger')
                    return _render_users_with_add_modal(add_user_state)

                add_user_state['stage'] = 'otp_sent'
                return _render_users_with_add_modal(add_user_state)

            # add_verify_otp
            otp_in = (request.form.get('otp') or '').strip()
            if not otp_in or not otp_in.isdigit() or len(otp_in) != 6:
                flash('Enter the 6-digit OTP sent to the email.', 'danger')
                add_user_state['stage'] = 'otp_sent'
                return _render_users_with_add_modal(add_user_state)

            sess_email = (session.get('admin_add_user_otp_email') or '').strip().lower()
            sess_hash = (session.get('admin_add_user_otp_hash') or '').strip()
            expires_at = _parse_iso_dt(session.get('admin_add_user_otp_expires_at'))

            if not sess_email or sess_email != email_norm or not sess_hash or not expires_at:
                flash('OTP session not found. Please request a new OTP.', 'danger')
                add_user_state['stage'] = 'start'
                return _render_users_with_add_modal(add_user_state)

            if get_eat_now() > expires_at:
                flash('OTP expired. Please request a new OTP.', 'danger')
                add_user_state['stage'] = 'start'
                return _render_users_with_add_modal(add_user_state)

            expected = _admin_add_user_otp_hash(email=email_in, code=otp_in)
            if not secrets.compare_digest(expected, sess_hash):
                flash('Invalid OTP. Please try again.', 'danger')
                add_user_state['stage'] = 'otp_sent'
                return _render_users_with_add_modal(add_user_state)

            session['admin_add_user_otp_verified'] = True
            session['admin_add_user_otp_verified_at'] = get_eat_now().isoformat()
            flash('OTP confirmed. You can now finish adding the user.', 'success')
            add_user_state['stage'] = 'verified'
            return _render_users_with_add_modal(add_user_state)
        
        if action == 'add':
            try:
                # NOTE: username/email are encrypted, so DB equality may not work reliably.
                username_in = (request.form.get('username') or '').strip()
                email_in = (request.form.get('email') or '').strip()

                # Require admin OTP verification before creating the user.
                verified = bool(session.get('admin_add_user_otp_verified'))
                verified_email = (session.get('admin_add_user_otp_email') or '').strip().lower()
                verified_at = _parse_iso_dt(session.get('admin_add_user_otp_verified_at'))
                if (not verified) or (verified_email != email_in.strip().lower()) or (not verified_at) or (get_eat_now() - verified_at > timedelta(minutes=30)):
                    flash('Verify the email by OTP before adding the user.', 'danger')
                    add_user_state = {
                        'stage': 'start',
                        'email': email_in,
                        'username': username_in,
                        'role': (request.form.get('role') or '').strip(),
                        'is_active': bool(request.form.get('is_active')),
                    }
                    return _render_users_with_add_modal(add_user_state)

                if (request.form.get('password') or '') != (request.form.get('confirm_password') or ''):
                    flash('Passwords do not match', 'danger')
                    add_user_state = {
                        'stage': 'verified',
                        'email': email_in,
                        'username': username_in,
                        'role': (request.form.get('role') or '').strip(),
                        'is_active': bool(request.form.get('is_active')),
                    }
                    return _render_users_with_add_modal(add_user_state)

                if User.query.filter_by(username=username_in).first() or any(str(u.username) == username_in for u in User.query.all()):
                    flash('Username already exists', 'danger')
                    add_user_state = {
                        'stage': 'verified',
                        'email': email_in,
                        'username': username_in,
                        'role': (request.form.get('role') or '').strip(),
                        'is_active': bool(request.form.get('is_active')),
                    }
                    return _render_users_with_add_modal(add_user_state)
                
                if User.query.filter_by(email=email_in).first() or any(str(u.email).strip().lower() == email_in.lower() for u in User.query.all()):
                    flash('Email already exists', 'danger')
                    add_user_state = {
                        'stage': 'start',
                        'email': email_in,
                        'username': username_in,
                        'role': (request.form.get('role') or '').strip(),
                        'is_active': bool(request.form.get('is_active')),
                    }
                    return _render_users_with_add_modal(add_user_state)
                
                # Create new user
                user = User(
                    username=username_in,
                    email=email_in,
                    role=(request.form.get('role') or '').strip(),
                    is_active=True if request.form.get('is_active') else False,
                    last_login=None,  # Initialize last_login as None for new users
                    is_email_verified=True,
                )
                user.set_password(request.form.get('password'))
                db.session.add(user)
                db.session.commit()

                # Clear admin add-user OTP session state after successful creation.
                session.pop('admin_add_user_otp_email', None)
                session.pop('admin_add_user_otp_hash', None)
                session.pop('admin_add_user_otp_expires_at', None)
                session.pop('admin_add_user_otp_verified', None)
                session.pop('admin_add_user_otp_verified_at', None)

                flash('User added successfully (email confirmed by OTP).', 'success')
                
                log_audit('create', 'User', user.id, None, {
                    'username': user.username,
                    'email': user.email,
                    'role': user.role,
                    'is_active': user.is_active,
                    'last_login': user.last_login
                })
                
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding user: {str(e)}', 'danger')
        
        elif action == 'edit':
            user_id = request.form.get('user_id')
            user = _db_get(User, user_id)
            if user:
                try:
                    old_values = {
                        'username': user.username,
                        'email': user.email,
                        'role': user.role,
                        'is_active': user.is_active,
                        'last_login': (user.last_login_dt or user.last_login).strftime('%Y-%m-%d %H:%M:%S') if user.last_login_dt else (user.last_login if user.last_login else None)
                    }
                    
                    user.username = request.form.get('username')
                    user.email = request.form.get('email')
                    user.role = request.form.get('role')
                    user.is_active = True if request.form.get('is_active') else False
                    
                    if request.form.get('password'):
                        user.set_password(request.form.get('password'))
                    
                    db.session.commit()
                    
                    log_audit('update', 'User', user.id, old_values, {
                        'username': user.username,
                        'email': user.email,
                        'role': user.role,
                        'is_active': user.is_active,
                        'last_login': (user.last_login_dt or user.last_login).strftime('%Y-%m-%d %H:%M:%S') if user.last_login_dt else (user.last_login if user.last_login else None)
                    })
                    
                    flash('User updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating user: {str(e)}', 'danger')
            else:
                flash('User not found', 'danger')
        
        elif action == 'delete':
            user_id = request.form.get('user_id')
            user = _db_get(User, user_id)
            if user:
                if user.id == current_user.id:
                    flash('You cannot delete your own account', 'danger')
                else:
                    try:
                        log_audit('delete', 'User', user.id, {
                            'username': user.username,
                            'email': user.email,
                            'role': user.role,
                            'is_active': user.is_active,
                            'last_login': (user.last_login_dt or user.last_login).strftime('%Y-%m-%d %H:%M:%S') if user.last_login_dt else (user.last_login if user.last_login else None)
                        }, None)
                        
                        db.session.delete(user)
                        db.session.commit()
                        flash('User deleted successfully!', 'success')
                    except Exception as e:
                        db.session.rollback()
                        flash(f'Error deleting user: {str(e)}', 'danger')
            else:
                flash('User not found', 'danger')
        
        return redirect(url_for('manage_users'))
    
    # Order users by last login (most recent first) and then by username
    users = User.query.order_by(User.last_login.desc().nullslast(), User.username.asc()).all()
    return render_template('admin/users.html', users=users)


# ============================================
# Ward and Department Assignment Routes
# ============================================

@app.route('/admin/wards', methods=['GET'])
@login_required
def get_wards():
    """Get all active wards for dropdown selection."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    wards = Ward.query.order_by(Ward.name).all()
    return jsonify([{
        'id': w.id,
        'name': w.name,
        'description': w.description
    } for w in wards])


@app.route('/admin/departments', methods=['GET'])
@login_required
def get_departments():
    """Get all active outpatient departments for dropdown selection."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    departments = OutpatientDepartment.query.filter_by(is_active=True).order_by(OutpatientDepartment.name).all()
    return jsonify([{
        'id': d.id,
        'name': d.name,
        'type': d.type,
        'description': d.description
    } for d in departments])


@app.route('/admin/user/<int:user_id>/ward-assignments', methods=['GET'])
@login_required
def get_user_ward_assignments(user_id):
    """Get all ward assignments for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = _db_get_or_404(User, user_id)
    assignments = UserWardAssignment.query.filter_by(user_id=user_id).all()
    
    return jsonify({
        'assignments': [{
            'id': a.id,
            'ward_id': a.ward_id,
            'ward_name': a.ward.name,
            'role': a.role,
            'is_primary': a.is_primary,
            'created_at': a.created_at.isoformat() if a.created_at else None
        } for a in assignments]
    })


@app.route('/admin/user/<int:user_id>/department-assignments', methods=['GET'])
@login_required
def get_user_department_assignments(user_id):
    """Get all department assignments for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = _db_get_or_404(User, user_id)
    assignments = UserDepartmentAssignment.query.filter_by(user_id=user_id).all()
    
    return jsonify({
        'assignments': [{
            'id': a.id,
            'department_id': a.department_id,
            'department_name': a.department.name,
            'role': a.role,
            'is_primary': a.is_primary,
            'created_at': a.created_at.isoformat() if a.created_at else None
        } for a in assignments]
    })


@app.route('/admin/user/<int:user_id>/ward-assignment', methods=['POST'])
@login_required
def add_user_ward_assignment(user_id):
    """Add a ward assignment for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = _db_get_or_404(User, user_id)
    data = request.get_json()
    
    ward_id = data.get('ward_id')
    role = data.get('role')
    is_primary = data.get('is_primary', False)
    
    if not ward_id or not role:
        return jsonify({'error': 'Ward ID and role are required'}), 400
    
    # Check if ward exists
    ward = _db_get(Ward, ward_id)
    if not ward:
        return jsonify({'error': 'Ward not found'}), 404
    
    # Check if assignment already exists
    existing = UserWardAssignment.query.filter_by(user_id=user_id, ward_id=ward_id).first()
    if existing:
        return jsonify({'error': 'User already assigned to this ward'}), 400
    
    # If this is primary, unset other primary assignments
    if is_primary:
        UserWardAssignment.query.filter_by(user_id=user_id, is_primary=True).update({'is_primary': False})
    
    # Create new assignment
    assignment = UserWardAssignment(
        user_id=user_id,
        ward_id=ward_id,
        role=role,
        is_primary=is_primary
    )
    
    try:
        db.session.add(assignment)
        db.session.commit()
        return jsonify({
            'message': 'Ward assignment added successfully',
            'assignment': {
                'id': assignment.id,
                'ward_id': assignment.ward_id,
                'ward_name': ward.name,
                'role': assignment.role,
                'is_primary': assignment.is_primary
            }
        }), 201
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'Error adding ward assignment: {e}')
        return jsonify({'error': 'Failed to add ward assignment'}), 500


@app.route('/admin/user/<int:user_id>/department-assignment', methods=['POST'])
@login_required
def add_user_department_assignment(user_id):
    """Add a department assignment for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    user = _db_get_or_404(User, user_id)
    data = request.get_json()
    
    department_id = data.get('department_id')
    role = data.get('role')
    is_primary = data.get('is_primary', False)
    
    if not department_id or not role:
        return jsonify({'error': 'Department ID and role are required'}), 400
    
    # Check if department exists
    department = _db_get(OutpatientDepartment, department_id)
    if not department:
        return jsonify({'error': 'Department not found'}), 404
    
    # Check if assignment already exists
    existing = UserDepartmentAssignment.query.filter_by(user_id=user_id, department_id=department_id).first()
    if existing:
        return jsonify({'error': 'User already assigned to this department'}), 400
    
    # If this is primary, unset other primary assignments
    if is_primary:
        UserDepartmentAssignment.query.filter_by(user_id=user_id, is_primary=True).update({'is_primary': False})
    
    # Create new assignment
    assignment = UserDepartmentAssignment(
        user_id=user_id,
        department_id=department_id,
        role=role,
        is_primary=is_primary
    )
    
    try:
        db.session.add(assignment)
        db.session.commit()
        return jsonify({
            'message': 'Department assignment added successfully',
            'assignment': {
                'id': assignment.id,
                'department_id': assignment.department_id,
                'department_name': department.name,
                'role': assignment.role,
                'is_primary': assignment.is_primary
            }
        }), 201
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'Error adding department assignment: {e}')
        return jsonify({'error': 'Failed to add department assignment'}), 500


@app.route('/admin/user/<int:user_id>/ward-assignment/<int:assignment_id>', methods=['DELETE'])
@login_required
def remove_user_ward_assignment(user_id, assignment_id):
    """Remove a ward assignment for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    assignment = UserWardAssignment.query.filter_by(id=assignment_id, user_id=user_id).first()
    if not assignment:
        return jsonify({'error': 'Assignment not found'}), 404
    
    try:
        db.session.delete(assignment)
        db.session.commit()
        return jsonify({'message': 'Ward assignment removed successfully'}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'Error removing ward assignment: {e}')
        return jsonify({'error': 'Failed to remove ward assignment'}), 500


@app.route('/admin/user/<int:user_id>/department-assignment/<int:assignment_id>', methods=['DELETE'])
@login_required
def remove_user_department_assignment(user_id, assignment_id):
    """Remove a department assignment for a user."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    assignment = UserDepartmentAssignment.query.filter_by(id=assignment_id, user_id=user_id).first()
    if not assignment:
        return jsonify({'error': 'Assignment not found'}), 404
    
    try:
        db.session.delete(assignment)
        db.session.commit()
        return jsonify({'message': 'Department assignment removed successfully'}), 200
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'Error removing department assignment: {e}')
        return jsonify({'error': 'Failed to remove department assignment'}), 500


@app.route('/admin/employees', methods=['GET', 'POST'])
@login_required
def manage_employees():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            try:
                # Handle empty salary
                salary = request.form.get('salary')
                salary_value = float(salary) if salary and salary.strip() else None
                
                # Handle hire date
                hire_date_str = request.form.get('hire_date')
                hire_date = datetime.strptime(hire_date_str, '%Y-%m-%d').date() if hire_date_str and hire_date_str.strip() else None
                
                # Handle user_id
                user_id_str = request.form.get('user_id')
                user_id = int(user_id_str) if user_id_str and user_id_str.strip() else None
                
                employee = Employee(
                    name=request.form.get('name'),
                    position=request.form.get('position'),
                    salary=salary_value,
                    hire_date=hire_date,
                    contact=request.form.get('contact'),
                    user_id=user_id
                )
                db.session.add(employee)
                db.session.commit()
                
                log_audit('create', 'Employee', employee.id, None, {
                    'name': employee.name,
                    'position': employee.position,
                    'salary': employee.salary,
                    'hire_date': str(employee.hire_date) if employee.hire_date else None,
                    'contact': employee.contact,
                    'user_id': employee.user_id
                })
                
                flash('Employee added successfully!', 'success')
            except ValueError as e:
                db.session.rollback()
                flash(f'Invalid data format: {str(e)}', 'danger')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding employee: {str(e)}', 'danger')
        
        elif action == 'edit':
            employee_id = request.form.get('employee_id')
            employee = _db_get(Employee, employee_id)
            if employee:
                try:
                    old_values = {
                        'name': employee.name,
                        'position': employee.position,
                        'salary': employee.salary,
                        'hire_date': str(employee.hire_date) if employee.hire_date else None,
                        'contact': employee.contact,
                        'user_id': employee.user_id
                    }
                    
                    # Handle empty salary
                    salary = request.form.get('salary')
                    salary_value = float(salary) if salary and salary.strip() else None
                    
                    # Handle hire date
                    hire_date_str = request.form.get('hire_date')
                    hire_date = datetime.strptime(hire_date_str, '%Y-%m-%d').date() if hire_date_str and hire_date_str.strip() else None
                    
                    # Handle user_id
                    user_id_str = request.form.get('user_id')
                    user_id = int(user_id_str) if user_id_str and user_id_str.strip() else None
                    
                    employee.name = request.form.get('name')
                    employee.position = request.form.get('position')
                    employee.salary = salary_value
                    employee.hire_date = hire_date
                    employee.contact = request.form.get('contact')
                    employee.user_id = user_id
                    
                    db.session.commit()
                    
                    log_audit('update', 'Employee', employee.id, old_values, {
                        'name': employee.name,
                        'position': employee.position,
                        'salary': employee.salary,
                        'hire_date': str(employee.hire_date) if employee.hire_date else None,
                        'contact': employee.contact,
                        'user_id': employee.user_id
                    })
                    
                    flash('Employee updated successfully!', 'success')
                except ValueError as e:
                    db.session.rollback()
                    flash(f'Invalid data format: {str(e)}', 'danger')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating employee: {str(e)}', 'danger')
            else:
                flash('Employee not found', 'danger')
        
        elif action == 'delete':
            employee_id = request.form.get('employee_id')
            employee = _db_get(Employee, employee_id)
            if employee:
                try:
                    log_audit('delete', 'Employee', employee.id, {
                        'name': employee.name,
                        'position': employee.position,
                        'salary': employee.salary,
                        'hire_date': str(employee.hire_date) if employee.hire_date else None,
                        'contact': employee.contact,
                        'user_id': employee.user_id
                    }, None)
                    
                    db.session.delete(employee)
                    db.session.commit()
                    flash('Employee deleted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error deleting employee: {str(e)}', 'danger')
            else:
                flash('Employee not found', 'danger')
        
        return redirect(url_for('manage_employees'))
    
    employees = Employee.query.all()
    users = User.query.filter(User.role != 'admin').all()
    return render_template('admin/employees.html', 
                        employees=employees, 
                        users=users,
                        User=User)


@app.route('/admin/employees/add', methods=['GET', 'POST'])
@login_required
def add_employee():
    """Render and handle the standalone 'Add Employee' form.

    Some templates use a separate add page (admin/add_employee.html) while the
    main employee management screen supports modal-based CRUD.
    """
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if request.method == 'POST':
        try:
            salary_raw = request.form.get('salary')
            salary_value = float(salary_raw) if salary_raw and str(salary_raw).strip() else None

            hire_date_raw = request.form.get('hire_date')
            hire_date_value = (
                datetime.strptime(hire_date_raw, '%Y-%m-%d').date()
                if hire_date_raw and str(hire_date_raw).strip()
                else None
            )

            employee = Employee(
                name=request.form.get('name'),
                position=request.form.get('position'),
                salary=salary_value,
                hire_date=hire_date_value,
                contact=request.form.get('contact'),
            )
            db.session.add(employee)
            db.session.commit()

            try:
                log_audit('create', 'Employee', employee.id, None, {
                    'name': employee.name,
                    'position': employee.position,
                    'salary': employee.salary,
                    'hire_date': str(employee.hire_date) if employee.hire_date else None,
                    'contact': employee.contact,
                    'user_id': employee.user_id,
                })
            except Exception:
                # Audit logging should not block core flows.
                pass

            flash('Employee added successfully!', 'success')
            return redirect(url_for('manage_employees'))
        except ValueError as e:
            db.session.rollback()
            flash(f'Invalid data format: {str(e)}', 'danger')
        except Exception as e:
            db.session.rollback()
            flash(f'Error adding employee: {str(e)}', 'danger')

    return render_template('admin/add_employee.html')


@app.route('/admin/financial_reports', methods=['GET', 'POST'])
@login_required
def financial_reports():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    # Backwards-compatible: if something posts to this route directly,
    # handle it the same way as `generate_financial_report`.
    if request.method == 'POST':
        return generate_financial_report()

    reports = FinancialReport.query.order_by(FinancialReport.generated_at.desc()).all()
    return render_template('admin/financial_reports.html', reports=reports)


@app.route('/admin/financial_reports/generate', methods=['POST'])
@login_required
def generate_financial_report():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    report_type = (request.form.get('report_type') or 'custom').strip().lower()
    start_date_str = request.form.get('start_date')
    end_date_str = request.form.get('end_date')

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
    except Exception:
        flash('Invalid start/end date', 'danger')
        return redirect(url_for('financial_reports'))

    if start_date > end_date:
        flash('Start date cannot be after end date', 'danger')
        return redirect(url_for('financial_reports'))

    # Use an exclusive end for DateTime filters.
    end_dt_exclusive = datetime.combine(end_date + timedelta(days=1), datetime.min.time())
    start_dt_inclusive = datetime.combine(start_date, datetime.min.time())

    try:
        total_sales = db.session.query(func.coalesce(func.sum(Sale.total_amount), 0)).filter(
            Sale.created_at >= start_dt_inclusive,
            Sale.created_at < end_dt_exclusive,
        ).scalar()

        total_invoices = db.session.query(func.coalesce(func.sum(Invoice.total_amount), 0)).filter(
            Invoice.date_issued >= start_dt_inclusive,
            Invoice.date_issued < end_dt_exclusive,
        ).scalar()

        expense_effective_date = func.coalesce(Expense.paid_date, func.date(Expense.created_at))
        total_expenses = db.session.query(func.coalesce(func.sum(Expense.amount), 0)).filter(
            expense_effective_date >= start_date,
            expense_effective_date <= end_date,
        ).scalar()

        total_revenue = (total_sales or 0) + (total_invoices or 0)
        net_profit = (total_revenue or 0) - (total_expenses or 0)

        report = FinancialReport(
            report_type=report_type,
            start_date=start_date,
            end_date=end_date,
            total_revenue=total_revenue,
            total_expenses=total_expenses,
            net_profit=net_profit,
            generated_by_id=current_user.id,
        )
        db.session.add(report)
        db.session.flush()  # ensure report.id is available

        # Keep items lightweight: aggregated categories.
        if total_sales and float(total_sales) != 0.0:
            db.session.add(ReportItem(
                report_id=report.id,
                item_type='revenue',
                description='Sales',
                amount=total_sales,
                date=start_date,
                reference_table='sales',
            ))

        if total_invoices and float(total_invoices) != 0.0:
            db.session.add(ReportItem(
                report_id=report.id,
                item_type='revenue',
                description='Invoices',
                amount=total_invoices,
                date=start_date,
                reference_table='invoices',
            ))

        if total_expenses and float(total_expenses) != 0.0:
            db.session.add(ReportItem(
                report_id=report.id,
                item_type='expense',
                description='Expenses',
                amount=total_expenses,
                date=start_date,
                reference_table='expenses',
            ))

        db.session.commit()
        flash('Financial report generated successfully.', 'success')
        return redirect(url_for('financial_reports'))
    except Exception as e:
        db.session.rollback()
        flash(f'Error generating report: {str(e)}', 'danger')
        return redirect(url_for('financial_reports'))


@app.route('/admin/financial_reports/<int:report_id>', methods=['GET'])
@login_required
def view_financial_report(report_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    report = db.session.get(FinancialReport, report_id)
    if not report:
        flash('Financial report not found.', 'danger')
        return redirect(url_for('financial_reports'))

    return render_template('admin/view_financial_report.html', report=report)


@app.route('/admin/financial_reports/<int:report_id>/delete', methods=['POST'])
@login_required
def delete_financial_report(report_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    report = db.session.get(FinancialReport, report_id)
    if not report:
        flash('Financial report not found.', 'danger')
        return redirect(url_for('financial_reports'))

    try:
        db.session.delete(report)
        db.session.commit()
        flash('Financial report deleted successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting report: {str(e)}', 'danger')

    return redirect(url_for('financial_reports'))

@app.route("/db-keepalive")
def db_keepalive():
    if request.headers.get("X-CRON-SECRET") != os.getenv("CRON_SECRET"):
        return jsonify({"error": "unauthorized"}), 401

    try:
        db.session.execute(text("SELECT 1"))
        db.session.commit()

        return jsonify({"db": "awake"}), 200

    except Exception as e:
        print("DB keepalive error:", str(e))
        return jsonify({"error": "db error"}), 500


# =================================================================================================
# FINANCIAL DASHBOARD ROUTES - DAILY, WEEKLY, MONTHLY, YEARLY
# =================================================================================================

@app.route('/admin/financial/dashboard/daily', methods=['GET', 'POST'])
@login_required
def financial_dashboard_daily():
    """Daily Financial Report Dashboard"""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        target_date = date.today()
        if request.method == 'POST':
            date_str = request.form.get('date')
            if date_str:
                target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        metrics = get_daily_financial_summary(target_date)
        
        # Get previous day for comparison
        previous_date = target_date - timedelta(days=1)
        previous_metrics = get_daily_financial_summary(previous_date)
        
        # Calculate percentage changes
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        return render_template('admin/financial_dashboard_daily.html', 
            metrics=metrics, 
            target_date=target_date,
            previous_metrics=previous_metrics
        )
    except Exception as e:
        app.logger.error(f"Error in daily financial dashboard: {str(e)}")
        flash(f'Error loading dashboard: {str(e)}', 'danger')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/financial/dashboard/weekly', methods=['GET', 'POST'])
@login_required
def financial_dashboard_weekly():
    """Weekly Financial Report Dashboard"""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        target_date = date.today()
        if request.method == 'POST':
            date_str = request.form.get('date')
            if date_str:
                target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        metrics = get_weekly_financial_summary(target_date)
        
        # Get previous week for comparison
        previous_date = target_date - timedelta(days=7)
        previous_metrics = get_weekly_financial_summary(previous_date)
        
        # Calculate percentage changes
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Get daily breakdown for the week
        daily_breakdown = _get_daily_breakdown(metrics['start_date'], metrics['end_date'])
        
        return render_template('admin/financial_dashboard_weekly.html', 
            metrics=metrics, 
            target_date=target_date,
            previous_metrics=previous_metrics,
            daily_breakdown=daily_breakdown
        )
    except Exception as e:
        app.logger.error(f"Error in weekly financial dashboard: {str(e)}")
        flash(f'Error loading dashboard: {str(e)}', 'danger')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/financial/dashboard/monthly', methods=['GET', 'POST'])
@login_required
def financial_dashboard_monthly():
    """Monthly Financial Report Dashboard"""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        today = date.today()
        year = today.year
        month = today.month
        
        if request.method == 'POST':
            year_str = request.form.get('year')
            month_str = request.form.get('month')
            if year_str and month_str:
                year = int(year_str)
                month = int(month_str)
        
        metrics = get_monthly_financial_summary(year, month)
        
        # Get previous month for comparison
        if month == 1:
            prev_year, prev_month = year - 1, 12
        else:
            prev_year, prev_month = year, month - 1
        previous_metrics = get_monthly_financial_summary(prev_year, prev_month)
        
        # Calculate percentage changes
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Get weekly breakdown for the month
        weekly_breakdown = _get_weekly_breakdown(metrics['start_date'], metrics['end_date'])
        
        # Get budget variance data
        budget_data = _get_budget_variance(year, month)
        
        return render_template('admin/financial_dashboard_monthly.html', 
            metrics=metrics, 
            year=year,
            month=month,
            previous_metrics=previous_metrics,
            weekly_breakdown=weekly_breakdown,
            budget_data=budget_data
        )
    except Exception as e:
        app.logger.error(f"Error in monthly financial dashboard: {str(e)}")
        flash(f'Error loading dashboard: {str(e)}', 'danger')
        return redirect(url_for('admin_dashboard'))


@app.route('/admin/financial/dashboard/yearly', methods=['GET', 'POST'])
@login_required
def financial_dashboard_yearly():
    """Yearly Financial Report Dashboard"""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        year = date.today().year
        
        if request.method == 'POST':
            year_str = request.form.get('year')
            if year_str:
                year = int(year_str)
        
        metrics = get_yearly_financial_summary(year)
        
        # Get previous year for comparison
        previous_metrics = get_yearly_financial_summary(year - 1)
        
        # Calculate percentage changes
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Get monthly breakdown for the year
        monthly_breakdown = _get_monthly_breakdown(year)
        
        # Get department performance
        dept_performance = _get_department_performance(metrics['start_date'], metrics['end_date'])
        
        return render_template('admin/financial_dashboard_yearly.html', 
            metrics=metrics, 
            year=year,
            previous_metrics=previous_metrics,
            monthly_breakdown=monthly_breakdown,
            dept_performance=dept_performance
        )
    except Exception as e:
        app.logger.error(f"Error in yearly financial dashboard: {str(e)}")
        flash(f'Error loading dashboard: {str(e)}', 'danger')
        return redirect(url_for('admin_dashboard'))


# =================================================================================================
# HELPER CLASS FOR DICT TO OBJECT CONVERSION
# =================================================================================================

class DictToObj:
    """Convert dict to object for template access with dot notation"""
    def __init__(self, data):
        if isinstance(data, dict):
            for key, value in data.items():
                if isinstance(value, dict):
                    setattr(self, key, DictToObj(value))
                elif isinstance(value, list):
                    setattr(self, key, [DictToObj(item) if isinstance(item, dict) else item for item in value])
                else:
                    setattr(self, key, value)
        else:
            self.__dict__ = data


# =================================================================================================
# FINANCIAL DASHBOARD API ROUTES (For AJAX Loading in Financial Reports Page)
# =================================================================================================

@app.route('/api/financial/dashboard/daily', methods=['GET'])
@login_required
def api_financial_dashboard_daily():
    """API endpoint to get daily dashboard HTML"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        target_date = date.today()
        date_str = request.args.get('date')
        start_date_str = request.args.get('startDate')
        end_date_str = request.args.get('endDate')
        
        # Check if date range is provided
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            
            # Calculate number of days in range
            num_days = (end_date - start_date).days + 1
            
            # Generate daily metrics for all days in range
            daily_data = []
            current = start_date
            total_revenue = 0
            total_expense = 0
            total_profit = 0
            
            while current <= end_date:
                metrics = get_daily_financial_summary(current)
                daily_data.append({
                    'date': current,
                    'revenue': metrics.get('total_revenue', 0),
                    'expense': metrics.get('total_expense', 0),
                    'profit': metrics.get('net_profit', 0),
                    'margin': (metrics.get('net_profit', 0) / metrics.get('total_revenue', 1) * 100) if metrics.get('total_revenue', 0) > 0 else 0
                })
                total_revenue += metrics.get('total_revenue', 0)
                total_expense += metrics.get('total_expense', 0)
                total_profit += metrics.get('net_profit', 0)
                current += timedelta(days=1)
            
            # Calculate aggregated metrics
            metrics = {
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_profit': total_profit,
                'start_date': start_date,
                'end_date': end_date,
                'cashflow_breakdown': {'total': total_revenue},  # Simplified for range
                'profit_margin': (total_profit / total_revenue * 100) if total_revenue > 0 else 0,
                'outstanding_debtor': 0,
                'outstanding_debtor_count': 0,
                'outstanding_insurance': 0,
                'outstanding_insurance_count': 0,
                'revenue_breakdown': {
                    'pharmacy': 0, 'lab': 0, 'imaging': 0, 'consultation': 0, 'insurance': 0, 'other': 0
                },
                'expense_breakdown': {
                    'payroll': 0, 'pharmacy': 0, 'equipment': 0, 'utilities': 0, 'debt': 0, 'other': 0
                }
            }
            
            cashflow_breakdown = metrics.get('cashflow_breakdown', {})
            metrics.pop('cashflow_breakdown', None)
            metrics = DictToObj(metrics)
            
            return render_template('admin/_financial_dashboard_daily_fragment.html', 
                metrics=metrics, cashflow_breakdown=cashflow_breakdown, target_date=start_date, 
                is_range=True, date_range_label=f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", 
                daily_data=daily_data, num_days=num_days, abs=abs)
        
        # Single day mode (existing behavior)
        elif date_str:
            target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        metrics = get_daily_financial_summary(target_date)
        previous_date = target_date - timedelta(days=1)
        previous_metrics = get_daily_financial_summary(previous_date)
        
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Create revenue breakdown object
        metrics['revenue_breakdown'] = {
            'pharmacy': metrics.get('pharmacy_revenue', 0),
            'lab': metrics.get('lab_revenue', 0),
            'imaging': metrics.get('imaging_revenue', 0),
            'consultation': metrics.get('consultation_revenue', 0),
            'insurance': metrics.get('insurance_revenue', 0),
            'other': metrics.get('other_revenue', 0)
        }
        
        # Create expense breakdown object
        metrics['expense_breakdown'] = {
            'payroll': metrics.get('payroll_expense', 0),
            'pharmacy': metrics.get('pharmacy_expense', 0),
            'equipment': metrics.get('equipment_expense', 0),
            'utilities': metrics.get('utilities_expense', 0),
            'debt': metrics.get('debt_payment', 0),
            'other': metrics.get('other_expense', 0)
        }
        
        # Save cashflow_breakdown before DictToObj conversion (needs .items() in template)
        cashflow_breakdown = metrics.get('cashflow_breakdown', {})
        
        # Add outstanding/debtor metrics with default values if missing
        metrics['outstanding_debtor'] = metrics.get('outstanding_debtor', 0)
        metrics['outstanding_debtor_count'] = metrics.get('outstanding_debtor_count', 0)
        metrics['outstanding_insurance'] = metrics.get('outstanding_insurance', 0)
        metrics['outstanding_insurance_count'] = metrics.get('outstanding_insurance_count', 0)
        
        # Remove cashflow_breakdown from metrics before conversion to avoid DictToObj wrapping
        metrics.pop('cashflow_breakdown', None)
        
        metrics = DictToObj(metrics)
        return render_template('admin/_financial_dashboard_daily_fragment.html', metrics=metrics, cashflow_breakdown=cashflow_breakdown, target_date=target_date, is_range=False, abs=abs)
    except Exception as e:
        app.logger.error(f"Error in daily API: {str(e)}")
        return f'<div class="alert alert-danger">Error: {str(e)}</div>', 500


@app.route('/api/financial/dashboard/weekly', methods=['GET'])
@login_required
def api_financial_dashboard_weekly():
    """API endpoint to get weekly dashboard HTML"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        target_date = date.today()
        date_str = request.args.get('date')
        start_date_str = request.args.get('startDate')
        end_date_str = request.args.get('endDate')
        
        # Check if date range is provided
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            
            # Calculate number of weeks in range
            num_weeks = ((end_date - start_date).days // 7) + 1
            
            # Generate weekly metrics for all weeks in range
            weekly_data = _get_weekly_breakdown(start_date, end_date)
            
            # Calculate aggregated metrics
            total_revenue = sum(w.get('revenue', 0) for w in weekly_data)
            total_expense = sum(w.get('expense', 0) for w in weekly_data)
            total_profit = sum(w.get('profit', 0) for w in weekly_data)
            
            metrics = {
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_profit': total_profit,
                'start_date': start_date,
                'end_date': end_date,
                'cashflow_breakdown': {'total': total_revenue},
                'profit_margin': (total_profit / total_revenue * 100) if total_revenue > 0 else 0,
                'outstanding_debtor': 0,
                'outstanding_debtor_count': 0,
                'outstanding_insurance': 0,
                'outstanding_insurance_count': 0,
                'revenue_breakdown': {
                    'pharmacy': 0, 'lab': 0, 'imaging': 0, 'consultation': 0, 'insurance': 0, 'other': 0
                },
                'expense_breakdown': {
                    'payroll': 0, 'pharmacy': 0, 'equipment': 0, 'utilities': 0, 'debt': 0, 'other': 0
                }
            }
            
            cashflow_breakdown = metrics.get('cashflow_breakdown', {})
            metrics.pop('cashflow_breakdown', None)
            metrics = DictToObj(metrics)
            
            return render_template('admin/_financial_dashboard_weekly_fragment.html', 
                metrics=metrics, cashflow_breakdown=cashflow_breakdown, target_date=start_date,
                is_range=True, date_range_label=f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", 
                weekly_data=weekly_data, num_weeks=num_weeks, abs=abs)
        
        # Single week mode (existing behavior)
        elif date_str:
            target_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        
        metrics = get_weekly_financial_summary(target_date)
        previous_date = target_date - timedelta(days=7)
        previous_metrics = get_weekly_financial_summary(previous_date)
        
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Create revenue breakdown object
        metrics['revenue_breakdown'] = {
            'pharmacy': metrics.get('pharmacy_revenue', 0),
            'lab': metrics.get('lab_revenue', 0),
            'imaging': metrics.get('imaging_revenue', 0),
            'consultation': metrics.get('consultation_revenue', 0),
            'insurance': metrics.get('insurance_revenue', 0),
            'other': metrics.get('other_revenue', 0)
        }
        
        # Create expense breakdown object
        metrics['expense_breakdown'] = {
            'payroll': metrics.get('payroll_expense', 0),
            'pharmacy': metrics.get('pharmacy_expense', 0),
            'equipment': metrics.get('equipment_expense', 0),
            'utilities': metrics.get('utilities_expense', 0),
            'debt': metrics.get('debt_payment', 0),
            'other': metrics.get('other_expense', 0)
        }
        
        # Add outstanding/debtor metrics with default values if missing
        metrics['outstanding_debtor'] = metrics.get('outstanding_debtor', 0)
        metrics['outstanding_debtor_count'] = metrics.get('outstanding_debtor_count', 0)
        metrics['outstanding_insurance'] = metrics.get('outstanding_insurance', 0)
        metrics['outstanding_insurance_count'] = metrics.get('outstanding_insurance_count', 0)
        
        # Save cashflow_breakdown before DictToObj conversion (needs .items() in template)
        cashflow_breakdown = metrics.get('cashflow_breakdown', {})
        
        # Store these values before converting to DictToObj
        # If custom date range is provided, use those dates; otherwise use metrics dates
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
        else:
            start_date = metrics.get('start_date')
            end_date = metrics.get('end_date')
        
        # Remove cashflow_breakdown from metrics before conversion
        metrics.pop('cashflow_breakdown', None)
        
        daily_breakdown = _get_daily_breakdown(start_date, end_date)
        metrics = DictToObj(metrics)
        
        return render_template('admin/_financial_dashboard_weekly_fragment.html', 
            metrics=metrics, cashflow_breakdown=cashflow_breakdown, target_date=target_date, 
            daily_breakdown=daily_breakdown, is_range=False, abs=abs)
    except Exception as e:
        app.logger.error(f"Error in weekly API: {str(e)}")
        return f'<div class="alert alert-danger">Error: {str(e)}</div>', 500


@app.route('/api/financial/dashboard/monthly', methods=['GET'])
@login_required
def api_financial_dashboard_monthly():
    """API endpoint to get monthly dashboard HTML"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        today = date.today()
        year = today.year
        month = today.month
        
        year_str = request.args.get('year')
        month_str = request.args.get('month')
        start_date_str = request.args.get('startDate')
        end_date_str = request.args.get('endDate')
        
        # Check if date range is provided
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            
            # Calculate number of months in range
            num_months = (end_date.year - start_date.year) * 12 + (end_date.month - start_date.month) + 1
            
            # Generate monthly metrics for all months in range
            monthly_data = []
            current_year = start_date.year
            current_month = start_date.month
            total_revenue = 0
            total_expense = 0
            total_profit = 0
            
            while (current_year, current_month) <= (end_date.year, end_date.month):
                m_metrics = get_monthly_financial_summary(current_year, current_month)
                monthly_data.append({
                    'year': current_year,
                    'month': current_month,
                    'month_name': datetime(current_year, current_month, 1).strftime('%B'),
                    'revenue': m_metrics.get('total_revenue', 0),
                    'expense': m_metrics.get('total_expense', 0),
                    'profit': m_metrics.get('net_profit', 0),
                    'margin': (m_metrics.get('net_profit', 0) / m_metrics.get('total_revenue', 1) * 100) if m_metrics.get('total_revenue', 0) > 0 else 0
                })
                total_revenue += m_metrics.get('total_revenue', 0)
                total_expense += m_metrics.get('total_expense', 0)
                total_profit += m_metrics.get('net_profit', 0)
                
                if current_month == 12:
                    current_year += 1
                    current_month = 1
                else:
                    current_month += 1
            
            # Calculate aggregated metrics
            metrics = {
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_profit': total_profit,
                'start_date': start_date,
                'end_date': end_date,
                'cashflow_breakdown': {'total': total_revenue},
                'profit_margin': (total_profit / total_revenue * 100) if total_revenue > 0 else 0,
                'revenue_change_pct': 0,
                'expense_change_pct': 0,
                'profit_change_pct': 0,
                'gross_profit': total_profit,
                'refunds': 0,
                'outstanding_debtor': 0,
                'outstanding_debtor_count': 0,
                'outstanding_insurance': 0,
                'outstanding_insurance_count': 0,
                'revenue_breakdown': {
                    'pharmacy': 0, 'lab': 0, 'imaging': 0, 'consultation': 0, 'insurance': 0, 'other': 0
                },
                'expense_breakdown': {
                    'payroll': 0, 'pharmacy': 0, 'equipment': 0, 'utilities': 0, 'debt': 0, 'other': 0
                }
            }
            
            # Ensure all required fields have default values
            metrics.setdefault('total_revenue', 0)
            metrics.setdefault('total_expense', 0)
            metrics.setdefault('net_profit', 0)
            metrics.setdefault('profit_margin', 0)
            metrics.setdefault('revenue_change_pct', 0)
            metrics.setdefault('expense_change_pct', 0)
            metrics.setdefault('profit_change_pct', 0)
            
            cashflow_breakdown = metrics.get('cashflow_breakdown', {})
            metrics.pop('cashflow_breakdown', None)
            metrics = DictToObj(metrics)
            
            # Create previous_metrics with default values for range mode
            previous_metrics = {
                'total_revenue': 0,
                'total_expense': 0,
                'net_profit': 0,
                'profit_margin': 0
            }
            previous_metrics = DictToObj(previous_metrics)
            
            return render_template('admin/_financial_dashboard_monthly_fragment.html', 
                metrics=metrics, cashflow_breakdown=cashflow_breakdown, year=year, month=month,
                is_range=True, date_range_label=f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", 
                monthly_data=monthly_data, num_months=num_months, previous_metrics=previous_metrics, 
                weekly_breakdown=[], budget_data=[], abs=abs)
        
        # Single month mode (existing behavior)
        elif year_str and month_str:
            year = int(year_str)
            month = int(month_str)
        
        metrics = get_monthly_financial_summary(year, month)
        
        if month == 1:
            prev_year, prev_month = year - 1, 12
        else:
            prev_year, prev_month = year, month - 1
        previous_metrics = get_monthly_financial_summary(prev_year, prev_month)
        
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Create revenue breakdown object
        metrics['revenue_breakdown'] = {
            'pharmacy': metrics.get('pharmacy_revenue', 0),
            'lab': metrics.get('lab_revenue', 0),
            'imaging': metrics.get('imaging_revenue', 0),
            'consultation': metrics.get('consultation_revenue', 0),
            'insurance': metrics.get('insurance_revenue', 0),
            'other': metrics.get('other_revenue', 0)
        }
        
        # Create expense breakdown object
        metrics['expense_breakdown'] = {
            'payroll': metrics.get('payroll_expense', 0),
            'pharmacy': metrics.get('pharmacy_expense', 0),
            'equipment': metrics.get('equipment_expense', 0),
            'utilities': metrics.get('utilities_expense', 0),
            'debt': metrics.get('debt_payment', 0),
            'other': metrics.get('other_expense', 0)
        }
        
        # Add outstanding/debtor metrics with default values if missing
        metrics['outstanding_debtor'] = metrics.get('outstanding_debtor', 0)
        metrics['outstanding_debtor_count'] = metrics.get('outstanding_debtor_count', 0)
        metrics['outstanding_insurance'] = metrics.get('outstanding_insurance', 0)
        metrics['outstanding_insurance_count'] = metrics.get('outstanding_insurance_count', 0)
        
        # Ensure all required fields exist with default values for template rendering
        # This prevents undefined format errors in Jinja2 templates
        metrics.setdefault('total_revenue', 0)
        metrics.setdefault('total_expense', 0)
        metrics.setdefault('net_profit', 0)
        metrics.setdefault('profit_margin', 0)
        metrics.setdefault('revenue_change_pct', 0)
        metrics.setdefault('expense_change_pct', 0)
        metrics.setdefault('profit_change_pct', 0)
        metrics.setdefault('gross_profit', 0)
        metrics.setdefault('refunds', 0)
        metrics.setdefault('start_date', date(year, month, 1))
        metrics.setdefault('end_date', date(year + 1, 1, 1) - timedelta(days=1) if month == 12 else date(year, month + 1, 1) - timedelta(days=1))
        
        # Create patient metrics object if it exists
        if 'patient_metrics' in metrics and isinstance(metrics['patient_metrics'], dict):
            metrics['patient_metrics'] = DictToObj(metrics['patient_metrics'])
        
        # Save cashflow_breakdown before DictToObj conversion (needs .items() in template)
        cashflow_breakdown = metrics.get('cashflow_breakdown', {})
        
        # Calculate start_date and end_date for single month mode
        start_date = date(year, month, 1)
        if month == 12:
            end_date = date(year + 1, 1, 1) - timedelta(days=1)
        else:
            end_date = date(year, month + 1, 1) - timedelta(days=1)
        
        # Remove cashflow_breakdown from metrics before conversion
        metrics.pop('cashflow_breakdown', None)
        
        # Ensure previous_metrics also has all required fields with default values
        previous_metrics.setdefault('total_revenue', 0)
        previous_metrics.setdefault('total_expense', 0)
        previous_metrics.setdefault('net_profit', 0)
        previous_metrics.setdefault('profit_margin', 0)
        
        # Convert previous_metrics to DictToObj as well
        previous_metrics = DictToObj(previous_metrics)
        
        weekly_breakdown = _get_weekly_breakdown(start_date, end_date)

        budget_variance = _get_budget_variance(year, month)
        budget_data = []
        if isinstance(budget_variance, dict):
            for row in (budget_variance.get('budgets') or []):
                if isinstance(row, dict):
                    budget_data.append({
                        'category': row.get('department', '') or '',
                        'budget': float(row.get('budgeted', 0) or 0),
                        'actual': float(row.get('actual', 0) or 0),
                        # Template renders this as a percentage.
                        'variance': float(row.get('variance_pct', 0) or 0),
                    })
        elif isinstance(budget_variance, list):
            budget_data = budget_variance
        
        # Convert weekly_breakdown items to DictToObj for template access
        weekly_breakdown = [DictToObj(week) for week in weekly_breakdown]
        
        metrics = DictToObj(metrics)
        
        return render_template('admin/_financial_dashboard_monthly_fragment.html', 
            metrics=metrics, cashflow_breakdown=cashflow_breakdown, year=year, month=month, 
            previous_metrics=previous_metrics,
            weekly_breakdown=weekly_breakdown,
            budget_data=budget_data,
            is_range=False,
            abs=abs)
    except Exception as e:
        app.logger.error(f"Error in monthly API: {str(e)}")
        return f'<div class="alert alert-danger">Error: {str(e)}</div>', 500


@app.route('/api/financial/dashboard/yearly', methods=['GET'])
@login_required
def api_financial_dashboard_yearly():
    """API endpoint to get yearly dashboard HTML"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        year = date.today().year
        
        year_str = request.args.get('year')
        start_date_str = request.args.get('startDate')
        end_date_str = request.args.get('endDate')
        
        # Check if date range is provided
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            
            # Calculate number of years in range
            num_years = end_date.year - start_date.year + 1
            
            # Generate yearly metrics for all years in range
            yearly_data = []
            total_revenue = 0
            total_expense = 0
            total_profit = 0
            
            for y in range(start_date.year, end_date.year + 1):
                y_metrics = get_yearly_financial_summary(y)
                yearly_data.append({
                    'year': y,
                    'revenue': y_metrics.get('total_revenue', 0),
                    'expense': y_metrics.get('total_expense', 0),
                    'profit': y_metrics.get('net_profit', 0),
                    'margin': (y_metrics.get('net_profit', 0) / y_metrics.get('total_revenue', 1) * 100) if y_metrics.get('total_revenue', 0) > 0 else 0
                })
                total_revenue += y_metrics.get('total_revenue', 0)
                total_expense += y_metrics.get('total_expense', 0)
                total_profit += y_metrics.get('net_profit', 0)
            
            # Calculate aggregated metrics
            metrics = {
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_profit': total_profit,
                'start_date': start_date,
                'end_date': end_date,
                'profit_margin': (total_profit / total_revenue * 100) if total_revenue > 0 else 0,
                'revenue_change_pct': 0,
                'expense_change_pct': 0,
                'profit_change_pct': 0,
                'outstanding_debtor': 0,
                'outstanding_debtor_count': 0,
                'outstanding_insurance': 0,
                'outstanding_insurance_count': 0,
                'revenue_breakdown': {
                    'pharmacy': 0, 'lab': 0, 'imaging': 0, 'consultation': 0, 'insurance': 0, 'other': 0
                },
                'expense_breakdown': {
                    'payroll': 0, 'pharmacy': 0, 'equipment': 0, 'utilities': 0, 'debt': 0, 'other': 0
                }
            }
            
            metrics = DictToObj(metrics)
            
            # Get monthly breakdown for the first year in range
            monthly_breakdown = _get_monthly_breakdown(start_date.year)
            
            return render_template('admin/_financial_dashboard_yearly_fragment.html', 
                metrics=metrics, year=start_date.year,
                is_range=True, date_range_label=f"{start_date.strftime('%Y-%m-%d')} to {end_date.strftime('%Y-%m-%d')}", 
                yearly_data=yearly_data, num_years=num_years, previous_metrics=DictToObj({}), 
                monthly_breakdown=monthly_breakdown, dept_performance=[], abs=abs)
        
        # Single year mode (existing behavior)
        elif year_str:
            year = int(year_str)
        
        metrics = get_yearly_financial_summary(year)
        previous_metrics = get_yearly_financial_summary(year - 1)
        
        metrics['revenue_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_revenue', 0),
            metrics.get('total_revenue', 0)
        )
        metrics['expense_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('total_expense', 0),
            metrics.get('total_expense', 0)
        )
        metrics['profit_change_pct'] = _calculate_percentage_change(
            previous_metrics.get('net_profit', 0),
            metrics.get('net_profit', 0)
        )
        
        # Create revenue breakdown object
        metrics['revenue_breakdown'] = {
            'pharmacy': metrics.get('pharmacy_revenue', 0),
            'lab': metrics.get('lab_revenue', 0),
            'imaging': metrics.get('imaging_revenue', 0),
            'consultation': metrics.get('consultation_revenue', 0),
            'insurance': metrics.get('insurance_revenue', 0),
            'other': metrics.get('other_revenue', 0)
        }
        
        # Create expense breakdown object
        metrics['expense_breakdown'] = {
            'payroll': metrics.get('payroll_expense', 0),
            'pharmacy': metrics.get('pharmacy_expense', 0),
            'equipment': metrics.get('equipment_expense', 0),
            'utilities': metrics.get('utilities_expense', 0),
            'debt': metrics.get('debt_payment', 0),
            'other': metrics.get('other_expense', 0)
        }
        
        # Add outstanding/debtor metrics with default values if missing
        metrics['outstanding_debtor'] = metrics.get('outstanding_debtor', 0)
        metrics['outstanding_debtor_count'] = metrics.get('outstanding_debtor_count', 0)
        metrics['outstanding_insurance'] = metrics.get('outstanding_insurance', 0)
        metrics['outstanding_insurance_count'] = metrics.get('outstanding_insurance_count', 0)
        
        # Store these values before converting to DictToObj
        # If custom date range is provided, use those dates; otherwise use metrics dates
        if start_date_str and end_date_str:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
        else:
            start_date = metrics.get('start_date')
            end_date = metrics.get('end_date')
        
        monthly_breakdown = _get_monthly_breakdown(year)
        dept_performance = _get_department_performance(start_date, end_date)
        
        # Convert both metrics and previous_metrics to DictToObj for consistent template access
        previous_metrics = DictToObj(previous_metrics)
        metrics = DictToObj(metrics)
        
        return render_template('admin/_financial_dashboard_yearly_fragment.html', 
            metrics=metrics, year=year,
            previous_metrics=previous_metrics,
            monthly_breakdown=monthly_breakdown,
            dept_performance=dept_performance,
            is_range=False,
            abs=abs)
    except Exception as e:
        app.logger.error(f"Error in yearly API: {str(e)}")
        return f'<div class="alert alert-danger">Error: {str(e)}</div>', 500


@app.route('/api/financial/dashboard/yearly/daily_breakdown', methods=['GET'])
@login_required
def api_financial_dashboard_yearly_daily_breakdown():
    """Return daily breakdown for a selected month in a year"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        year_str = request.args.get('year')
        month_str = request.args.get('month')
        if not year_str or not month_str:
            return jsonify({'daily': []})

        year = int(year_str)
        month = int(month_str)
        days_in_month = calendar.monthrange(year, month)[1]

        daily_rows = []
        for day in range(1, days_in_month + 1):
            target_date = date(year, month, day)
            metrics = get_daily_financial_summary(target_date)

            revenue_breakdown = {
                'pharmacy': metrics.get('pharmacy_revenue', 0),
                'lab': metrics.get('lab_revenue', 0),
                'imaging': metrics.get('imaging_revenue', 0),
                'consultation': metrics.get('consultation_revenue', 0),
                'insurance': metrics.get('insurance_revenue', 0),
                'other': metrics.get('other_revenue', 0)
            }

            expense_breakdown = {
                'payroll': metrics.get('payroll_expense', 0),
                'pharmacy': metrics.get('pharmacy_expense', 0),
                'equipment': metrics.get('equipment_expense', 0),
                'utilities': metrics.get('utilities_expense', 0),
                'debt': metrics.get('debt_payment', 0),
                'other': metrics.get('other_expense', 0)
            }

            total_revenue = metrics.get('total_revenue', 0)
            total_expense = metrics.get('total_expense', 0)
            net_profit = metrics.get('net_profit', 0)
            profit_margin = metrics.get('profit_margin', 0)

            daily_rows.append({
                'date': target_date.strftime('%Y-%m-%d'),
                'total_revenue': total_revenue,
                'total_expense': total_expense,
                'net_profit': net_profit,
                'profit_margin': profit_margin,
                'revenue_breakdown': revenue_breakdown,
                'expense_breakdown': expense_breakdown
            })

        return jsonify({'daily': daily_rows})
    except Exception as e:
        app.logger.error(f"Error in yearly daily breakdown API: {str(e)}")
        return jsonify({'daily': [], 'error': str(e)}), 500


@app.route('/api/financial/dashboard/yearly/export', methods=['GET'])
@login_required
def api_financial_dashboard_yearly_export():
    """Export yearly report as CSV (optionally filtered by month)"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        year = int(request.args.get('year', date.today().year))
        month_value = request.args.get('month', 'all')

        output = io.StringIO()
        writer = csv.writer(output)

        writer.writerow([f'Yearly Financial Report - {year}'])
        writer.writerow([])

        monthly_breakdown = _get_monthly_breakdown(year)
        writer.writerow(['Month', 'Revenue (KES)', 'Expense (KES)', 'Profit (KES)', 'Margin %'])
        for month in monthly_breakdown:
            writer.writerow([
                month.get('month_name') or month.get('month_abbr') or '',
                round(month.get('revenue', 0), 2),
                round(month.get('expense', 0), 2),
                round(month.get('profit', 0), 2),
                round(month.get('margin', 0), 2)
            ])

        if month_value and month_value != 'all':
            month = int(month_value)
            writer.writerow([])
            writer.writerow([f'Daily Breakdown - {calendar.month_name[month]} {year}'])
            writer.writerow(['Date', 'Total Income (KES)', 'Total Expense (KES)', 'Net Profit (KES)', 'Margin %'])

            days_in_month = calendar.monthrange(year, month)[1]
            for day in range(1, days_in_month + 1):
                target_date = date(year, month, day)
                metrics = get_daily_financial_summary(target_date)
                writer.writerow([
                    target_date.strftime('%Y-%m-%d'),
                    round(metrics.get('total_revenue', 0), 2),
                    round(metrics.get('total_expense', 0), 2),
                    round(metrics.get('net_profit', 0), 2),
                    round(metrics.get('profit_margin', 0), 2)
                ])

        output.seek(0)
        filename = f"yearly_report_{year}.csv" if month_value == 'all' else f"yearly_report_{year}_{month_value}.csv"
        return Response(
            output.getvalue(),
            mimetype='text/csv',
            headers={'Content-Disposition': f'attachment; filename={filename}'}
        )
    except Exception as e:
        app.logger.error(f"Error exporting yearly report: {str(e)}")
        return jsonify({'error': str(e)}), 500


# =================================================================================================
# FINANCIAL DASHBOARD HELPER FUNCTIONS
# =================================================================================================

def _calculate_percentage_change(old_value: float, new_value: float) -> float:
    """Calculate percentage change between two values"""
    try:
        if old_value == 0:
            return 100 if new_value > 0 else 0
        return ((new_value - old_value) / old_value) * 100
    except Exception:
        return 0


def _get_daily_breakdown(start_date: date, end_date: date) -> list:
    """Get daily metrics breakdown for a date range"""
    breakdown = []
    current = start_date
    while current <= end_date:
        metrics = get_daily_financial_summary(current)
        breakdown.append({
            'date': current,
            'revenue': metrics.get('total_revenue', 0),
            'expense': metrics.get('total_expense', 0),
            'profit': metrics.get('net_profit', 0)
        })
        current += timedelta(days=1)
    return breakdown


def _get_weekly_breakdown(start_date: date, end_date: date) -> list:
    """Get weekly metrics breakdown for a date range"""
    breakdown = []
    current = start_date
    while current <= end_date:
        week_start = current - timedelta(days=current.weekday())
        week_end = min(week_start + timedelta(days=6), end_date)
        metrics = get_financial_metrics(week_start, week_end, 'weekly')
        breakdown.append({
            'start_date': week_start,
            'end_date': week_end,
            'week_number': current.isocalendar()[1],
            'revenue': metrics.get('total_revenue', 0),
            'expense': metrics.get('total_expense', 0),
            'profit': metrics.get('net_profit', 0),
            'margin': (metrics.get('net_profit', 0) / metrics.get('total_revenue', 1) * 100) if metrics.get('total_revenue', 0) > 0 else 0
        })
        current = week_end + timedelta(days=1)
    return breakdown


def _get_monthly_breakdown(year: int) -> list:
    """Get monthly metrics breakdown for a year with detailed revenue and expense breakdowns"""
    breakdown = []
    for month in range(1, 13):
        metrics = get_monthly_financial_summary(year, month)
        month_name = datetime(year, month, 1).strftime('%B')
        month_abbr = datetime(year, month, 1).strftime('%b')
        total_revenue = metrics.get('total_revenue', 0)
        total_expense = metrics.get('total_expense', 0)
        
        breakdown.append({
            'month': month,
            'month_name': month_name,
            'month_abbr': month_abbr,
            'revenue': total_revenue,
            'expense': total_expense,
            'profit': metrics.get('net_profit', 0),
            'margin': (metrics.get('net_profit', 0) / total_revenue * 100) if total_revenue > 0 else 0,
            # Revenue breakdown by source (always present)
            'pharmacy_revenue': metrics.get('pharmacy_revenue', 0) if metrics.get('pharmacy_revenue') is not None else 0,
            'lab_revenue': metrics.get('lab_revenue', 0) if metrics.get('lab_revenue') is not None else 0,
            'imaging_revenue': metrics.get('imaging_revenue', 0) if metrics.get('imaging_revenue') is not None else 0,
            'consultation_revenue': metrics.get('consultation_revenue', 0) if metrics.get('consultation_revenue') is not None else 0,
            'insurance_revenue': metrics.get('insurance_revenue', 0) if metrics.get('insurance_revenue') is not None else 0,
            'other_revenue': metrics.get('other_revenue', 0) if metrics.get('other_revenue') is not None else 0,
            # Expense breakdown by category (always present)
            'payroll_expense': metrics.get('payroll_expense', 0) if metrics.get('payroll_expense') is not None else 0,
            'pharmacy_expense': metrics.get('pharmacy_expense', 0) if metrics.get('pharmacy_expense') is not None else 0,
            'equipment_expense': metrics.get('equipment_expense', 0) if metrics.get('equipment_expense') is not None else 0,
            'utilities_expense': metrics.get('utilities_expense', 0) if metrics.get('utilities_expense') is not None else 0,
            'debt_payment': metrics.get('debt_payment', 0) if metrics.get('debt_payment') is not None else 0,
            'other_expense': metrics.get('other_expense', 0) if metrics.get('other_expense') is not None else 0
        })
    return breakdown


def _get_budget_variance(year: int, month: int) -> dict:
    """Get budget vs actual variance data"""
    try:
        budget = DepartmentBudget.query.filter_by(
            fiscal_year=year
        ).all()
        
        budget_data = []
        for b in budget:
            budget_data.append({
                'department': b.department_name,
                'budgeted': float(b.budgeted_amount),
                'actual': float(b.actual_amount),
                'variance': float(b.variance),
                'variance_pct': float(b.variance_percentage)
            })
        
        return {
            'budgets': budget_data,
            'total_budgeted': sum(b['budgeted'] for b in budget_data),
            'total_actual': sum(b['actual'] for b in budget_data)
        }
    except Exception as e:
        app.logger.error(f"Error getting budget variance: {str(e)}")
        return {'budgets': [], 'total_budgeted': 0, 'total_actual': 0}


def _get_department_performance(start_date: date, end_date: date) -> dict:
    """Get department-wise revenue and expense performance"""
    try:
        dept_revenue = db.session.query(
            DepartmentRevenue.department,
            func.sum(DepartmentRevenue.revenue_amount).label('total_revenue')
        ).filter(
            DepartmentRevenue.metric_date >= start_date,
            DepartmentRevenue.metric_date <= end_date
        ).group_by(DepartmentRevenue.department).all()
        
        dept_expense = db.session.query(
            DepartmentExpense.department,
            func.sum(DepartmentExpense.expense_amount).label('total_expense')
        ).filter(
            DepartmentExpense.metric_date >= start_date,
            DepartmentExpense.metric_date <= end_date
        ).group_by(DepartmentExpense.department).all()
        
        departments = {}
        for dept, revenue in dept_revenue:
            departments[dept] = {'revenue': float(revenue or 0), 'expense': 0}
        
        for dept, expense in dept_expense:
            if dept not in departments:
                departments[dept] = {'revenue': 0, 'expense': 0}
            departments[dept]['expense'] = float(expense or 0)
        
        dept_perf = []
        for dept, data in departments.items():
            dept_perf.append({
                'department': dept,
                'revenue': data['revenue'],
                'expense': data['expense'],
                'profit': data['revenue'] - data['expense']
            })
        
        return dept_perf
    except Exception as e:
        app.logger.error(f"Error getting department performance: {str(e)}")
        return []


@app.route('/admin/employees/<int:employee_id>')
@login_required
def get_employee(employee_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    employee = db.session.get(Employee, employee_id)  # Fixed: use employee_id parameter
    if not employee:
        return jsonify({'error': 'Employee not found'}), 404
        
    return jsonify({
        'id': employee.id,
        'name': employee.name,
        'position': employee.position,
        'salary': employee.salary,
        'hire_date': employee.hire_date.strftime('%Y-%m-%d') if employee.hire_date else None,
        'contact': employee.contact,
        'user_id': employee.user_id
    })

@app.route('/admin/reports', methods=['GET', 'POST'])
@login_required
def admin_reports():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    drug_report = None
    service_report = None
    start_date = None
    end_date = None
    
    if request.method == 'POST':
        start_date_str = request.form.get('start_date')
        end_date_str = request.form.get('end_date')
        report_type = request.form.get('report_type')
        
        try:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()
            
            if start_date > end_date:
                flash('Start date cannot be after end date', 'danger')
                return redirect(url_for('admin_reports'))
            
            if report_type == 'drug_sales':
                # Generate drug sales report
                drug_sales = db.session.query(
                    SaleItem.drug_name,
                    func.sum(SaleItem.quantity).label('total_units'),
                    func.sum(SaleItem.total_price).label('total_amount'),
                    func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity).label('total_profit')
                ).join(
                    Drug, SaleItem.drug_id == Drug.id
                ).join(
                    Sale, SaleItem.sale_id == Sale.id
                ).filter(
                    Sale.created_at >= start_date,
                    Sale.created_at <= end_date + timedelta(days=1),
                    SaleItem.drug_id.isnot(None)
                ).group_by(
                    SaleItem.drug_name
                ).order_by(
                    SaleItem.drug_name
                ).all()
                
                # Calculate totals
                total_sales = sum(sale.total_amount for sale in drug_sales)
                total_profit = sum(sale.total_profit for sale in drug_sales)
                
                drug_report = {
                    'sales': drug_sales,
                    'total_sales': total_sales,
                    'total_profit': total_profit,
                    'start_date': start_date,
                    'end_date': end_date
                }
                
            elif report_type == 'patient_services':
                # Generate patient service report
                service_data = db.session.query(
                    PatientService.service_id,
                    Service.name,
                    func.count(PatientService.id).label('total_services'),
                    func.sum(Service.price).label('total_amount')
                ).join(
                    Service, PatientService.service_id == Service.id
                ).filter(
                    PatientService.created_at >= start_date,
                    PatientService.created_at <= end_date + timedelta(days=1)
                ).group_by(
                    PatientService.service_id,
                    Service.name
                ).order_by(
                    Service.name
                ).all()
                
                # Calculate totals
                total_services = sum(service.total_services for service in service_data)
                total_amount = sum(service.total_amount for service in service_data)
                
                service_report = {
                    'services': service_data,
                    'total_services': total_services,
                    'total_amount': total_amount,
                    'start_date': start_date,
                    'end_date': end_date
                }
                
        except ValueError:
            flash('Invalid date format', 'danger')
    
    return render_template('admin/reports.html',
        drug_report=drug_report,
        service_report=service_report,
        start_date=start_date,
        end_date=end_date
    )

# ==================== REPORTING HELPER FUNCTIONS ====================

def log_report_access(report_type, filters, data_count=0, status='success', error_msg=None):
    """Log report generation for audit trail compliance"""
    try:
        audit_log = ReportAuditLog(
            user_id=current_user.id,
            report_type=report_type,
            filters=filters,
            data_count=data_count,
            ip_address=request.remote_addr,
            status=status,
            error_message=error_msg
        )
        db.session.add(audit_log)
        db.session.commit()
    except Exception as e:
        app.logger.error(f'Failed to log report access: {str(e)}')


def log_audit_event(action, table_name=None, record_id=None, description=None, 
                     old_values=None, new_values=None, changes=None):
    """Log audit event for data modification tracking"""
    try:
        audit_log = AuditLog(
            user_id=current_user.id,
            action=action,
            table_name=table_name,
            record_id=record_id,
            description=description,
            old_values=old_values,
            new_values=new_values,
            changes=changes,
            ip_address=request.remote_addr
        )
        db.session.add(audit_log)
        db.session.commit()
    except Exception as e:
        app.logger.error(f'Failed to log audit event: {str(e)}')


def validate_report_data(data_dict):
    """Validate report output for data quality"""
    issues = []
    
    # Check for null values in critical fields
    if data_dict.get('totals'):
        totals = data_dict['totals']
        for key in ['sales_total', 'cogs', 'expenses', 'estimated_profit']:
            if key not in totals or totals[key] is None:
                issues.append(f"Missing or null {key} in totals")
    
    # Verify logical relationships
    if data_dict.get('totals'):
        sales = data_dict['totals'].get('sales_total', 0)
        cogs = data_dict['totals'].get('cogs', 0)
        expenses = data_dict['totals'].get('expenses', 0)
        profit = data_dict['totals'].get('estimated_profit', 0)
        
        # Profit should equal sales - cogs - expenses (with small tolerance for rounding)
        calculated_profit = sales - cogs - expenses


def _parse_year_month(value: str | None):
    if not value:
        return None
    v = str(value).strip()
    try:
        return datetime.strptime(v, '%Y-%m').date().replace(day=1)
    except Exception:
        return None


def _month_bounds(month_first_day: 'date'):
    if not month_first_day:
        return None, None
    start = month_first_day.replace(day=1)
    # next month
    if start.month == 12:
        next_month = date(start.year + 1, 1, 1)
    else:
        next_month = date(start.year, start.month + 1, 1)
    end = next_month - timedelta(days=1)
    return start, end


def _dt_range_for_dates(start_d: 'date', end_d: 'date'):
    if not start_d or not end_d:
        return None, None
    try:
        start_dt = datetime(start_d.year, start_d.month, start_d.day, 0, 0, 0, tzinfo=EAT)
    except Exception:
        start_dt = datetime.combine(start_d, datetime.min.time())
    # End is exclusive
    try:
        end_excl = datetime(end_d.year, end_d.month, end_d.day, 0, 0, 0, tzinfo=EAT) + timedelta(days=1)
    except Exception:
        end_excl = datetime.combine(end_d, datetime.min.time()) + timedelta(days=1)
    return start_dt, end_excl


def _outflow_transaction_types():
    # Legacy fallbacks when direction/status/department aren't populated.
    return ['expense', 'purchase', 'drawing', 'refund', 'debt_payment']


def _sum_outflows_by_department(start_dt: 'datetime', end_dt: 'datetime') -> dict:
    if not start_dt or not end_dt:
        return {}

    try:
        q = db.session.query(Transaction.department, func.sum(Transaction.amount))
        q = q.filter(Transaction.created_at >= start_dt, Transaction.created_at < end_dt)

        if _transaction_supports_metadata():
            # Prefer direction='OUT'. Allow legacy rows with null direction but recognizable types.
            out_types = _outflow_transaction_types()
            q = q.filter(
                db.or_(
                    Transaction.direction == 'OUT',
                    db.and_(Transaction.direction.is_(None), Transaction.transaction_type.in_(out_types)),
                )
            )
            q = q.filter(db.or_(Transaction.status.is_(None), Transaction.status == 'posted'))
        else:
            q = q.filter(Transaction.transaction_type.in_(_outflow_transaction_types()))

        q = q.group_by(Transaction.department)
        rows = q.all() or []
        out = {}
        for dept, total in rows:
            key = (dept or '').strip() or 'unassigned'
            out[key] = float(total or 0)
        return out
    except Exception:
        return {}
        if abs(profit - calculated_profit) > 1:  # Allow 1 unit rounding error
            issues.append(f"Profit calculation mismatch: expected {calculated_profit}, got {profit}")
        
        # COGS should never exceed sales
        if cogs > sales:
            issues.append(f"COGS ({cogs}) exceeds Sales ({sales})")
    
    return issues


def _budget_enforcement_mode() -> str:
    """Returns budget enforcement mode: warn (default), block, or off."""
    try:
        mode = (current_app.config.get('BUDGET_ENFORCEMENT_MODE') or '').strip().lower()
    except Exception:
        mode = ''
    if not mode:
        try:
            mode = (os.getenv('BUDGET_ENFORCEMENT_MODE', 'warn') or 'warn').strip().lower()
        except Exception:
            mode = 'warn'
    if mode not in ('warn', 'block', 'off'):
        mode = 'warn'
    return mode


def _notify_budget_issue_best_effort(dept: str, status: str, month_str: str, budget_month: float, projected_month: float, created_after: Optional['datetime'] = None):
    """Best-effort admin notification for budget warnings/exceedances."""
    try:
        admins = User.query.filter(User.role == 'admin').all()
        if not admins:
            return

        title = f"Budget {status}: {dept} ({month_str})"
        message = f"Projected spend {round(projected_month, 2)} / {round(budget_month, 2)} for {month_str}."

        for admin_user in admins:
            q = Notification.query.filter(
                Notification.user_id == admin_user.id,
                Notification.title == title,
            )
            if created_after is not None:
                q = q.filter(Notification.created_at >= created_after)
            if q.first():
                continue
            db.session.add(Notification(
                user_id=admin_user.id,
                title=title,
                message=message,
                is_read=False,
                created_at=get_eat_now(),
            ))
        db.session.flush()
    except Exception:
        pass


def _budget_check_outflow(department: str | None, amount: float, when_dt: Optional['datetime'] = None) -> dict | None:
    """Checks current month budget status for an outgoing payment.

    Returns a dict with status and optional block recommendation, or None if budgets are not configured.
    """
    try:
        mode = _budget_enforcement_mode()
        if mode == 'off':
            return None

        dept = (department or '').strip() or 'unassigned'
        amt = float(amount or 0)
        if amt <= 0:
            return None

        when_dt = when_dt or get_eat_now()
        month_first = date(int(when_dt.year), int(when_dt.month), 1)
        month_str = month_first.strftime('%Y-%m')
        start_d, end_d = _month_bounds(month_first)
        start_dt, end_excl = _dt_range_for_dates(start_d, end_d)
        spend_by_dept = _sum_outflows_by_department(start_dt, end_excl)

        budget = db.session.query(DepartmentBudget).filter(
            DepartmentBudget.fiscal_year == int(when_dt.year),
            DepartmentBudget.department_name == dept,
        ).first()
        if not budget:
            return None

        budget_year = float(budget.budgeted_amount or 0)
        budget_month = float((budget_year / 12.0) if budget_year else 0.0)
        if budget_month <= 0:
            return None

        actual_month = float((spend_by_dept or {}).get(dept, 0.0))
        projected_month = actual_month + amt
        ratio = projected_month / budget_month

        warning_ratio = 0.80
        if ratio >= 1.0:
            status = 'EXCEEDED'
        elif ratio >= warning_ratio:
            status = 'WARNING'
        else:
            status = 'OK'

        message = None
        if status in ('WARNING', 'EXCEEDED'):
            message = f"{dept} budget {status.lower()} for {month_str}. Projected {projected_month:.2f} / {budget_month:.2f}."
            _notify_budget_issue_best_effort(dept, status, month_str, budget_month, projected_month, created_after=start_dt)

        return {
            'mode': mode,
            'department': dept,
            'month': month_str,
            'budget_month': budget_month,
            'actual_month': actual_month,
            'projected_month': projected_month,
            'ratio': ratio,
            'status': status,
            'message': message,
            'block': bool(mode == 'block' and status == 'EXCEEDED'),
        }
    except Exception:
        return None


def calculate_trend_metrics(current_data, previous_data):
    """Calculate growth rates and trend indicators"""
    trends = {}
    
    for key in current_data.get('totals', {}):
        current_val = current_data['totals'].get(key, 0)
        previous_val = previous_data['totals'].get(key, 0) if previous_data else 0
        
        if previous_val != 0:
            growth_rate = ((current_val - previous_val) / abs(previous_val)) * 100
            trends[f'{key}_growth'] = round(growth_rate, 2)
            trends[f'{key}_growth_arrow'] = '↑' if growth_rate > 0 else '↓' if growth_rate < 0 else '→'
        else:
            trends[f'{key}_growth'] = None if current_val == 0 else 100
            trends[f'{key}_growth_arrow'] = '→' if current_val == 0 else '↑'
    
    return trends


def format_financial_metrics(totals):
    """Calculate and format additional financial metrics"""
    sales = totals.get('sales_total', 0)
    cogs = totals.get('cogs', 0)
    expenses = totals.get('expenses', 0)
    profit = totals.get('estimated_profit', 0)
    
    metrics = {
        'sales_total': float(sales),
        'cogs': float(cogs),
        'expenses': float(expenses),
        'estimated_profit': float(profit),
        'gross_profit': float(sales - cogs),
        'gross_margin_pct': (((sales - cogs) / sales) * 100) if sales > 0 else 0,
        'operating_margin_pct': ((profit / sales) * 100) if sales > 0 else 0,
        'cogs_pct': ((cogs / sales) * 100) if sales > 0 else 0,
        'expense_pct': ((expenses / sales) * 100) if sales > 0 else 0,
    }
    
    return metrics

# ==================== END REPORTING HELPERS ====================

@app.route('/admin/reports/generate', methods=['GET'])
@login_required
def generate_reports():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    # Get parameters (default to drug_sales if not specified)
    report_type = request.args.get('type', 'drug_sales')
    # Accept legacy report type names from older UI
    if report_type == 'patient_services':
        report_type = 'lab_reports'
    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')
    
    # Validate required parameters
    if not start_date_str or not end_date_str:
        return jsonify({'error': 'Both start and end dates are required'}), 400
    
    try:
        # Parse dates
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date() + timedelta(days=1)
        
        if start_date > end_date:
            return jsonify({'error': 'Start date must be before end date'}), 400
    
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD'}), 400
    
    # Reporting granularity
    granularity = request.args.get('granularity', 'daily')  # daily, weekly, monthly, yearly

    # Use datetime windows for DateTime columns to avoid DB-specific date casting / timezone edge cases.
    start_dt = datetime.combine(start_date, datetime.min.time())
    end_dt = datetime.combine(end_date, datetime.min.time())

    # For display breakdown:
    # - weekly: show daily points
    # - monthly: show weekly points
    # - yearly: show monthly points
    # - daily: show daily points
    def _effective_bucket_granularity(gran: str) -> str:
        g = (gran or 'daily').lower()
        if g == 'weekly':
            return 'daily'
        if g == 'monthly':
            return 'weekly'
        if g == 'yearly':
            return 'monthly'
        return 'daily'

    effective_granularity = _effective_bucket_granularity(granularity)

    # Precompute totals and expenses used across reports
    total_sales = db.session.query(func.coalesce(func.sum(Sale.total_amount), 0)).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed'
    ).scalar() or 0

    cogs = db.session.query(func.coalesce(func.sum(SaleItem.quantity * Drug.buying_price), 0)).join(Drug).join(Sale).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    # Profit for drug sales is calculated as: Total Sales Revenue - Cost of Goods Sold (COGS)
    # Expenses are tracked separately and not deducted from drug profit
    estimated_profit = float(total_sales) - float(cogs)

    if report_type == 'drug_sales':
        # Drug sales report logic (legacy simple path)
        drugs = db.session.query(
            Drug.name,
            func.sum(SaleItem.quantity).label('units_sold'),
            func.sum(SaleItem.total_price).label('total_sales'),
            func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity).label('profit')
        ).join(SaleItem).join(Sale).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).group_by(Drug.name).all()

        # Build timeseries by day, then bucket according to granularity in Python
        date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('units')
        ).join(SaleItem).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.drug_id.isnot(None)
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        # Convert rows to dict by date
        daily = {}
        for r in date_rows:
            daily[str(r.d)] = {'amount': float(r.amount or 0), 'units': int(r.units or 0)}

        # Helper to bucket dates
        def bucket_dates(daily_dict, gran):
            from datetime import datetime as _dt
            buckets = {}
            for ds, vals in daily_dict.items():
                dt = _dt.strptime(ds, '%Y-%m-%d').date()
                if gran == 'weekly':
                    # ISO week-year key
                    key = f"{dt.isocalendar()[0]}-W{dt.isocalendar()[1]:02d}"
                    label = key
                elif gran == 'monthly':
                    key = f"{dt.year}-{dt.month:02d}"
                    label = key
                elif gran == 'yearly':
                    key = f"{dt.year}"
                    label = key
                else:
                    key = ds
                    label = ds

                if key not in buckets:
                    buckets[key] = {'label': label, 'amount': 0.0, 'units': 0}
                buckets[key]['amount'] += vals['amount']
                buckets[key]['units'] += vals['units']

            # Order buckets by key (for time order keys are sortable strings)
            ordered = [buckets[k] for k in sorted(buckets.keys())]
            labels = [x['label'] for x in ordered]
            amounts = [x['amount'] for x in ordered]
            units = [x['units'] for x in ordered]
            return labels, amounts, units

        # Daily series for line chart (always show day-by-day)
        daily_keys = sorted(daily.keys())
        daily_labels = daily_keys
        daily_amounts = [daily[k]['amount'] for k in daily_keys]
        daily_units = [daily[k]['units'] for k in daily_keys]

        # Bucketed series for the selected breakdown level
        labels, amounts, units = bucket_dates(daily, effective_granularity)
        
        # Get Top 10 Most Sold Drugs (Daily, Weekly, Monthly, Yearly) with amounts and percentages
        def get_top_10_drugs(start_dt, end_dt, gran='daily'):
            try:
                top_drugs = db.session.query(
                    Drug.name,
                    func.sum(SaleItem.quantity).label('total_units'),
                    func.sum(SaleItem.total_price).label('total_amount'),
                    func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity).label('profit')
                ).join(SaleItem, Drug.id == SaleItem.drug_id).join(Sale, SaleItem.sale_id == Sale.id).filter(
                    Sale.created_at >= start_dt,
                    Sale.created_at < end_dt,
                    Sale.status == 'completed',
                    SaleItem.drug_id.isnot(None)
                ).group_by(Drug.name).order_by(func.sum(SaleItem.quantity).desc()).limit(10).all()
                
                # Calculate total for percentage calculations
                total_units = sum(int(d.total_units or 0) for d in top_drugs)
                total_amount = sum(float(d.total_amount or 0) for d in top_drugs)
                total_profit = sum(float(d.profit or 0) for d in top_drugs)
                
                return {
                    'labels': [d.name[:20] for d in top_drugs],
                    'units': [int(d.total_units or 0) for d in top_drugs],
                    'amounts': [float(d.total_amount or 0) for d in top_drugs],
                    'profits': [float(d.profit or 0) for d in top_drugs],
                    'percentages': [round((int(d.total_units or 0) / total_units * 100) if total_units > 0 else 0, 2) for d in top_drugs],
                    'total_units': total_units,
                    'total_amount': total_amount,
                    'total_profit': total_profit
                }
            except Exception as e:
                app.logger.error(f"Error getting top 10 drugs: {str(e)}")
                return {
                    'labels': [],
                    'units': [],
                    'amounts': [],
                    'profits': [],
                    'percentages': [],
                    'total_units': 0,
                    'total_amount': 0,
                    'total_profit': 0
                }

        # Calculate top 10 for different granularities including yearly
        def _as_dt(d):
            return datetime.combine(d, datetime.min.time())

        # Primary Top 10: always for the selected period
        top10_current = get_top_10_drugs(start_dt, end_dt, 'period')

        if granularity == 'daily':
            top10_daily = get_top_10_drugs(_as_dt(start_date), end_dt, 'daily')
            top10_weekly = get_top_10_drugs(_as_dt(start_date - timedelta(days=7)), end_dt, 'weekly')
            top10_monthly = get_top_10_drugs(_as_dt(start_date - timedelta(days=30)), end_dt, 'monthly')
            top10_yearly = get_top_10_drugs(_as_dt(start_date - timedelta(days=365)), end_dt, 'yearly')
        elif granularity == 'weekly':
            top10_daily = get_top_10_drugs(_as_dt(start_date), end_dt, 'daily')
            top10_weekly = get_top_10_drugs(_as_dt(start_date - timedelta(days=14)), end_dt, 'weekly')
            top10_monthly = get_top_10_drugs(_as_dt(start_date - timedelta(days=60)), end_dt, 'monthly')
            top10_yearly = get_top_10_drugs(_as_dt(start_date - timedelta(days=365)), end_dt, 'yearly')
        elif granularity == 'monthly':
            top10_daily = get_top_10_drugs(_as_dt(start_date - timedelta(days=1)), end_dt, 'daily')
            top10_weekly = get_top_10_drugs(_as_dt(start_date - timedelta(days=7)), end_dt, 'weekly')
            top10_monthly = get_top_10_drugs(_as_dt(start_date - timedelta(days=90)), end_dt, 'monthly')
            top10_yearly = get_top_10_drugs(_as_dt(start_date - timedelta(days=365)), end_dt, 'yearly')
        else:  # yearly
            top10_daily = get_top_10_drugs(_as_dt(start_date - timedelta(days=1)), end_dt, 'daily')
            top10_weekly = get_top_10_drugs(_as_dt(start_date - timedelta(days=7)), end_dt, 'weekly')
            top10_monthly = get_top_10_drugs(_as_dt(start_date - timedelta(days=30)), end_dt, 'monthly')
            top10_yearly = get_top_10_drugs(_as_dt(start_date - timedelta(days=365)), end_dt, 'yearly')

        # Get Patient vs Over-the-Counter Sales
        # Patient sales: transactions linked to IP or OP patient numbers
        patient_sales_data = db.session.query(
            func.coalesce(func.sum(Sale.total_amount), 0).label('patient_amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('patient_units')
        ).join(SaleItem, Sale.id == SaleItem.sale_id).outerjoin(Patient, Sale.patient_id == Patient.id).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.drug_id.isnot(None),
            ((Patient.ip_number.isnot(None)) | (Patient.op_number.isnot(None)))
        ).first()

        # Over-the-counter: transactions without patient link (walking customers)
        overcounter_sales_data = db.session.query(
            func.coalesce(func.sum(Sale.total_amount), 0).label('overcounter_amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('overcounter_units')
        ).join(SaleItem, Sale.id == SaleItem.sale_id).outerjoin(Patient, Sale.patient_id == Patient.id).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.drug_id.isnot(None),
            Sale.patient_id.is_(None)
        ).first()

        # Receipts list for the selected period
        sales_rows = db.session.query(Sale).options(db.joinedload(Sale.patient)).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).order_by(Sale.created_at.desc()).all()

        tx_by_sale_id = {}
        try:
            sale_ids = [s.id for s in sales_rows]
            if sale_ids:
                tx_q = Transaction.query.filter(
                    Transaction.transaction_type == 'sale',
                    Transaction.reference_id.in_(sale_ids),
                )
                if _transaction_supports_metadata():
                    tx_q = tx_q.filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'sales'))
                tx_rows = tx_q.order_by(Transaction.reference_id.asc(), Transaction.created_at.desc()).all()
                for tx in tx_rows:
                    if tx.reference_id not in tx_by_sale_id:
                        tx_by_sale_id[tx.reference_id] = tx
        except Exception:
            tx_by_sale_id = {}

        receipts = []
        for s in sales_rows:
            patient_name = None
            patient_phone = None
            try:
                if s.patient:
                    patient_name = (s.patient.name or '').strip() or None
                    patient_phone = (s.patient.phone or '').strip() or None
            except Exception:
                patient_name = None
                patient_phone = None

            tx = tx_by_sale_id.get(s.id)
            receipt_url = url_for('admin_transaction_receipt', transaction_id=tx.id) if tx else None

            # Back-compat alias: some older snippets used `sale` in this loop.
            sale = s
            pdf_url = url_for('api_sale_receipt_pdf', sale_id=sale.id) if 'api_sale_receipt_pdf' in current_app.view_functions else f"/api/sales/{sale.id}/receipt.pdf"

            receipts.append({
                'sale_id': s.id,
                'sale_number': s.sale_number,
                'created_at': s.created_at.strftime('%Y-%m-%d %H:%M') if s.created_at else '',
                'pharmacist_name': s.pharmacist_name,
                'pdf_url': pdf_url,
                'total_amount': float(s.total_amount or 0),
                'patient_name': patient_name,
                'customer_name': patient_name,
                'customer_phone': patient_phone,
                'receipt_url': receipt_url,
            })

        patient_amount = float(patient_sales_data.patient_amount or 0) if patient_sales_data else 0
        patient_units = int(patient_sales_data.patient_units or 0) if patient_sales_data else 0
        overcounter_amount = float(overcounter_sales_data.overcounter_amount or 0) if overcounter_sales_data else 0
        overcounter_units = int(overcounter_sales_data.overcounter_units or 0) if overcounter_sales_data else 0
        
        # Build response
        totals = {
            'sales_total': float(total_sales),
            'cogs': float(cogs),
            'estimated_profit': float(estimated_profit)
        }
        
        response_data = {
            'status': 'success',
            'report_type': 'drug_sales',
            'granularity': granularity,
            'start_date': start_date_str,
            'end_date': end_date_str,
            'effective_granularity': effective_granularity,
            'data': [{
                'name': d.name,
                'units_sold': int(d.units_sold or 0),
                'total_sales': float(d.total_sales or 0),
                'profit': float(d.profit or 0)
            } for d in drugs],
            'receipts': receipts,
            'charts': {
                'labels': labels,
                'amounts': amounts,
                'units': units,
                'daily_labels': daily_labels,
                'daily_amounts': daily_amounts,
                'daily_units': daily_units,
                'totals': totals,
                'top10_current': top10_current,
                'top10_daily': top10_daily,
                'top10_weekly': top10_weekly,
                'top10_monthly': top10_monthly,
                'top10_yearly': top10_yearly,
                'patient_sales': patient_amount,
                'patient_units': patient_units,
                'patient_percentage': round((patient_amount / total_sales * 100) if total_sales > 0 else 0, 2),
                'overcounter_sales': overcounter_amount,
                'overcounter_units': overcounter_units,
                'overcounter_percentage': round((overcounter_amount / total_sales * 100) if total_sales > 0 else 0, 2)
            },
            'metrics': format_financial_metrics(totals)
        }
        
        # Validate data quality
        issues = validate_report_data(response_data)
        if issues:
            response_data['data_quality_issues'] = issues
        
        # Log report access for audit trail
        log_report_access(
            report_type='drug_sales',
            filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity},
            data_count=len(drugs),
            status='success'
        )

        return jsonify(response_data)

# ==================== PAYROLL ROUTES ====================
@app.route('/admin/payroll')
@login_required
def payroll_list():
    if current_user.role != 'admin':
        abort(403)
    payrolls = Payroll.query.order_by(Payroll.pay_period.desc()).all()
    return render_template('admin/payroll_list.html', payrolls=payrolls)

@app.route('/admin/payroll/create', methods=['GET', 'POST'])
@login_required
def create_payroll():
    if current_user.role != 'admin':
        abort(403)
    
    employees = Employee.query.order_by(Employee.name).all()
    
    if request.method == 'POST':
        employee_id = request.form.get('employee_id')
        pay_period = request.form.get('pay_period')
        amount = request.form.get('amount')
        notes = request.form.get('notes')
        
        if not all([employee_id, pay_period, amount]):
            flash('Please fill all required fields.', 'danger')
            return render_template('admin/create_edit_payroll.html', employees=employees)
            
        try:
            payroll = Payroll(
                employee_id=employee_id,
                pay_period=datetime.strptime(pay_period, '%Y-%m-%d').date(),
                amount=float(amount),
                notes=notes,
                status='pending'
            )
            db.session.add(payroll)
            db.session.commit()
            flash('Payroll created successfully.', 'success')
            return redirect(url_for('payroll_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Error creating payroll: {str(e)}', 'danger')
            
    return render_template('admin/create_edit_payroll.html', employees=employees)

@app.route('/admin/payroll/<int:payroll_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_payroll(payroll_id):
    if current_user.role != 'admin':
        abort(403)
    
    payroll = _db_get_or_404(Payroll, payroll_id)
    employees = Employee.query.order_by(Employee.name).all()
    
    if request.method == 'POST':
        payroll.employee_id = request.form.get('employee_id')
        payroll.pay_period = datetime.strptime(request.form.get('pay_period'), '%Y-%m-%d').date()
        payroll.amount = float(request.form.get('amount'))
        payroll.notes = request.form.get('notes')
        payroll.status = request.form.get('status')
        
        try:
            db.session.commit()
            flash('Payroll updated successfully.', 'success')
            return redirect(url_for('payroll_list'))
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating payroll: {str(e)}', 'danger')
            
    return render_template('admin/create_edit_payroll.html', payroll=payroll, employees=employees)

@app.route('/admin/payroll/<int:payroll_id>')
@login_required
def view_payroll(payroll_id):
    if current_user.role != 'admin':
        abort(403)
    payroll = _db_get_or_404(Payroll, payroll_id)
    return render_template('admin/view_payroll.html', payroll=payroll)

@app.route('/admin/payroll/<int:payroll_id>/delete', methods=['POST'])
@login_required
def delete_payroll(payroll_id):
    if current_user.role != 'admin':
        # Detect AJAX request
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        abort(403)
    payroll = _db_get_or_404(Payroll, payroll_id)
    try:
        db.session.delete(payroll)
        db.session.commit()
        
        # Return JSON for AJAX requests
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': True, 'message': 'Payroll deleted successfully'})
        
        flash('Payroll deleted successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        error_msg = f'Error deleting payroll: {str(e)}'
        
        # Return JSON for AJAX requests
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': error_msg}), 500
        
        flash(error_msg, 'danger')
    return redirect(url_for('payroll_list'))

@app.route('/admin/payroll/<int:payroll_id>/make_payment', methods=['POST'])
@login_required
def make_payroll_payment(payroll_id):
    payroll = _db_get_or_404(Payroll, payroll_id)
    payment_amount = float(request.form.get('amount', 0) or 0)
    payment_date = request.form.get('payment_date')
    payment_method = (request.form.get('payment_method') or '').strip() or None
    notes = request.form.get('notes', '')

    try:
        if payment_amount <= 0:
            flash('Payment amount must be positive.', 'danger')
            return redirect(url_for('view_payroll', payroll_id=payroll_id))

        # Calculate remaining balance
        try:
            total_paid_before = sum(float(p.amount or 0) for p in (payroll.payments or []))
        except Exception:
            total_paid_before = 0.0
        remaining = float(payroll.amount or 0) - float(total_paid_before or 0)
        if payment_amount > remaining + 0.0001:
            flash(f'Payment amount exceeds remaining balance (Ksh {remaining:.2f}).', 'danger')
            return redirect(url_for('view_payroll', payroll_id=payroll_id))

        # Parse payment date (YYYY-MM-DD) when provided
        payment_dt = get_eat_now()
        if payment_date:
            try:
                pd = datetime.strptime(payment_date, '%Y-%m-%d')
                payment_dt = datetime(pd.year, pd.month, pd.day, tzinfo=EAT)
            except Exception:
                payment_dt = get_eat_now()

        # Budget enforcement (warn-only by default)
        try:
            budget_check = _budget_check_outflow('admin', float(payment_amount or 0), when_dt=payment_dt)
            if budget_check and budget_check.get('block'):
                flash(budget_check.get('message') or 'Budget exceeded for this month.', 'danger')
                return redirect(url_for('view_payroll', payroll_id=payroll_id))
        except Exception:
            pass

        payment = PayrollPayment(
            payroll_id=payroll.id,
            amount=payment_amount,
            paid_by=current_user.id,
            payment_date=payment_dt,
            notes=notes
        )
        db.session.add(payment)
        db.session.flush()

        # Golden rule: every payroll payment must post to Transaction
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=payment_amount,
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Payroll payment for {payroll.payroll_number}: {notes}",
            created_at=get_eat_now(),
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='payroll_payments',
            direction='OUT',
            status='posted',
            department='admin',
            category='payroll',
            payment_method=payment_method,
        )
        db.session.add(transaction)

        try:
            employee = _db_get(Employee, payroll.employee_id) if getattr(payroll, 'employee_id', None) else None
            employee_name = getattr(employee, 'name', None) if employee else None
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Payroll Payment Receipt</h2>",
                f"<div><strong>Payroll:</strong> {escape(str(payroll.payroll_number))}</div>",
                (f"<div><strong>Employee:</strong> {escape(str(employee_name))}</div>" if employee_name else ""),
                f"<div><strong>Amount:</strong> {escape(_money(payment_amount))}</div>",
                f"<div><strong>Date:</strong> {escape(payment_dt.strftime('%Y-%m-%d %H:%M'))}</div>",
                (f"<div><strong>Payment Method:</strong> {escape(str(payment_method))}</div>" if payment_method else ""),
                (f"<div><strong>Notes:</strong> {escape(str(notes))}</div>" if notes else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='PAY', force=True)
        except Exception:
            pass

        # Update payroll status if fully paid
        total_paid_after = float(total_paid_before) + float(payment_amount)
        if total_paid_after >= float(payroll.amount or 0) - 0.005:
            payroll.status = 'paid'

        db.session.commit()
        flash('Payment made successfully.', 'success')

        # Log audit event (best-effort; keep payment+transaction atomic above)
        try:
            log_audit_event(
                action='make_payroll_payment',
                table_name='payroll_payments',
                record_id=payment.id,
                description=f"Made payroll payment of {payment.amount} for payroll {payroll.payroll_number}",
                new_values={
                    'payroll_payment_id': payment.id,
                    'payroll_id': payroll.id,
                    'amount': payment.amount
                }
            )
        except Exception:
            pass
    except Exception as e:
        db.session.rollback()
        flash(f'Error making payment: {str(e)}', 'danger')
        
    return redirect(url_for('view_payroll', payroll_id=payroll_id))
    if current_user.role != 'admin':
        abort(403)
    
    payroll = _db_get_or_404(Payroll, payroll_id)
    amount = request.form.get('amount')
    notes = request.form.get('notes')
    
    if not amount:
        flash('Payment amount is required.', 'danger')
        return redirect(url_for('view_payroll', payroll_id=payroll_id))
        
    try:
        payment_amount = float(amount)
        payment = PayrollPayment(
            payroll_id=payroll.id,
            amount=payment_amount,
            notes=notes,
            paid_by=current_user.id
        )
        db.session.add(payment)
        
        # Update payroll status if fully paid
        total_paid = sum(p.amount for p in payroll.payments) + payment_amount
        if total_paid >= payroll.amount:
            payroll.status = 'paid'
            
        db.session.commit()
        flash('Payment made successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error making payment: {str(e)}', 'danger')
        
    return redirect(url_for('view_payroll', payroll_id=payroll_id))

    # ==================== CONTROLLED DRUG SALES REPORTS ====================
    if report_type == 'controlled_drug_sales':
        try:
            # Use a robust datetime range to avoid timezone/date-cast edge cases.
            # Note: end_date is already computed as (requested_end_date + 1 day).
            start_dt = datetime.combine(start_date, datetime.min.time())
            end_dt = datetime.combine(end_date, datetime.min.time())

            def _effective_bucket_granularity(gran: str) -> str:
                g = (gran or 'daily').lower()
                if g == 'weekly':
                    return 'daily'
                if g == 'monthly':
                    return 'weekly'
                if g == 'yearly':
                    return 'monthly'
                return 'daily'

            effective_granularity = _effective_bucket_granularity(granularity)

            # Totals
            total_sales = db.session.query(func.coalesce(func.sum(ControlledSale.total_amount), 0)).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).scalar() or 0

            cogs = db.session.query(
                func.coalesce(
                    func.sum(ControlledSaleItem.quantity * func.coalesce(ControlledDrug.buying_price, 0)),
                    0
                )
            ).select_from(
                ControlledSaleItem
            ).join(
                ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
            ).outerjoin(
                ControlledDrug, ControlledDrug.id == ControlledSaleItem.controlled_drug_id
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).scalar() or 0

            estimated_profit = float(total_sales) - float(cogs)

            # Aggregate by controlled drug
            drugs = db.session.query(
                ControlledSaleItem.controlled_drug_name.label('name'),
                func.sum(ControlledSaleItem.quantity).label('units_sold'),
                func.sum(ControlledSaleItem.total_price).label('total_sales'),
                func.sum((ControlledSaleItem.unit_price - func.coalesce(ControlledDrug.buying_price, 0)) * ControlledSaleItem.quantity).label('profit')
            ).join(
                ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
            ).outerjoin(
                ControlledDrug, ControlledDrug.id == ControlledSaleItem.controlled_drug_id
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).group_by(ControlledSaleItem.controlled_drug_name).order_by(func.sum(ControlledSaleItem.quantity).desc()).all()

            # Timeseries from sale items (avoids double-counting sale totals)
            date_rows = db.session.query(
                func.date(ControlledSale.created_at).label('d'),
                func.coalesce(func.sum(ControlledSaleItem.total_price), 0).label('amount'),
                func.coalesce(func.sum(ControlledSaleItem.quantity), 0).label('units')
            ).join(
                ControlledSaleItem, ControlledSale.id == ControlledSaleItem.sale_id
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).group_by(func.date(ControlledSale.created_at)).order_by(func.date(ControlledSale.created_at)).all()

            daily = {}
            for r in date_rows:
                daily[str(r.d)] = {'amount': float(r.amount or 0), 'units': int(r.units or 0)}

            def bucket_dates_local(daily_dict, gran):
                buckets = {}
                for ds, vals in daily_dict.items():
                    dt = datetime.strptime(ds, '%Y-%m-%d').date()
                    if gran == 'weekly':
                        key = f"{dt.isocalendar()[0]}-W{dt.isocalendar()[1]:02d}"
                        label = key
                    elif gran == 'monthly':
                        key = f"{dt.year}-{dt.month:02d}"
                        label = key
                    elif gran == 'yearly':
                        key = f"{dt.year}"
                        label = key
                    else:
                        key = ds
                        label = ds

                    if key not in buckets:
                        buckets[key] = {'label': label, 'amount': 0.0, 'units': 0}
                    buckets[key]['amount'] += float(vals.get('amount', 0) or 0)
                    buckets[key]['units'] += int(vals.get('units', 0) or 0)

                ordered = [buckets[k] for k in sorted(buckets.keys())]
                labels = [x['label'] for x in ordered]
                amounts = [x['amount'] for x in ordered]
                units = [x['units'] for x in ordered]
                return labels, amounts, units

            daily_keys = sorted(daily.keys())
            daily_labels = daily_keys
            daily_amounts = [daily[k]['amount'] for k in daily_keys]
            daily_units = [daily[k]['units'] for k in daily_keys]

            labels, amounts, units = bucket_dates_local(daily, effective_granularity)

            # Top 10 controlled drugs across time windows
            def get_top_10_controlled(start_dt, end_dt):
                rows = db.session.query(
                    ControlledSaleItem.controlled_drug_name.label('name'),
                    func.sum(ControlledSaleItem.quantity).label('total_units'),
                    func.sum(ControlledSaleItem.total_price).label('total_amount'),
                    func.sum((ControlledSaleItem.unit_price - func.coalesce(ControlledDrug.buying_price, 0)) * ControlledSaleItem.quantity).label('profit')
                ).join(
                    ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
                ).outerjoin(
                    ControlledDrug, ControlledDrug.id == ControlledSaleItem.controlled_drug_id
                ).filter(
                    ControlledSale.created_at >= start_dt,
                    ControlledSale.created_at < end_dt,
                    ControlledSale.status == 'completed'
                ).group_by(ControlledSaleItem.controlled_drug_name).order_by(func.sum(ControlledSaleItem.quantity).desc()).limit(10).all()

                total_units = sum(int(d.total_units or 0) for d in rows)
                total_amount = sum(float(d.total_amount or 0) for d in rows)
                total_profit = sum(float(d.profit or 0) for d in rows)
                return {
                    'labels': [d.name[:20] for d in rows],
                    'units': [int(d.total_units or 0) for d in rows],
                    'amounts': [float(d.total_amount or 0) for d in rows],
                    'profits': [float(d.profit or 0) for d in rows],
                    'percentages': [round((int(d.total_units or 0) / total_units * 100) if total_units > 0 else 0, 2) for d in rows],
                    'total_units': total_units,
                    'total_amount': total_amount,
                    'total_profit': total_profit
                }

            def _as_dt(d):
                return datetime.combine(d, datetime.min.time())

            # Primary Top 10: always for the selected period
            top10_current = get_top_10_controlled(start_dt, end_dt)

            # Use same windows as drug report to keep UI consistent
            top10_daily = get_top_10_controlled(_as_dt(start_date), end_dt)
            top10_weekly = get_top_10_controlled(_as_dt(start_date - timedelta(days=7)), end_dt)
            top10_monthly = get_top_10_controlled(_as_dt(start_date - timedelta(days=30)), end_dt)
            top10_yearly = get_top_10_controlled(_as_dt(start_date - timedelta(days=365)), end_dt)

            # Patient vs walk-in for controlled sales
            patient_sales = db.session.query(func.coalesce(func.sum(ControlledSale.total_amount), 0)).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed',
                ControlledSale.patient_id.isnot(None)
            ).scalar() or 0

            overcounter_sales = db.session.query(func.coalesce(func.sum(ControlledSale.total_amount), 0)).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed',
                ControlledSale.patient_id.is_(None)
            ).scalar() or 0

            patient_units = db.session.query(func.coalesce(func.sum(ControlledSaleItem.quantity), 0)).join(
                ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed',
                ControlledSale.patient_id.isnot(None)
            ).scalar() or 0

            overcounter_units = db.session.query(func.coalesce(func.sum(ControlledSaleItem.quantity), 0)).join(
                ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed',
                ControlledSale.patient_id.is_(None)
            ).scalar() or 0

            # List individual controlled sales for receipt links / export preview
            sales_rows = db.session.query(ControlledSale).options(
                db.joinedload(ControlledSale.patient)
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).order_by(ControlledSale.created_at.desc()).all()

            # Controlled inventory snapshot (from controlled_drugs)
            try:
                controlled_inventory_total = db.session.query(func.count(ControlledDrug.id)).scalar() or 0
                controlled_inventory_in_stock = db.session.query(func.count(ControlledDrug.id)).filter(
                    ControlledDrug.remaining_quantity > 0
                ).scalar() or 0
                controlled_inventory_low_stock = db.session.query(func.count(ControlledDrug.id)).filter(
                    ControlledDrug.remaining_quantity > 0,
                    ControlledDrug.remaining_quantity < 10
                ).scalar() or 0
                controlled_inventory_out_stock = db.session.query(func.count(ControlledDrug.id)).filter(
                    ControlledDrug.remaining_quantity <= 0
                ).scalar() or 0
                controlled_inventory_expiring_soon = db.session.query(func.count(ControlledDrug.id)).filter(
                    ControlledDrug.expiry_date.isnot(None),
                    ControlledDrug.expiry_date <= date.today() + timedelta(days=30)
                ).scalar() or 0
            except Exception:
                controlled_inventory_total = 0
                controlled_inventory_in_stock = 0
                controlled_inventory_low_stock = 0
                controlled_inventory_out_stock = 0
                controlled_inventory_expiring_soon = 0

            # Controlled prescriptions summary (from controlled_prescriptions + items)
            prescriptions_total = 0
            prescriptions_pending = 0
            prescriptions_dispensed = 0
            prescriptions_cancelled = 0
            prescribed_units = 0
            top_prescribed = []
            try:
                status_rows = db.session.query(
                    ControlledPrescription.status,
                    func.count(ControlledPrescription.id)
                ).filter(
                    ControlledPrescription.created_at >= start_dt,
                    ControlledPrescription.created_at < end_dt,
                ).group_by(ControlledPrescription.status).all()

                for st, cnt in status_rows:
                    c = int(cnt or 0)
                    prescriptions_total += c
                    if (st or '').lower() == 'pending':
                        prescriptions_pending = c
                    elif (st or '').lower() == 'dispensed':
                        prescriptions_dispensed = c
                    elif (st or '').lower() == 'cancelled':
                        prescriptions_cancelled = c

                prescribed_units = db.session.query(func.coalesce(func.sum(ControlledPrescriptionItem.quantity), 0)).join(
                    ControlledPrescription,
                    ControlledPrescriptionItem.controlled_prescription_id == ControlledPrescription.id
                ).filter(
                    ControlledPrescription.created_at >= start_dt,
                    ControlledPrescription.created_at < end_dt,
                ).scalar() or 0

                top_rows = db.session.query(
                    ControlledPrescriptionItem.controlled_drug_id.label('drug_id'),
                    func.coalesce(ControlledDrug.name, func.cast(ControlledPrescriptionItem.controlled_drug_id, db.String)).label('drug_name'),
                    func.coalesce(ControlledDrug.specification, '').label('specification'),
                    func.coalesce(func.sum(ControlledPrescriptionItem.quantity), 0).label('units'),
                    func.count(func.distinct(ControlledPrescription.id)).label('prescriptions')
                ).select_from(
                    ControlledPrescriptionItem
                ).join(
                    ControlledPrescription,
                    ControlledPrescriptionItem.controlled_prescription_id == ControlledPrescription.id
                ).outerjoin(
                    ControlledDrug,
                    ControlledDrug.id == ControlledPrescriptionItem.controlled_drug_id
                ).filter(
                    ControlledPrescription.created_at >= start_dt,
                    ControlledPrescription.created_at < end_dt,
                ).group_by(
                    ControlledPrescriptionItem.controlled_drug_id,
                    ControlledDrug.name,
                    ControlledDrug.specification,
                ).order_by(
                    func.coalesce(func.sum(ControlledPrescriptionItem.quantity), 0).desc()
                ).limit(10).all()

                top_prescribed = [
                    {
                        'controlled_drug_id': int(r.drug_id or 0),
                        # Provide both legacy + explicit keys to keep the frontend resilient.
                        'name': (r.drug_name or '').strip(),
                        'drug_name': (r.drug_name or '').strip(),
                        'specification': (r.specification or '').strip(),
                        'units': int(r.units or 0),
                        'total_units': int(r.units or 0),
                        'prescriptions': int(r.prescriptions or 0),
                        'prescription_count': int(r.prescriptions or 0),
                    }
                    for r in top_rows
                ]
            except Exception:
                prescriptions_total = 0
                prescriptions_pending = 0
                prescriptions_dispensed = 0
                prescriptions_cancelled = 0
                prescribed_units = 0
                top_prescribed = []

            # Item-level controlled sale lines (for end table)
            item_rows = db.session.query(ControlledSale, ControlledSaleItem).join(
                ControlledSaleItem, ControlledSale.id == ControlledSaleItem.sale_id
            ).options(
                db.joinedload(ControlledSale.patient)
            ).filter(
                ControlledSale.created_at >= start_dt,
                ControlledSale.created_at < end_dt,
                ControlledSale.status == 'completed'
            ).order_by(ControlledSale.created_at.desc(), ControlledSaleItem.id.asc()).all()

            items_data = []
            for sale, item in item_rows:
                patient_name = None
                patient_phone = None
                try:
                    if sale.patient:
                        patient_name = (sale.patient.name or '').strip() or None
                        patient_phone = (sale.patient.phone or '').strip() or None
                except Exception:
                    patient_name = None
                    patient_phone = None

                items_data.append({
                    'sale_id': sale.id,
                    'sale_number': sale.sale_number,
                    'created_at': sale.created_at.strftime('%Y-%m-%d %H:%M') if sale.created_at else '',
                    'payment_method': sale.payment_method,
                    'customer_name': sale.customer_name or patient_name,
                    'patient_name': patient_name,
                    'customer_phone': sale.customer_phone or patient_phone,
                    'prescription_image_path': sale.prescription_image_path,
                    'receipt_url': url_for('admin_controlled_sale_receipt', sale_id=sale.id),
                    'drug_name': item.controlled_drug_name,
                    'quantity': int(item.quantity or 0),
                    'unit_price': float(item.unit_price or 0),
                    'line_total': float(item.total_price or 0),
                })

            sales_data = []
            for s in sales_rows:
                patient_name = None
                patient_phone = None
                try:
                    if s.patient:
                        patient_name = (s.patient.name or '').strip() or None
                        patient_phone = (s.patient.phone or '').strip() or None
                except Exception:
                    patient_name = None
                    patient_phone = None

                sales_data.append({
                    'id': s.id,
                    'sale_number': s.sale_number,
                    'created_at': s.created_at.strftime('%Y-%m-%d %H:%M') if s.created_at else '',
                    'pharmacist_name': s.pharmacist_name,
                    'payment_method': s.payment_method,
                    'total_amount': float(s.total_amount or 0),
                    'patient_name': patient_name,
                    'customer_name': s.customer_name or patient_name,
                    'customer_phone': s.customer_phone or patient_phone,
                    'customer_gender': s.customer_gender,
                    'customer_age': s.customer_age,
                    'diagnosis': s.diagnosis,
                    'destination': s.destination,
                    'prescription_image_path': s.prescription_image_path,
                    'receipt_url': url_for('admin_controlled_sale_receipt', sale_id=s.id),
                })

            totals = {
                'sales_total': float(total_sales),
                'cogs': float(cogs),
                'expenses': 0.0,
                'estimated_profit': float(estimated_profit)
            }

            response_data = {
                'status': 'success',
                'report_type': 'controlled_drug_sales',
                'granularity': granularity,
                'start_date': start_date_str,
                'end_date': end_date_str,
                'effective_granularity': effective_granularity,
                'data': items_data,
                'receipts': sales_data,
                'charts': {
                    'labels': labels,
                    'amounts': amounts,
                    'units': units,
                    'daily_labels': daily_labels,
                    'daily_amounts': daily_amounts,
                    'daily_units': daily_units,
                    'totals': totals,
                    'top10_current': top10_current,
                    'top10_daily': top10_daily,
                    'top10_weekly': top10_weekly,
                    'top10_monthly': top10_monthly,
                    'top10_yearly': top10_yearly,
                    'patient_sales': float(patient_sales or 0),
                    'patient_units': int(patient_units or 0),
                    'patient_percentage': round((float(patient_sales or 0) / float(total_sales) * 100) if float(total_sales) > 0 else 0, 2),
                    'overcounter_sales': float(overcounter_sales or 0),
                    'overcounter_units': int(overcounter_units or 0),
                    'overcounter_percentage': round((float(overcounter_sales or 0) / float(total_sales) * 100) if float(total_sales) > 0 else 0, 2),
                },
                'controlled_inventory': {
                    'total': int(controlled_inventory_total),
                    'in_stock': int(controlled_inventory_in_stock),
                    'low_stock': int(controlled_inventory_low_stock),
                    'out_of_stock': int(controlled_inventory_out_stock),
                    'expiring_soon': int(controlled_inventory_expiring_soon),
                },
                'controlled_prescriptions': {
                    'total': int(prescriptions_total),
                    'pending': int(prescriptions_pending),
                    'dispensed': int(prescriptions_dispensed),
                    'cancelled': int(prescriptions_cancelled),
                    'prescribed_units': int(prescribed_units or 0),
                    'top_prescribed': top_prescribed,
                },
                'metrics': format_financial_metrics(totals)
            }

            issues = validate_report_data(response_data)
            if issues:
                response_data['data_quality_issues'] = issues

            log_report_access(
                report_type='controlled_drug_sales',
                filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity},
                data_count=len(items_data),
                status='success'
            )

            return jsonify(response_data)

        except Exception as e:
            app.logger.error(f"Error generating controlled drug sales report: {str(e)}", exc_info=True)
            log_report_access(
                report_type='controlled_drug_sales',
                filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity},
                data_count=0,
                status='error',
                error_msg=str(e)
            )
            return jsonify({'error': 'Failed to generate controlled drug sales report'}), 500

    def bucket_dates(daily_dict, gran):
        buckets = {}
        for ds, vals in daily_dict.items():
            dt = datetime.strptime(ds, '%Y-%m-%d').date()
            if gran == 'weekly':
                key = f"{dt.isocalendar()[0]}-W{dt.isocalendar()[1]:02d}"
                label = key
            elif gran == 'monthly':
                key = f"{dt.year}-{dt.month:02d}"
                label = key
            elif gran == 'yearly':
                key = f"{dt.year}"
                label = key
            else:
                key = ds
                label = ds

            if key not in buckets:
                buckets[key] = {'label': label, 'amount': 0.0, 'units': 0}
            buckets[key]['amount'] += float(vals.get('amount', 0) or 0)
            buckets[key]['units'] += int(vals.get('units', vals.get('count', 0)) or 0)

        ordered = [buckets[k] for k in sorted(buckets.keys())]
        labels = [x['label'] for x in ordered]
        amounts = [x['amount'] for x in ordered]
        units = [x['units'] for x in ordered]
        return labels, amounts, units

    # ==================== LAB REPORTS (Monetary, by patient) ====================
    if report_type == 'lab_reports':
        # Lab: inpatient only (exclude over-the-counter / walk-in)
        inpatient_filter = db.or_(Patient.ip_number.isnot(None), Patient.date_of_admission.isnot(None))

        # Overall lab revenue and count
        lab_total_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).select_from(SaleItem).join(
            Sale, SaleItem.sale_id == Sale.id
        ).join(
            Patient, Sale.patient_id == Patient.id
        ).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).scalar() or 0

        lab_total_count = db.session.query(func.coalesce(func.count(SaleItem.id), 0)).select_from(SaleItem).join(
            Sale, SaleItem.sale_id == Sale.id
        ).join(
            Patient, Sale.patient_id == Patient.id
        ).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).scalar() or 0

        # Group by patient and test
        lab_rows = db.session.query(
            Patient.id.label('patient_id'),
            Patient.name.label('patient_name'),
            LabTest.id.label('test_id'),
            LabTest.name.label('test_name'),
            func.count(SaleItem.id).label('count'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
        ).join(Sale, Sale.patient_id == Patient.id).join(SaleItem, SaleItem.sale_id == Sale.id).join(LabTest, SaleItem.lab_test_id == LabTest.id).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).group_by(Patient.id, Patient.name, LabTest.id, LabTest.name).order_by(Patient.name, LabTest.name).all()

        patients_by_id = {}
        for r in lab_rows:
            pid = int(r.patient_id)
            if pid not in patients_by_id:
                patients_by_id[pid] = {
                    'patient_id': pid,
                    'patient_name': r.patient_name,
                    'tests': [],
                    'total_count': 0,
                    'total_revenue': 0.0
                }
            count = int(r.count or 0)
            amount = float(r.amount or 0)
            patients_by_id[pid]['tests'].append({
                'test_id': int(r.test_id),
                'test_name': r.test_name,
                'count': count,
                'amount': amount
            })
            patients_by_id[pid]['total_count'] += count
            patients_by_id[pid]['total_revenue'] += amount

        patient_rows = sorted(patients_by_id.values(), key=lambda x: (x['patient_name'] or ''))

        # Time series for lab revenue
        lab_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.count(SaleItem.id), 0).label('count')
        ).select_from(SaleItem).join(
            Sale, SaleItem.sale_id == Sale.id
        ).join(
            Patient, Sale.patient_id == Patient.id
        ).filter(
            SaleItem.lab_test_id.isnot(None),
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            inpatient_filter
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        lab_daily = {str(r.d): {'amount': float(r.amount or 0), 'count': int(r.count or 0)} for r in lab_date_rows}

        daily_keys = sorted(lab_daily.keys())
        daily_labels = daily_keys
        daily_amounts = [lab_daily[k]['amount'] for k in daily_keys]
        daily_counts = [lab_daily[k]['count'] for k in daily_keys]

        labels, amounts, counts = bucket_dates(lab_daily, effective_granularity)

        # Breakdown by test (for pie + bar)
        test_breakdown_rows = db.session.query(
            LabTest.name.label('test_name'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.count(SaleItem.id), 0).label('count')
        ).select_from(SaleItem).join(
            LabTest, SaleItem.lab_test_id == LabTest.id
        ).join(
            Sale, SaleItem.sale_id == Sale.id
        ).join(
            Patient, Sale.patient_id == Patient.id
        ).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).group_by(LabTest.name).order_by(func.sum(SaleItem.total_price).desc()).all()

        top_tests = {
            'labels': [r.test_name[:24] for r in test_breakdown_rows[:10]],
            'amounts': [float(r.amount or 0) for r in test_breakdown_rows[:10]],
            'counts': [int(r.count or 0) for r in test_breakdown_rows[:10]]
        }

        # Top patients by lab spend
        top_patient_rows = db.session.query(
            Patient.name.label('patient_name'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
        ).select_from(SaleItem).join(
            Sale, SaleItem.sale_id == Sale.id
        ).join(
            Patient, Sale.patient_id == Patient.id
        ).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).group_by(Patient.name).order_by(func.sum(SaleItem.total_price).desc()).limit(10).all()

        # Lab receipts list (inpatient only)
        lab_sale_rows = db.session.query(
            Sale.id.label('sale_id'),
            Sale.sale_number.label('sale_number'),
            Sale.created_at.label('created_at'),
            Sale.payment_method.label('payment_method'),
            Patient.name.label('patient_name'),
            Patient.phone.label('patient_phone'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('lab_total')
        ).join(Patient, Sale.patient_id == Patient.id).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None),
            inpatient_filter
        ).group_by(Sale.id, Sale.sale_number, Sale.created_at, Sale.payment_method, Patient.name, Patient.phone).order_by(Sale.created_at.desc()).all()

        tx_by_sale_id = {}
        try:
            sale_ids = [int(r.sale_id) for r in lab_sale_rows]
            if sale_ids:
                tx_q = Transaction.query.filter(
                    Transaction.transaction_type == 'sale',
                    Transaction.reference_id.in_(sale_ids),
                )
                if _transaction_supports_metadata():
                    tx_q = tx_q.filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'sales'))
                tx_rows = tx_q.order_by(Transaction.reference_id.asc(), Transaction.created_at.desc()).all()
                for tx in tx_rows:
                    if tx.reference_id not in tx_by_sale_id:
                        tx_by_sale_id[tx.reference_id] = tx
        except Exception:
            tx_by_sale_id = {}

        lab_receipts = []
        for r in lab_sale_rows:
            tx = tx_by_sale_id.get(int(r.sale_id))
            receipt_url = url_for('admin_transaction_receipt', transaction_id=tx.id) if tx else None
            lab_receipts.append({
                'sale_id': int(r.sale_id),
                'sale_number': r.sale_number,
                'created_at': r.created_at.strftime('%Y-%m-%d %H:%M') if r.created_at else '',
                'payment_method': r.payment_method,
                'patient_name': r.patient_name,
                'patient_phone': r.patient_phone,
                'total_amount': float(r.lab_total or 0),
                'receipt_url': receipt_url,
            })

        top_patients = {
            'labels': [r.patient_name[:24] if r.patient_name else 'Unknown' for r in top_patient_rows],
            'amounts': [float(r.amount or 0) for r in top_patient_rows]
        }

        totals = {
            'lab_revenue': float(lab_total_revenue),
            'lab_count': int(lab_total_count)
        }

        response_data = {
            'status': 'success',
            'report_type': 'lab_reports',
            'granularity': granularity,
            'start_date': start_date_str,
            'end_date': end_date_str,
            'effective_granularity': effective_granularity,
            'data': patient_rows,
            'receipts': lab_receipts,
            'charts': {
                'labels': labels,
                'amounts': amounts,
                'units': counts,
                'daily_labels': daily_labels,
                'daily_amounts': daily_amounts,
                'daily_units': daily_counts,
                'totals': totals,
                'lab_breakdown': {
                    'labels': [r.test_name[:24] for r in test_breakdown_rows],
                    'amounts': [float(r.amount or 0) for r in test_breakdown_rows]
                },
                'top_tests': top_tests,
                'top_patients': top_patients
            }
        }

        log_report_access(
            report_type='lab_reports',
            filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity},
            data_count=len(patient_rows),
            status='success'
        )

        return jsonify(response_data)

    # ==================== GENERAL REPORT (Drugs + Labs) ====================
    if report_type == 'general':
        drug_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).join(Sale).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.drug_id.isnot(None)
        ).scalar() or 0

        lab_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).join(Sale).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None)
        ).scalar() or 0

        total_revenue = float(drug_revenue) + float(lab_revenue)

        # Expenses (for general report)
        try:
            total_expenses = db.session.query(func.coalesce(func.sum(Expense.amount), 0)).filter(
                Expense.created_at >= start_dt,
                Expense.created_at < end_dt
            ).scalar() or 0
        except Exception:
            total_expenses = 0

        drug_profit = db.session.query(func.coalesce(func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity), 0)).join(Drug).join(Sale).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.drug_id.isnot(None)
        ).scalar() or 0

        # Time series for both streams
        drug_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('units')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.drug_id.isnot(None),
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        lab_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.count(SaleItem.id), 0).label('count')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.lab_test_id.isnot(None),
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        drug_daily = {str(r.d): {'amount': float(r.amount or 0), 'units': int(r.units or 0)} for r in drug_date_rows}
        lab_daily = {str(r.d): {'amount': float(r.amount or 0), 'count': int(r.count or 0)} for r in lab_date_rows}

        # Daily series for line chart
        daily_keys = sorted(set(list(drug_daily.keys()) + list(lab_daily.keys())))
        daily_labels = daily_keys
        daily_drug_amounts = [float(drug_daily.get(k, {}).get('amount', 0) or 0) for k in daily_keys]
        daily_lab_amounts = [float(lab_daily.get(k, {}).get('amount', 0) or 0) for k in daily_keys]
        daily_amounts = [a + b for a, b in zip(daily_drug_amounts, daily_lab_amounts)]

        labels_drug, drug_amounts, drug_units = bucket_dates(drug_daily, effective_granularity)
        labels_lab, lab_amounts, lab_counts = bucket_dates(lab_daily, effective_granularity)
        labels = labels_drug if len(labels_drug) >= len(labels_lab) else labels_lab

        # Top drugs by revenue
        top_drugs = db.session.query(
            Drug.name.label('name'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('units'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity), 0).label('profit')
        ).join(SaleItem).join(Sale).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).group_by(Drug.name).order_by(func.sum(SaleItem.total_price).desc()).limit(10).all()

        top_labs = db.session.query(
            LabTest.name.label('name'),
            func.coalesce(func.count(SaleItem.id), 0).label('count'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
        ).join(SaleItem, SaleItem.lab_test_id == LabTest.id).join(Sale, SaleItem.sale_id == Sale.id).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed',
            SaleItem.lab_test_id.isnot(None)
        ).group_by(LabTest.name).order_by(func.sum(SaleItem.total_price).desc()).limit(10).all()

        combined_items = []
        for d in top_drugs:
            combined_items.append({
                'category': 'Drug',
                'name': d.name,
                'units': int(d.units or 0),
                'total_revenue': float(d.amount or 0),
                'profit': float(d.profit or 0)
            })
        for t in top_labs:
            combined_items.append({
                'category': 'Lab',
                'name': t.name,
                'units': int(t.count or 0),
                'total_revenue': float(t.amount or 0)
            })

        totals = {
            'total_revenue': float(total_revenue),
            'drug_revenue': float(drug_revenue),
            'lab_revenue': float(lab_revenue),
            'drug_cogs': float(cogs),
            'drug_profit': float(drug_profit),
            'expenses_total': float(total_expenses),
            'net_income': float(total_revenue) - float(total_expenses)
        }

        # Receipts list (all completed sales in period)
        sales_rows = db.session.query(Sale).options(db.joinedload(Sale.patient)).filter(
            Sale.created_at >= start_dt,
            Sale.created_at < end_dt,
            Sale.status == 'completed'
        ).order_by(Sale.created_at.desc()).all()

        tx_by_sale_id = {}
        try:
            sale_ids = [s.id for s in sales_rows]
            if sale_ids:
                tx_q = Transaction.query.filter(
                    Transaction.transaction_type == 'sale',
                    Transaction.reference_id.in_(sale_ids),
                )
                if _transaction_supports_metadata():
                    tx_q = tx_q.filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'sales'))
                tx_rows = tx_q.order_by(Transaction.reference_id.asc(), Transaction.created_at.desc()).all()
                for tx in tx_rows:
                    if tx.reference_id not in tx_by_sale_id:
                        tx_by_sale_id[tx.reference_id] = tx
        except Exception:
            tx_by_sale_id = {}

        receipts = []
        for s in sales_rows:
            patient_name = None
            patient_phone = None
            try:
                if s.patient:
                    patient_name = (s.patient.name or '').strip() or None
                    patient_phone = (s.patient.phone or '').strip() or None
            except Exception:
                patient_name = None
                patient_phone = None

            tx = tx_by_sale_id.get(s.id)
            receipt_url = url_for('admin_transaction_receipt', transaction_id=tx.id) if tx else None

            receipts.append({
                'sale_id': s.id,
                'sale_number': s.sale_number,
                'created_at': s.created_at.strftime('%Y-%m-%d %H:%M') if s.created_at else '',
                'payment_method': s.payment_method,
                'total_amount': float(s.total_amount or 0),
                'patient_name': patient_name,
                'customer_name': patient_name,
                'customer_phone': patient_phone,
                'receipt_url': receipt_url,
            })

        # Expense list (period)
        expenses = []
        try:
            expense_rows = Expense.query.filter(
                Expense.created_at >= start_dt,
                Expense.created_at < end_dt
            ).order_by(Expense.created_at.desc()).all()
            for ex in expense_rows:
                expenses.append({
                    'id': ex.id,
                    'expense_number': ex.expense_number,
                    'expense_type': ex.expense_type,
                    'amount': float(ex.amount or 0),
                    'status': ex.status,
                    'payment_method': ex.payment_method,
                    'paid_date': ex.paid_date.strftime('%Y-%m-%d') if ex.paid_date else None,
                    'created_at': ex.created_at.strftime('%Y-%m-%d %H:%M') if ex.created_at else '',
                    'description': ex.description,
                })
        except Exception:
            expenses = []

        response_data = {
            'status': 'success',
            'report_type': 'general',
            'granularity': granularity,
            'start_date': start_date_str,
            'end_date': end_date_str,
            'effective_granularity': effective_granularity,
            'data': sorted(combined_items, key=lambda x: x.get('total_revenue', 0), reverse=True),
            'receipts': receipts,
            'expenses': expenses,
            'charts': {
                'labels': labels,
                'drug_amounts': drug_amounts,
                'lab_amounts': lab_amounts,
                'drug_units': drug_units,
                'lab_counts': lab_counts,
                'daily_labels': daily_labels,
                'daily_amounts': daily_amounts,
                'totals': totals,
                'top_drugs': {
                    'labels': [d.name[:24] for d in top_drugs],
                    'amounts': [float(d.amount or 0) for d in top_drugs]
                },
                'top_tests': {
                    'labels': [t.name[:24] for t in top_labs],
                    'amounts': [float(t.amount or 0) for t in top_labs]
                }
            }
        }

        log_report_access(
            report_type='general',
            filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity},
            data_count=len(combined_items),
            status='success'
        )

        return jsonify(response_data)
    
    # Additional advanced reporting options
    # Additional advanced reporting options
    subtype = request.args.get('subtype')  # e.g., 'lab' or 'drugs' for patient reports
    patient_kind = request.args.get('patient_kind')  # 'inpatient' | 'outpatient' | None
    granularity = request.args.get('granularity', 'daily')  # daily, weekly, monthly, yearly

    # Normalize end_date to include entire day already done above via + timedelta

    # Compute high-level totals
    total_sales = db.session.query(func.coalesce(func.sum(Sale.total_amount), 0)).filter(
        Sale.created_at >= start_date,
        Sale.created_at <= end_date,
        Sale.status == 'completed'
    ).scalar() or 0

    cogs = db.session.query(func.coalesce(func.sum(SaleItem.quantity * Drug.buying_price), 0)).join(Drug).join(Sale).filter(
        Sale.created_at >= start_date,
        Sale.created_at <= end_date,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    expenses_list = db.session.query(Expense).filter(
        Expense.created_at >= start_date,
        Expense.created_at <= end_date
    ).all()

    total_expenses = db.session.query(func.coalesce(func.sum(Expense.amount), 0)).filter(
        Expense.created_at >= start_date,
        Expense.created_at <= end_date
    ).scalar() or 0

    estimated_profit = float(total_sales) - float(cogs) - float(total_expenses)

    # Patients report: inpatients/outpatients, subtype lab/drugs
    if report_type == 'patients':
        patient_filter = []
        if patient_kind == 'inpatient':
            patient_filter.append(Patient.date_of_admission.isnot(None))
        elif patient_kind == 'outpatient':
            patient_filter.append(Patient.op_number.isnot(None))

        results = []

        # LABS: combine clinical lab counts (PatientLab) and financial lab sales (SaleItem.lab_test_id)
        if subtype in (None, 'lab'):
            lab_rows = db.session.query(
                Patient.id.label('patient_id'),
                Patient.name.label('patient_name'),
                func.coalesce(func.count(PatientLab.id), 0).label('lab_tests_count'),
                func.coalesce(func.sum(SaleItem.total_price), 0).label('lab_sales_amount')
            ).select_from(Patient).outerjoin(Sale, Sale.patient_id == Patient.id).outerjoin(SaleItem, db.and_(SaleItem.sale_id == Sale.id, SaleItem.lab_test_id.isnot(None))).outerjoin(PatientLab, PatientLab.patient_id == Patient.id).filter(
                Sale.created_at >= start_date,
                Sale.created_at <= end_date,
                Sale.status == 'completed'
            )

            if patient_filter:
                lab_rows = lab_rows.filter(*patient_filter)

            lab_rows = lab_rows.group_by(Patient.id).order_by(Patient.name).all()

            for r in lab_rows:
                results.append({
                    'patient_id': r.patient_id,
                    'patient_name': r.patient_name,
                    'lab_tests_count': int(r.lab_tests_count or 0),
                    'lab_sales_amount': float(r.lab_sales_amount or 0)
                })

        # DRUGS: drugs sold to patients (from SaleItem)
        if subtype in (None, 'drugs'):
            drug_rows = db.session.query(
                Patient.id.label('patient_id'),
                Patient.name.label('patient_name'),
                func.coalesce(func.sum(SaleItem.quantity), 0).label('units'),
                func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
            ).join(Sale, Sale.patient_id == Patient.id).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
                Sale.created_at >= start_date,
                Sale.created_at <= end_date,
                Sale.status == 'completed',
                SaleItem.drug_id.isnot(None)
            )

            if patient_filter:
                drug_rows = drug_rows.filter(*patient_filter)

            drug_rows = drug_rows.group_by(Patient.id).order_by(Patient.name).all()

            # Merge into results keyed by patient
            results_by_id = {r['patient_id']: r for r in results}
            for r in drug_rows:
                pid = r.patient_id
                if pid in results_by_id:
                    results_by_id[pid].update({
                        'drug_units': int(r.units or 0),
                        'drug_amount': float(r.amount or 0)
                    })
                else:
                    results.append({
                        'patient_id': r.patient_id,
                        'patient_name': r.patient_name,
                        'drug_units': int(r.units or 0),
                        'drug_amount': float(r.amount or 0)
                    })

        # Build time series for patient-related lab and drug sales
        # LAB timeseries
        lab_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.count(SaleItem.id), 0).label('count')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.lab_test_id.isnot(None),
            Sale.created_at >= start_date,
            Sale.created_at <= end_date,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        # DRUG timeseries
        drug_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('units')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.drug_id.isnot(None),
            Sale.created_at >= start_date,
            Sale.created_at <= end_date,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        # Convert rows to daily dict
        lab_daily = {str(r.d): {'amount': float(r.amount or 0), 'count': int(r.count or 0)} for r in lab_date_rows}
        drug_daily = {str(r.d): {'amount': float(r.amount or 0), 'units': int(r.units or 0)} for r in drug_date_rows}

        # Reuse bucketing logic for granularity
        def bucket_dates(daily_dict, gran):
            buckets = {}
            for ds, vals in daily_dict.items():
                dt = datetime.strptime(ds, '%Y-%m-%d').date()
                if gran == 'weekly':
                    key = f"{dt.isocalendar()[0]}-W{dt.isocalendar()[1]:02d}"
                    label = key
                elif gran == 'monthly':
                    key = f"{dt.year}-{dt.month:02d}"
                    label = key
                elif gran == 'yearly':
                    key = f"{dt.year}"
                    label = key
                else:
                    key = ds
                    label = ds

                if key not in buckets:
                    buckets[key] = {'label': label, 'amount': 0.0, 'units': 0}
                buckets[key]['amount'] += vals.get('amount', 0)
                # some buckets have 'count' other have 'units'
                buckets[key]['units'] += vals.get('units', vals.get('count', 0))

            ordered = [buckets[k] for k in sorted(buckets.keys())]
            labels = [x['label'] for x in ordered]
            amounts = [x['amount'] for x in ordered]
            units = [x['units'] for x in ordered]
            return labels, amounts, units

        lab_labels, lab_amounts, lab_counts = bucket_dates(lab_daily, granularity)
        drug_labels, drug_amounts, drug_units = bucket_dates(drug_daily, granularity)

        # Build response
        totals = {
            'sales_total': float(total_sales),
            'cogs': float(cogs),
            'expenses': float(total_expenses),
            'estimated_profit': float(estimated_profit)
        }
        
        response_data = {
            'status': 'success',
            'report_type': 'patients',
            'subtype': subtype,
            'patient_kind': patient_kind or 'all',
            'granularity': granularity,
            'start_date': start_date_str,
            'end_date': end_date_str,
            'data': results,
            'totals': totals,
            'expenses': [{
                'expense_number': e.expense_number,
                'expense_type': e.expense_type,
                'amount': float(e.amount),
                'description': e.description,
                'created_at': e.created_at.strftime('%Y-%m-%d') if e.created_at else None
            } for e in expenses_list],
            'charts': {
                'labels': lab_labels if len(lab_labels) >= len(drug_labels) else drug_labels,
                'lab_amounts': lab_amounts,
                'lab_counts': lab_counts,
                'drug_amounts': drug_amounts,
                'drug_units': drug_units,
                'totals': totals
            },
            'metrics': format_financial_metrics(totals)
        }
        
        # Validate data quality
        issues = validate_report_data(response_data)
        if issues:
            response_data['data_quality_issues'] = issues
        
        # Log report access for audit trail
        log_report_access(
            report_type='patients',
            filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity, 'subtype': subtype, 'patient_kind': patient_kind},
            data_count=len(results),
            status='success'
        )

        return jsonify(response_data)
    
    # Additional advanced reporting options
    subtype = request.args.get('subtype')  # e.g., 'lab' or 'drugs' for patient reports
    patient_kind = request.args.get('patient_kind')  # 'inpatient' | 'outpatient' | None
    granularity = request.args.get('granularity', 'daily')  # daily, weekly, monthly, yearly

    # Normalize end_date to include entire day already done above via + timedelta

    # Compute high-level totals
    total_sales = db.session.query(func.coalesce(func.sum(Sale.total_amount), 0)).filter(
        Sale.created_at >= start_date,
        Sale.created_at <= end_date,
        Sale.status == 'completed'
    ).scalar() or 0

    cogs = db.session.query(func.coalesce(func.sum(SaleItem.quantity * Drug.buying_price), 0)).join(Drug).join(Sale).filter(
        Sale.created_at >= start_date,
        Sale.created_at <= end_date,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    expenses_list = db.session.query(Expense).filter(
        Expense.created_at >= start_date,
        Expense.created_at <= end_date
    ).all()

    total_expenses = db.session.query(func.coalesce(func.sum(Expense.amount), 0)).filter(
        Expense.created_at >= start_date,
        Expense.created_at <= end_date
    ).scalar() or 0

    estimated_profit = float(total_sales) - float(cogs) - float(total_expenses)

    # Patients report: inpatients/outpatients, subtype lab/drugs
    if report_type == 'patients':
        patient_filter = []
        if patient_kind == 'inpatient':
            patient_filter.append(Patient.date_of_admission.isnot(None))
        elif patient_kind == 'outpatient':
            patient_filter.append(Patient.op_number.isnot(None))

        results = []

        # LABS: combine clinical lab counts (PatientLab) and financial lab sales (SaleItem.lab_test_id)
        if subtype in (None, 'lab'):
            lab_rows = db.session.query(
                Patient.id.label('patient_id'),
                Patient.name.label('patient_name'),
                func.coalesce(func.count(PatientLab.id), 0).label('lab_tests_count'),
                func.coalesce(func.sum(SaleItem.total_price), 0).label('lab_sales_amount')
            ).select_from(Patient).outerjoin(Sale, Sale.patient_id == Patient.id).outerjoin(SaleItem, db.and_(SaleItem.sale_id == Sale.id, SaleItem.lab_test_id.isnot(None))).outerjoin(PatientLab, PatientLab.patient_id == Patient.id).filter(
                Sale.created_at >= start_date,
                Sale.created_at <= end_date,
                Sale.status == 'completed'
            )

            if patient_filter:
                lab_rows = lab_rows.filter(*patient_filter)

            lab_rows = lab_rows.group_by(Patient.id).order_by(Patient.name).all()

            for r in lab_rows:
                results.append({
                    'patient_id': r.patient_id,
                    'patient_name': r.patient_name,
                    'lab_tests_count': int(r.lab_tests_count or 0),
                    'lab_sales_amount': float(r.lab_sales_amount or 0)
                })

        # DRUGS: drugs sold to patients (from SaleItem)
        if subtype in (None, 'drugs'):
            drug_rows = db.session.query(
                Patient.id.label('patient_id'),
                Patient.name.label('patient_name'),
                func.coalesce(func.sum(SaleItem.quantity), 0).label('units'),
                func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
            ).join(Sale, Sale.patient_id == Patient.id).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
                Sale.created_at >= start_date,
                Sale.created_at <= end_date,
                Sale.status == 'completed',
                SaleItem.drug_id.isnot(None)
            )

            if patient_filter:
                drug_rows = drug_rows.filter(*patient_filter)

            drug_rows = drug_rows.group_by(Patient.id).order_by(Patient.name).all()

            # Merge into results keyed by patient
            results_by_id = {r['patient_id']: r for r in results}
            for r in drug_rows:
                pid = r.patient_id
                if pid in results_by_id:
                    results_by_id[pid].update({
                        'drug_units': int(r.units or 0),
                        'drug_amount': float(r.amount or 0)
                    })
                else:
                    results.append({
                        'patient_id': r.patient_id,
                        'patient_name': r.patient_name,
                        'drug_units': int(r.units or 0),
                        'drug_amount': float(r.amount or 0)
                    })

        # Build time series for patient-related lab and drug sales
        # LAB timeseries
        lab_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.count(SaleItem.id), 0).label('count')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.lab_test_id.isnot(None),
            Sale.created_at >= start_date,
            Sale.created_at <= end_date,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        # DRUG timeseries
        drug_date_rows = db.session.query(
            func.date(Sale.created_at).label('d'),
            func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
            func.coalesce(func.sum(SaleItem.quantity), 0).label('units')
        ).join(SaleItem, SaleItem.sale_id == Sale.id).filter(
            SaleItem.drug_id.isnot(None),
            Sale.created_at >= start_date,
            Sale.created_at <= end_date,
            Sale.status == 'completed'
        ).group_by(func.date(Sale.created_at)).order_by(func.date(Sale.created_at)).all()

        # Convert rows to daily dict
        lab_daily = {str(r.d): {'amount': float(r.amount or 0), 'count': int(r.count or 0)} for r in lab_date_rows}
        drug_daily = {str(r.d): {'amount': float(r.amount or 0), 'units': int(r.units or 0)} for r in drug_date_rows}

        # Reuse bucketing logic for granularity
        def bucket_dates(daily_dict, gran):
            buckets = {}
            for ds, vals in daily_dict.items():
                dt = datetime.strptime(ds, '%Y-%m-%d').date()
                if gran == 'weekly':
                    key = f"{dt.isocalendar()[0]}-W{dt.isocalendar()[1]:02d}"
                    label = key
                elif gran == 'monthly':
                    key = f"{dt.year}-{dt.month:02d}"
                    label = key
                elif gran == 'yearly':
                    key = f"{dt.year}"
                    label = key
                else:
                    key = ds
                    label = ds

                if key not in buckets:
                    buckets[key] = {'label': label, 'amount': 0.0, 'units': 0}
                buckets[key]['amount'] += vals.get('amount', 0)
                # some buckets have 'count' other have 'units'
                buckets[key]['units'] += vals.get('units', vals.get('count', 0))

            ordered = [buckets[k] for k in sorted(buckets.keys())]
            labels = [x['label'] for x in ordered]
            amounts = [x['amount'] for x in ordered]
            units = [x['units'] for x in ordered]
            return labels, amounts, units

        lab_labels, lab_amounts, lab_counts = bucket_dates(lab_daily, granularity)
        drug_labels, drug_amounts, drug_units = bucket_dates(drug_daily, granularity)

        # Build response
        totals = {
            'sales_total': float(total_sales),
            'cogs': float(cogs),
            'expenses': float(total_expenses),
            'estimated_profit': float(estimated_profit)
        }
        
        response_data = {
            'status': 'success',
            'report_type': 'patients',
            'subtype': subtype,
            'patient_kind': patient_kind or 'all',
            'granularity': granularity,
            'start_date': start_date_str,
            'end_date': end_date_str,
            'data': results,
            'totals': totals,
            'expenses': [{
                'expense_number': e.expense_number,
                'expense_type': e.expense_type,
                'amount': float(e.amount),
                'description': e.description,
                'created_at': e.created_at.strftime('%Y-%m-%d') if e.created_at else None
            } for e in expenses_list],
            'charts': {
                'labels': lab_labels if len(lab_labels) >= len(drug_labels) else drug_labels,
                'lab_amounts': lab_amounts,
                'lab_counts': lab_counts,
                'drug_amounts': drug_amounts,
                'drug_units': drug_units,
                'totals': totals
            },
            'metrics': format_financial_metrics(totals)
        }
        
        # Validate data quality
        issues = validate_report_data(response_data)
        if issues:
            response_data['data_quality_issues'] = issues
        
        # Log report access for audit trail
        log_report_access(
            report_type='patients',
            filters={'start_date': start_date_str, 'end_date': end_date_str, 'granularity': granularity, 'subtype': subtype, 'patient_kind': patient_kind},
            data_count=len(results),
            status='success'
        )

        return jsonify(response_data)
def quality_metrics_report():
    """Clinical quality metrics dashboard (readmission, mortality, outcomes)"""
    if current_user.role not in ['admin', 'clinical_director']:
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        start_date_str = request.args.get('start_date')
        end_date_str = request.args.get('end_date')
        
        if not start_date_str or not end_date_str:
            return jsonify({'error': 'Both start and end dates are required'}), 400
        
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date() + timedelta(days=1)
        
        # Get quality metrics for the period
        quality_data = db.session.query(QualityMetric).filter(
            QualityMetric.admission_date >= start_date,
            QualityMetric.admission_date <= end_date
        ).all()
        
        # Calculate aggregated metrics
        total_admissions = len(quality_data)
        readmissions = len([q for q in quality_data if q.readmitted_within_30d])
        deaths = len([q for q in quality_data if q.discharge_status == 'died'])
        average_los = sum([q.length_of_stay for q in quality_data if q.length_of_stay]) / len([q for q in quality_data if q.length_of_stay]) if any(q.length_of_stay for q in quality_data) else 0
        infections = len([q for q in quality_data if q.infections_acquired])
        adverse_events_total = sum([q.adverse_events for q in quality_data])
        
        response = {
            'status': 'success',
            'report_type': 'quality_metrics',
            'start_date': start_date_str,
            'end_date': end_date_str,
            'metrics': {
                'total_admissions': total_admissions,
                'readmissions': readmissions,
                'readmission_rate_pct': (readmissions / total_admissions * 100) if total_admissions > 0 else 0,
                'deaths': deaths,
                'mortality_rate_pct': (deaths / total_admissions * 100) if total_admissions > 0 else 0,
                'average_los_days': round(average_los, 1),
                'hospital_acquired_infections': infections,
                'infection_rate_pct': (infections / total_admissions * 100) if total_admissions > 0 else 0,
                'total_adverse_events': adverse_events_total,
                'adverse_event_rate_pct': (adverse_events_total / total_admissions * 100) if total_admissions > 0 else 0
            },
            'data': [{
                'patient_id': q.patient_id,
                'admission_date': q.admission_date.isoformat(),
                'discharge_status': q.discharge_status,
                'los_days': q.length_of_stay,
                'readmitted': q.readmitted_within_30d,
                'diagnosis': q.primary_diagnosis,
                'adverse_events': q.adverse_events,
                'infection': q.infections_acquired
            } for q in quality_data]
        }
        
        # Log access
        log_report_access(
            report_type='quality_metrics',
            filters={'start_date': start_date_str, 'end_date': end_date_str},
            data_count=len(quality_data),
            status='success'
        )
        
        return jsonify(response)
    
    except Exception as e:
        app.logger.error(f'Quality metrics report error: {str(e)}', exc_info=True)
        log_report_access(
            report_type='quality_metrics',
            filters={},
            status='error',
            error_msg=str(e)
        )
        return jsonify({'error': 'Failed to generate quality metrics report', 'message': str(e)}), 500


@app.route('/admin/reports/provider-performance', methods=['GET'])
@login_required
def provider_performance_report():
    """Provider (doctor) performance metrics"""
    if current_user.role not in ['admin', 'clinical_director']:
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        start_date_str = request.args.get('start_date')
        end_date_str = request.args.get('end_date')
        
        if not start_date_str or not end_date_str:
            return jsonify({'error': 'Both start and end dates are required'}), 400
        
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date() + timedelta(days=1)
        
        # Get providers and their metrics
        providers = db.session.query(User).filter(User.role.in_(['doctor', 'provider'])).all()
        
        provider_data = []
        for provider in providers:
            # Count patients seen (from sales)
            sales = db.session.query(Sale).filter(
                Sale.user_id == provider.id,
                Sale.created_at >= start_date,
                Sale.created_at <= end_date,
                Sale.status == 'completed'
            ).all()
            
            patients_count = len(set([s.patient_id for s in sales if s.patient_id]))
            total_revenue = sum([s.total_amount for s in sales])
            avg_patient_value = (total_revenue / patients_count) if patients_count > 0 else 0
            
            # Get quality metrics for this provider
            provider_quality = db.session.query(QualityMetric).filter(
                QualityMetric.admission_date >= start_date,
                QualityMetric.admission_date <= end_date
            ).all()
            
            readmissions = len([q for q in provider_quality if q.readmitted_within_30d])
            
            provider_data.append({
                'provider_id': provider.id,
                'provider_name': provider.username,
                'full_name': f"{provider.first_name} {provider.last_name}",
                'patients_seen': patients_count,
                'total_revenue': float(total_revenue),
                'average_patient_value': float(avg_patient_value),
                'readmissions': readmissions,
                'transactions': len(sales)
            })
        
        response = {
            'status': 'success',
            'report_type': 'provider_performance',
            'start_date': start_date_str,
            'end_date': end_date_str,
            'data': provider_data
        }
        
        # Log access
        log_report_access(
            report_type='provider_performance',
            filters={'start_date': start_date_str, 'end_date': end_date_str},
            data_count=len(provider_data),
            status='success'
        )
        
        return jsonify(response)
    
    except Exception as e:
        app.logger.error(f'Provider performance report error: {str(e)}', exc_info=True)
        log_report_access(
            report_type='provider_performance',
            filters={},
            status='error',
            error_msg=str(e)
        )
        return jsonify({'error': 'Failed to generate provider performance report', 'message': str(e)}), 500


@app.route('/admin/reports/budget-variance', methods=['GET'])
@login_required
def budget_variance_report():
    """Budget vs. actual variance analysis"""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        fiscal_year = request.args.get('fiscal_year', str(datetime.now().year), type=str)
        month_str = (request.args.get('month') or '').strip() or None
        month_first = _parse_year_month(month_str) if month_str else None
        
        # Get all department budgets for this year
        budgets = db.session.query(DepartmentBudget).filter(
            DepartmentBudget.fiscal_year == int(fiscal_year)
        ).all()

        # Compute actuals from Transaction OUT flows (year + optional month)
        fy = int(fiscal_year)
        year_start_d = date(fy, 1, 1)
        year_end_d = date(fy, 12, 31)
        year_start_dt, year_end_excl = _dt_range_for_dates(year_start_d, year_end_d)
        computed_year = _sum_outflows_by_department(year_start_dt, year_end_excl)

        computed_month = {}
        month_start_d = None
        month_end_d = None
        if month_first and month_first.year == fy:
            month_start_d, month_end_d = _month_bounds(month_first)
            m_start_dt, m_end_excl = _dt_range_for_dates(month_start_d, month_end_d)
            computed_month = _sum_outflows_by_department(m_start_dt, m_end_excl)
        
        budget_data = []
        for budget in budgets:
            variance_pct = (budget.variance / budget.budgeted_amount * 100) if budget.budgeted_amount > 0 else 0

            dept_key = (budget.department_name or '').strip() or 'unassigned'
            computed_year_actual = float((computed_year or {}).get(dept_key, 0.0))
            computed_month_actual = float((computed_month or {}).get(dept_key, 0.0)) if month_first else None

            computed_variance = computed_year_actual - float(budget.budgeted_amount or 0)
            computed_variance_pct = (computed_variance / float(budget.budgeted_amount or 1) * 100) if float(budget.budgeted_amount or 0) > 0 else 0.0
            
            budget_data.append({
                'department': budget.department_name,
                'budgeted': float(budget.budgeted_amount),
                'actual': float(budget.actual_amount),
                'variance': float(budget.variance),
                'variance_pct': round(variance_pct, 2),
                'status': 'under' if budget.variance < 0 else 'over',
                'notes': budget.notes,
                # New computed values (do not break existing keys)
                'actual_computed_year': round(computed_year_actual, 2),
                'variance_computed_year': round(computed_variance, 2),
                'variance_pct_computed_year': round(computed_variance_pct, 2),
                'month': month_str if (month_first and month_start_d and month_end_d) else None,
                'actual_computed_month': round(computed_month_actual, 2) if computed_month_actual is not None else None,
            })
        
        total_budgeted = sum([b.budgeted_amount for b in budgets])
        total_actual = sum([b.actual_amount for b in budgets])
        total_variance = total_actual - total_budgeted

        total_actual_computed_year = float(sum((computed_year or {}).values()))
        total_variance_computed_year = float(total_actual_computed_year - float(total_budgeted or 0))
        
        response = {
            'status': 'success',
            'report_type': 'budget_variance',
            'fiscal_year': fiscal_year,
            'month': month_str if (month_first and month_start_d and month_end_d) else None,
            'totals': {
                'budgeted': float(total_budgeted),
                'actual': float(total_actual),
                'variance': float(total_variance),
                'variance_pct': round((total_variance / total_budgeted * 100) if total_budgeted > 0 else 0, 2),
                'actual_computed_year': round(total_actual_computed_year, 2),
                'variance_computed_year': round(total_variance_computed_year, 2),
                'variance_pct_computed_year': round((total_variance_computed_year / total_budgeted * 100) if total_budgeted > 0 else 0, 2),
            },
            'data': budget_data
        }
        
        # Log access
        log_report_access(
            report_type='budget_variance',
            filters={'fiscal_year': fiscal_year},
            data_count=len(budget_data),
            status='success'
        )
        
        return jsonify(response)
    
    except Exception as e:
        app.logger.error(f'Budget variance report error: {str(e)}', exc_info=True)
        log_report_access(
            report_type='budget_variance',
            filters={},
            status='error',
            error_msg=str(e)
        )
        return jsonify({'error': 'Failed to generate budget variance report', 'message': str(e)}), 500


@app.route('/admin/reports/budget-alerts', methods=['GET'])
@login_required
def budget_alerts_report():
    """Monthly budget alerts (OK/WARNING/EXCEEDED) based on computed Transaction OUT spend."""
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        month_str = (request.args.get('month') or '').strip() or None
        month_first = _parse_year_month(month_str) if month_str else None
        if not month_first:
            now = get_eat_now()
            month_first = date(now.year, now.month, 1)
            month_str = month_first.strftime('%Y-%m')

        start_d, end_d = _month_bounds(month_first)
        start_dt, end_excl = _dt_range_for_dates(start_d, end_d)
        spend_by_dept = _sum_outflows_by_department(start_dt, end_excl)

        fiscal_year = int(month_first.year)
        budgets = db.session.query(DepartmentBudget).filter(DepartmentBudget.fiscal_year == fiscal_year).all()

        warning_ratio = 0.80
        rows = []
        warned_depts = []

        for budget in (budgets or []):
            dept = (budget.department_name or '').strip() or 'unassigned'
            budget_year = float(budget.budgeted_amount or 0)
            budget_month = float((budget_year / 12.0) if budget_year else 0.0)
            actual_month = float((spend_by_dept or {}).get(dept, 0.0))

            if budget_month <= 0:
                status = 'OK'
                ratio = None
            else:
                ratio = actual_month / budget_month
                if ratio >= 1.0:
                    status = 'EXCEEDED'
                elif ratio >= warning_ratio:
                    status = 'WARNING'
                else:
                    status = 'OK'

            if status in ('WARNING', 'EXCEEDED'):
                warned_depts.append((dept, status, budget_month, actual_month))

            rows.append({
                'department': dept,
                'month': month_str,
                'budget_month': round(budget_month, 2),
                'actual_month': round(actual_month, 2),
                'ratio': round(ratio, 4) if ratio is not None else None,
                'status': status,
            })

        # Best-effort notifications (avoid duplicates for the same month/department/status)
        try:
            if warned_depts:
                admins = User.query.filter(User.role == 'admin').all()
                for dept, status, budget_month, actual_month in warned_depts:
                    title = f"Budget {status}: {dept} ({month_str})"
                    message = f"{dept} spend {round(actual_month, 2)} / {round(budget_month, 2)} for {month_str}."

                    for admin_user in (admins or []):
                        exists_q = Notification.query.filter(
                            Notification.user_id == admin_user.id,
                            Notification.title == title,
                        )
                        if start_dt is not None:
                            exists_q = exists_q.filter(Notification.created_at >= start_dt)
                        if exists_q.first():
                            continue

                        db.session.add(Notification(
                            user_id=admin_user.id,
                            title=title,
                            message=message,
                            is_read=False,
                            created_at=get_eat_now(),
                        ))
                db.session.commit()
        except Exception:
            db.session.rollback()

        return jsonify({
            'status': 'success',
            'report_type': 'budget_alerts',
            'month': month_str,
            'warning_ratio': warning_ratio,
            'data': rows,
        })
    except Exception as e:
        app.logger.error(f'Budget alerts report error: {str(e)}', exc_info=True)
        return jsonify({'error': 'Failed to generate budget alerts report', 'message': str(e)}), 500


# ==================== END ENHANCED REPORTING ENDPOINTS ====================

@app.route('/admin/transactions')
@login_required
def manage_transactions():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    transactions = Transaction.query.order_by(Transaction.created_at.desc()).all()
    return render_template('admin/transactions.html', transactions=transactions)

# Configuration for backup
BACKUP_CONFIG = {
    'local_storage_path': os.path.join(app.instance_path, 'backups'),
    's3_bucket': (os.getenv('AWS_BACKUP_BUCKET', '') or '').strip(),
    'encryption_key': os.getenv('BACKUP_ENCRYPTION_KEY'),
    'tables_to_backup': [
        'appointments', 'audit_logs', 'beds', 'debt_payments', 
        'debtors', 'drug', 'drug_dosage', 'employees', 'expenses', 
        'patients', 'patient_services', 'payroll', 'purchase_items', 'purchases', 'sales', 
        'service_items', 'services', 'transactions', 'user', 'wards'
    ]
}
if not BACKUP_CONFIG['encryption_key']:
    raise RuntimeError("Missing BACKUP_ENCRYPTION_KEY")

# Initialize S3 client if configured
_S3_BUCKET_NAME_RE = re.compile(r'^[a-zA-Z0-9.\-_]{1,255}$')


def _is_valid_s3_bucket_name(name: str) -> bool:
    n = (name or '').strip()
    return bool(n and _S3_BUCKET_NAME_RE.match(n))


_aws_access_key_id = (os.getenv('AWS_ACCESS_KEY_ID') or '').strip()
_aws_secret_access_key = (os.getenv('AWS_SECRET_ACCESS_KEY') or '').strip()
_aws_region = (os.getenv('AWS_REGION', 'us-east-1') or 'us-east-1').strip()
_s3_bucket_name = (BACKUP_CONFIG.get('s3_bucket') or '').strip()

if _aws_access_key_id and _aws_secret_access_key and _is_valid_s3_bucket_name(_s3_bucket_name):
    s3_client = boto3.client(
        's3',
        aws_access_key_id=_aws_access_key_id,
        aws_secret_access_key=_aws_secret_access_key,
        region_name=_aws_region
    )
else:
    s3_client = None
    if _aws_access_key_id or _aws_secret_access_key or _s3_bucket_name:
        reasons = []
        if not _aws_access_key_id:
            reasons.append('AWS_ACCESS_KEY_ID missing')
        if not _aws_secret_access_key:
            reasons.append('AWS_SECRET_ACCESS_KEY missing')
        if not _s3_bucket_name:
            reasons.append('AWS_BACKUP_BUCKET not set')
        elif not _is_valid_s3_bucket_name(_s3_bucket_name):
            reasons.append('AWS_BACKUP_BUCKET invalid')
        app.logger.warning('S3 backups disabled (%s). Using local backups.', '; '.join(reasons))


def has_backup_access() -> bool:
    """Check if current session has valid backup access."""
    email = session.get('backup_authenticated_email')
    if not email:
        return False
    
    backup_user = BackupLoginUser.query.filter_by(email=email, is_active=True, is_verified=True).first()
    return backup_user is not None


def require_backup_access(f):
    """Decorator to require backup login before accessing backup features."""
    from functools import wraps
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not has_backup_access():
            flash('You must log in to backup access first', 'warning')
            return redirect(url_for('backup_login_page'))
        return f(*args, **kwargs)
    return decorated_function


@app.route('/admin/backup', methods=['GET', 'POST'])
@login_required
@require_backup_access
def backup_management():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'create_backup':
            try:
                # Create a new backup record
                backup = BackupRecord(
                    backup_type='manual',
                    user_id=current_user.id,
                    notes=request.form.get('notes', ''),
                    status='in_progress'
                )
                db.session.add(backup)
                db.session.commit()
                
                # Run backup in background
                from threading import Thread
                user_id = current_user.id
                thread = Thread(target=create_backup, args=(backup.id, user_id), daemon=True)
                thread.start()
                
                flash('Backup process started successfully. You will be notified when complete.', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error initiating backup: {str(e)}', 'danger')
        
        elif action == 'restore_backup':
            backup_id = request.form.get('backup_id')
            backup = _db_get_or_404(BackupRecord, backup_id)
            
            try:
                # Verify backup exists
                if not verify_backup_exists(backup):
                    flash('Backup file not found', 'danger')
                    return redirect(url_for('backup_management'))

                # Mark restore as started (stored in notes so UI can poll without schema changes)
                try:
                    backup.notes = _backup_notes_with_restore_status(backup.notes, {
                        'status': 'in_progress',
                        'started_at': get_eat_now().isoformat(),
                        'message': 'Restore started. Please wait...',
                    })
                    db.session.commit()
                except Exception:
                    try:
                        db.session.rollback()
                    except Exception:
                        pass
                
                # Run restore in background
                from threading import Thread
                thread = Thread(target=restore_backup, args=(backup.id,), daemon=True)
                thread.start()
                
                flash('Restore process started successfully. The system may be unavailable during restoration.', 'warning')
            except Exception as e:
                flash(f'Error initiating restore: {str(e)}', 'danger')
        
        elif action == 'download_backup':
            backup_id = request.form.get('backup_id')
            backup = _db_get_or_404(BackupRecord, backup_id)
            
            try:
                if not verify_backup_exists(backup):
                    flash('Backup file not found', 'danger')
                    return redirect(url_for('backup_management'))
                
                # Get backup file
                backup_file = get_backup_file(backup)
                
                # Create a response with the backup file
                decrypt = request.form.get('decrypt') == 'true'
                if not decrypt:
                    response = send_file(
                        backup_file,
                        as_attachment=True,
                        download_name=f"backup_{backup.backup_id}.zip.enc",
                        mimetype='application/octet-stream'
                    )
                else:
                    # Decrypt in memory to avoid writing sensitive data to disk
                    try:
                        encrypted_data = backup_file.read()
                        cipher = Fernet(BACKUP_CONFIG['encryption_key'].encode())
                        decrypted_data = cipher.decrypt(encrypted_data)
                        
                        # Create an in-memory file-like object
                        decrypted_file = io.BytesIO(decrypted_data)
                        
                        response = send_file(
                            decrypted_file,
                            as_attachment=True,
                            download_name=f"backup_{backup.backup_id}.zip",
                            mimetype='application/zip'
                        )
                    except Exception as e:
                        flash(f'Error decrypting backup: {str(e)}', 'danger')
                        return redirect(url_for('backup_management'))
                
                # Log download activity
                log_audit('download', 'BackupRecord', backup.id, None, {'downloaded_by': current_user.id})
                
                return response
            except Exception as e:
                flash(f'Error downloading backup: {str(e)}', 'danger')
        
        elif action == 'delete_backup':
            backup_id = request.form.get('backup_id')
            backup = _db_get_or_404(BackupRecord, backup_id)
            
            try:
                # Delete from storage
                delete_backup_file(backup)
                
                # Delete record
                db.session.delete(backup)
                db.session.commit()
                
                flash('Backup deleted successfully', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error deleting backup: {str(e)}', 'danger')
        
        return redirect(url_for('backup_management'))
    
    # Get all backups ordered by most recent
    backups = BackupRecord.query.order_by(BackupRecord.timestamp.desc()).all()

    # Attach parsed stats/clean notes for display (no schema changes).
    for b in backups:
        try:
            b.exec_stats = _backup_extract_stats(getattr(b, 'notes', None))
            b.display_notes = _backup_strip_stats(getattr(b, 'notes', None))
        except Exception:
            b.exec_stats = None
            b.display_notes = getattr(b, 'notes', None)
    
    # Get disaster recovery plans
    recovery_plans = DisasterRecoveryPlan.query.all()

    # Get schedule config (optional; DB may not be migrated yet)
    schedule_cfg = _get_or_create_schedule_config()

    def _is_main_admin(u: User) -> bool:
        try:
            return bool(u) and (str(u.role) == 'admin') and int(u.id) == 1
        except Exception:
            return False

    admin_users = []
    try:
        # Role is stored via EncryptedType; filter in Python for reliability.
        users = User.query.order_by(User.id.asc()).all()
        admin_users = [u for u in users if str(getattr(u, 'role', '') or '') == 'admin']
    except Exception:
        admin_users = []

    storage_label = 'Unknown'
    try:
        storage_label = f"S3: {BACKUP_CONFIG.get('s3_bucket', '-') }" if s3_client else f"Local: {BACKUP_CONFIG.get('local_storage_path', '-') }"
    except Exception:
        pass

    next_scheduled_label = 'Daily at 2:00 AM'
    try:
        if schedule_cfg and schedule_cfg.daily_enabled:
            next_scheduled_label = f"Daily at {schedule_cfg.daily_time or '02:00'}"
        elif schedule_cfg and not schedule_cfg.daily_enabled:
            next_scheduled_label = 'Disabled'
    except Exception:
        pass

    restricted_attempts = []
    try:
        if _is_main_admin(current_user):
            restricted_attempts = AuditLog.query.filter_by(action='backup_login_restricted')\
                .order_by(AuditLog.created_at.desc()).limit(10).all()
    except Exception:
        restricted_attempts = []

    return render_template(
        'admin/backup.html',
        backups=backups,
        recovery_plans=recovery_plans,
        backup_user_email=session.get('backup_authenticated_email'),
        backup_config=BACKUP_CONFIG,
        storage_label=storage_label,
        schedule_cfg=schedule_cfg,
        next_scheduled_label=next_scheduled_label,
        admin_users=admin_users,
        is_main_admin=_is_main_admin(current_user),
        restricted_attempts=restricted_attempts,
    )


# ============================================================================
# BACKUP LOGIN SYSTEM - AUTHENTICATION & ACCESS CONTROL
# ============================================================================

def _get_or_create_backup_login_user(email: str, created_by_admin_id: int) -> 'BackupLoginUser':
    """Get or create a BackupLoginUser record.

    NOTE: `created_by_admin_id` is used as the *linked admin user_id* for access restriction.
    """
    user = BackupLoginUser.query.filter_by(email=email).first()
    if not user:
        user = BackupLoginUser(
            email=email.lower().strip(),
            created_by_admin_id=created_by_admin_id,
            is_verified=False,
            is_active=False
        )
        db.session.add(user)
        db.session.commit()
    else:
        # Keep linkage in sync if reusing an existing record (e.g., re-inviting a user)
        try:
            if created_by_admin_id and user.created_by_admin_id != created_by_admin_id:
                user.created_by_admin_id = created_by_admin_id
                db.session.commit()
        except Exception:
            db.session.rollback()
    return user


def _send_backup_login_otp(email: str, otp_code: str) -> bool:
    """Send OTP to backup login email address with production-ready handling.
    
    Args:
        email: Backup login email address
        otp_code: 6-digit OTP code
    
    Returns:
        bool: True if sent successfully, False otherwise
    """
    from utils.email_templates import OTPEmailTemplate
    
    try:
        # Validate inputs
        email = str(email or '').strip()
        otp_code = str(otp_code or '').strip()
        
        if not _is_valid_email_address(email):
            app.logger.error(f"Invalid backup email: {email}")
            return False
        
        if not otp_code or len(otp_code) != 6 or not otp_code.isdigit():
            app.logger.error(f"Invalid OTP code format: {otp_code}")
            return False
        
        # Use template for backup OTP
        html, text_body = OTPEmailTemplate.backup_otp(otp_code, minutes_valid=10)
        
        _send_backup_email(
            recipient=email,
            subject="🔐 Your Backup Access Verification Code",
            html=html,
        )
        
        app.logger.info(f"Backup OTP sent to {email}")
        return True
        
    except Exception as e:
        app.logger.error(f'Failed to send backup login OTP to {email}: {e}', exc_info=True)
        return False


def _verify_backup_password_policy(password: str) -> tuple[bool, str]:
    """Validate backup access password meets security requirements."""
    if not password or len(password) < 8:
        return False, 'Password must be at least 8 characters long'
    if not re.search(r'[A-Z]', password):
        return False, 'Password must contain at least one uppercase letter'
    if not re.search(r'[a-z]', password):
        return False, 'Password must contain at least one lowercase letter'
    if not re.search(r'\d', password):
        return False, 'Password must contain at least one digit'
    if not re.search(r'[^A-Za-z0-9]', password):
        return False, 'Password must contain at least one special character'
    return True, ''


def _wants_json_response() -> bool:
    """Detect fetch/AJAX requests so routes can return JSON instead of redirects."""
    try:
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return True
        accept = (request.headers.get('Accept') or '').lower()
        if 'application/json' in accept:
            return True
        if request.is_json:
            return True
    except Exception:
        return False
    return False


def _check_is_main_admin() -> bool:
    """Check if current user is the main admin (ID=1)."""
    try:
        return bool(current_user) and int(current_user.id) == 1
    except (AttributeError, TypeError, ValueError):
        return False


def _log_backup_access_attempt(email: str, success: bool, ip_address: str = None):
    """Log backup access login attempts for security auditing."""
    try:
        ip_address = ip_address or request.remote_addr
        action = 'backup_login_success' if success else 'backup_login_failure'
        log_audit(
            action=action,
            table='BackupLoginUser',
            user_id=current_user.id if current_user.is_authenticated else None,
            changes={
                'email': email,
                'ip_address': ip_address,
                'user_agent': request.user_agent.string if hasattr(request, 'user_agent') else None
            }
        )
    except Exception as e:
        app.logger.error(f'Failed to log backup access attempt: {e}')


def _notify_unauthorized_backup_attempt(email: str, ip_address: str = None, user_agent: str = None):
    """Alert main admin of unauthorized backup access attempt."""
    try:
        main_admin = User.query.filter_by(id=1).first()
        if not main_admin or not main_admin.email:
            return
        
        ip_address = ip_address or request.remote_addr if request else 'Unknown'
        timestamp = get_eat_now().strftime('%Y-%m-%d %H:%M:%S EAT')
        
        subject = "⚠️ Unauthorized Backup Access Attempt"
        html = f"""
        <h2>Unauthorized Backup Login Attempt Detected</h2>
        <p><strong>Email:</strong> {email}</p>
        <p><strong>Time:</strong> {timestamp}</p>
        <p><strong>IP Address:</strong> {ip_address}</p>
        <p><strong>User Agent:</strong> {user_agent or 'Not available'}</p>
        <p>Someone attempted to access backup features with this email but failed verification.</p>
        <p>Log in to your admin dashboard for more details.</p>
        """
        
        _send_backup_email(
            recipient=main_admin.email,
            subject=subject,
            html=html
        )
    except Exception as e:
        app.logger.error(f'Failed to notify main admin of unauthorized attempt: {e}')


def _notify_restricted_backup_attempt(*, email: str, attempted_by_user_id: int | None, ip_address: str | None, user_agent: str | None) -> None:
    """Notify main admin when valid credentials are used by the wrong logged-in admin."""
    try:
        main_admin = User.query.filter_by(id=1).first()
        if not main_admin or not main_admin.email:
            return

        ts = get_eat_now().strftime('%Y-%m-%d %H:%M:%S EAT')
        subject = "⚠️ Restricted Backup Login Attempt"
        html = (
            "<h2>Restricted Backup Login Attempt</h2>"
            f"<p><strong>Backup Email:</strong> {email}</p>"
            f"<p><strong>Time:</strong> {ts}</p>"
            f"<p><strong>Attempted By Admin ID:</strong> {attempted_by_user_id or 'Unknown'}</p>"
            f"<p><strong>IP Address:</strong> {ip_address or 'Unknown'}</p>"
            f"<p><strong>User Agent:</strong> {user_agent or 'Not available'}</p>"
            "<p>The email/password were correct, but the logged-in admin is not the one linked to these backup credentials.</p>"
        )

        _send_backup_email(recipient=main_admin.email, subject=subject, html=html)
    except Exception:
        app.logger.exception('Failed to send restricted backup attempt notification')


@app.route('/admin/backup/login/register/email', methods=['GET', 'POST'])
@login_required
def backup_login_register_email():
    """Step 1: Main admin registers backup email and requests OTP."""
    if current_user.role != 'admin':
        flash('Only admins can register backup access', 'danger')
        return redirect(url_for('backup_management'))
    
    if not _check_is_main_admin():
        flash('Only the main admin can set up backup access', 'danger')
        return redirect(url_for('backup_management'))
    
    if request.method == 'POST':
        email = (request.form.get('backup_email') or '').strip().lower()
        # Defensively normalize common copy/paste issues.
        email = email.strip('<>').strip()
        email = email.replace(' ', '')
        if email.endswith('.'):
            email = email[:-1]
        
        if not email or '@' not in email:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Please enter a valid email address'}), 400
            flash('Please enter a valid email address', 'danger')
            return redirect(url_for('backup_login_register_email'))
        
        existing = BackupLoginUser.query.filter_by(email=email).first()
        if existing and existing.is_active and existing.is_verified:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'This email already has backup access registered'}), 409
            flash('This email already has backup access registered', 'warning')
            return redirect(url_for('backup_login_register_email'))
        
        backup_user = _get_or_create_backup_login_user(email, current_user.id)
        
        otp_code = _generate_backup_otp_code()
        backup_user.otp_hash = _backup_code_hash(otp_code)
        backup_user.otp_expires_at = get_eat_now() + timedelta(minutes=10)
        backup_user.is_verified = False
        db.session.commit()
        
        if not _send_backup_login_otp(email, otp_code):
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Failed to send OTP email. Check email configuration and try again'}), 500
            flash('Failed to send OTP email. Check email configuration and try again', 'danger')
            return redirect(url_for('backup_login_register_email'))
        
        session['backup_register_email'] = email
        if _wants_json_response():
            return jsonify({'success': True, 'next': 'otp', 'email': email}), 200
        flash(f'OTP code sent to {email}. Check your inbox and enter the code to proceed', 'success')
        return redirect(url_for('backup_login_register_otp'))
    
    return render_template(
        'admin/backup_login_register_email.html',
        page_title='Register Backup Access - Step 1: Email'
    )


@app.route('/admin/backup/login/register/otp', methods=['GET', 'POST'])
@login_required
def backup_login_register_otp():
    """Step 2: Main admin verifies OTP sent to email."""
    if current_user.role != 'admin' or not _check_is_main_admin():
        flash('Unauthorized', 'danger')
        return redirect(url_for('backup_management'))
    
    email = session.get('backup_register_email')
    if not email:
        if _wants_json_response():
            return jsonify({'success': False, 'message': 'Please start from Step 1: Register Email'}), 400
        flash('Please start from Step 1: Register Email', 'warning')
        return redirect(url_for('backup_login_register_email'))
    
    if request.method == 'POST':
        otp_code = (request.form.get('otp_code') or '').strip()
        
        backup_user = BackupLoginUser.query.filter_by(email=email).first()
        if not backup_user:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Email not found. Please try again'}), 404
            flash('Email not found. Please try again', 'danger')
            return redirect(url_for('backup_login_register_email'))
        
        now = get_eat_now()
        expires_at = _as_eat_aware(backup_user.otp_expires_at)
        if not expires_at or expires_at < now:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'OTP expired. Please request a new one'}), 400
            flash('OTP expired. Please request a new one', 'danger')
            return redirect(url_for('backup_login_register_email'))
        
        if _backup_code_hash(otp_code) != backup_user.otp_hash:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Invalid OTP code. Please try again'}), 400
            flash('Invalid OTP code. Please try again', 'danger')
            return redirect(url_for('backup_login_register_otp'))
        
        backup_user.is_verified = True
        backup_user.verified_at = now
        backup_user.otp_hash = None
        backup_user.otp_expires_at = None
        db.session.commit()
        
        session['backup_register_verified_email'] = email
        if _wants_json_response():
            return jsonify({'success': True, 'next': 'password', 'email': email}), 200
        flash('Email verified successfully. Now create your backup access password', 'success')
        return redirect(url_for('backup_login_register_password'))
    
    return render_template(
        'admin/backup_login_register_otp.html',
        email=email,
        page_title='Register Backup Access - Step 2: Verify OTP'
    )


@app.route('/admin/backup/login/register/password', methods=['GET', 'POST'])
@login_required
def backup_login_register_password():
    """Step 3: Main admin sets backup access password."""
    if current_user.role != 'admin' or not _check_is_main_admin():
        flash('Unauthorized', 'danger')
        return redirect(url_for('backup_management'))
    
    email = session.get('backup_register_verified_email')
    if not email:
        if _wants_json_response():
            return jsonify({'success': False, 'message': 'Email verification required first'}), 400
        flash('Email verification required first', 'warning')
        return redirect(url_for('backup_login_register_email'))
    
    if request.method == 'POST':
        password = request.form.get('password') or ''
        confirm = request.form.get('confirm_password') or ''
        
        if password != confirm:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Passwords do not match'}), 400
            flash('Passwords do not match', 'danger')
            return redirect(url_for('backup_login_register_password'))
        
        ok, msg = _verify_backup_password_policy(password)
        if not ok:
            if _wants_json_response():
                return jsonify({'success': False, 'message': msg}), 400
            flash(msg, 'danger')
            return redirect(url_for('backup_login_register_password'))
        
        backup_user = BackupLoginUser.query.filter_by(email=email).first()
        if not backup_user:
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Email record not found. Please start over'}), 404
            flash('Email record not found. Please start over', 'danger')
            return redirect(url_for('backup_login_register_email'))
        
        backup_user.password_hash = generate_password_hash(password)
        backup_user.is_active = True
        backup_user.failed_attempts = 0
        db.session.commit()
        
        session.pop('backup_register_email', None)
        session.pop('backup_register_verified_email', None)
        
        app.logger.info(f'Backup access registered for: {email} by admin {current_user.email}')
        
        if _wants_json_response():
            return jsonify({'success': True, 'next': 'login', 'email': email}), 200
        flash('✓ Backup access successfully registered! You can now login to access backups', 'success')
        return redirect(url_for('backup_login_page'))
    
    return render_template(
        'admin/backup_login_register_password.html',
        email=email,
        page_title='Register Backup Access - Step 3: Set Password'
    )


@app.route('/admin/backup/login', methods=['GET', 'POST'])
@login_required
def backup_login_page():
    """Backup access login page - handles first-time and consecutive login."""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    # If already logged into backup, redirect to management
    if 'backup_authenticated_email' in session:
        return redirect(url_for('backup_management'))
    
    if request.method == 'POST':
        email = (request.form.get('email') or '').strip().lower()
        password = request.form.get('password') or ''
        
        backup_user = BackupLoginUser.query.filter_by(email=email).first()
        
        if not backup_user or not backup_user.is_active or not backup_user.is_verified:
            _log_backup_access_attempt(email, False)
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Invalid email or password'}), 401
            flash('Invalid email or password', 'danger')
            return redirect(url_for('backup_login_page'))
        
        if not check_password_hash(backup_user.password_hash, password):
            backup_user.failed_attempts += 1
            backup_user.last_login_attempt = get_eat_now()
            db.session.commit()
            
            if backup_user.failed_attempts > 5:
                backup_user.is_active = False
                db.session.commit()
                app.logger.warning(f'Backup user locked due to failed attempts: {email}')
                
                try:
                    main_admin = User.query.filter_by(id=1).first()
                    if main_admin and main_admin.email:
                        _send_backup_email(
                            recipient=main_admin.email,
                            subject='⚠️ Backup Access Locked - Too Many Failed Attempts',
                            html=f'<p>Backup user <strong>{email}</strong> has been locked after 5+ failed login attempts.</p>'
                        )
                except Exception as e:
                    app.logger.error(f'Failed to notify main admin: {e}')
            
            _log_backup_access_attempt(email, False)
            if _wants_json_response():
                return jsonify({'success': False, 'message': f"Invalid password. {max(0, 6 - backup_user.failed_attempts)} attempts remaining"}), 401
            flash(f'Invalid password. {max(0, 6 - backup_user.failed_attempts)} attempts remaining', 'danger')
            return redirect(url_for('backup_login_page'))
        
        # Restrict usage to the linked admin user_id (prevents other admins using someone else's backup credentials)
        try:
            if backup_user.created_by_admin_id and int(current_user.id) != int(backup_user.created_by_admin_id):
                backup_user.last_login_attempt = get_eat_now()
                db.session.commit()

                _log_backup_access_attempt(email, False)
                # Dashboard notification via audit log
                log_audit(
                    action='backup_login_restricted',
                    table='BackupLoginUser',
                    record_id=getattr(backup_user, 'id', None),
                    user_id=int(current_user.id) if current_user.is_authenticated else None,
                    changes={
                        'email': email,
                        'linked_admin_id': int(backup_user.created_by_admin_id) if backup_user.created_by_admin_id else None,
                        'attempted_by_admin_id': int(current_user.id) if current_user.is_authenticated else None,
                        'ip_address': request.remote_addr,
                        'user_agent': request.user_agent.string if hasattr(request, 'user_agent') else None,
                    },
                )
                _notify_restricted_backup_attempt(
                    email=email,
                    attempted_by_user_id=int(current_user.id) if current_user.is_authenticated else None,
                    ip_address=request.remote_addr,
                    user_agent=request.user_agent.string if hasattr(request, 'user_agent') else None,
                )
                if _wants_json_response():
                    return jsonify({'success': False, 'message': 'These backup credentials are restricted to a different admin account.'}), 403
                flash('These backup credentials are restricted to a different admin account.', 'danger')
                return redirect(url_for('backup_login_page'))
        except Exception:
            # If anything goes wrong with restriction checks, fail closed.
            if _wants_json_response():
                return jsonify({'success': False, 'message': 'Unable to validate backup access restriction. Please contact the main admin.'}), 403
            flash('Unable to validate backup access restriction. Please contact the main admin.', 'danger')
            return redirect(url_for('backup_login_page'))

        backup_user.last_successful_login = get_eat_now()
        backup_user.failed_attempts = 0
        db.session.commit()

        session['backup_authenticated_email'] = email
        session['backup_authenticated_time'] = get_eat_now().isoformat()

        _log_backup_access_attempt(email, True)
        app.logger.info(f'Backup access authenticated: {email}')

        if _wants_json_response():
            return jsonify({'success': True, 'email': email, 'redirect': url_for('backup_management')}), 200

        flash(f'✓ Welcome to Backup Access, {email}!', 'success')
        return redirect(url_for('backup_management'))
    
    return render_template('admin/backup_login.html', page_title='Backup Access Login')



@app.route('/admin/backup/logout', methods=['POST', 'GET'])
def backup_logout():
    """Logout from backup access session."""
    email = session.get('backup_authenticated_email')
    session.pop('backup_authenticated_email', None)
    session.pop('backup_authenticated_time', None)
    
    if email:
        app.logger.info(f'Backup access logout: {email}')
    
    flash('Logged out from backup access', 'info')
    return redirect(url_for('backup_login_page'))


@app.route('/admin/backup/users', methods=['GET', 'POST'])
@login_required
@require_backup_access
def backup_manage_users():
    """Manage backup access users (main admin only)."""
    if not _check_is_main_admin():
        flash('Only main admin can manage backup users', 'danger')
        return redirect(url_for('backup_management'))
    
    # Get all backup users
    backup_users = BackupLoginUser.query.order_by(BackupLoginUser.created_at.desc()).all()
    
    # Get admins for adding new users (role is encrypted; filter in Python)
    try:
        users = User.query.order_by(User.id.asc()).all()
        admins = [u for u in users if str(getattr(u, 'role', '') or '') == 'admin']
    except Exception:
        admins = []

    add_stage = session.get('backup_add_stage')
    pending_user_email = session.get('backup_add_email')
    
    return render_template(
        'admin/backup_manage_users.html',
        backup_users=backup_users,
        admins=admins,
        add_stage=add_stage,
        pending_user_email=pending_user_email,
        page_title='Manage Backup Access Users'
    )


@app.route('/admin/backup/users/add', methods=['POST'])
@login_required
@require_backup_access
def backup_add_user():
    """Main admin adds another admin to backup access (OTP + password set by main admin)."""
    if not _check_is_main_admin():
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    action = (request.form.get('action') or 'request_otp').strip()

    # Step 1: Request OTP
    if action in {'request_otp', 'resend_otp'}:
        if action == 'resend_otp':
            # For resend, use the pending email from session
            email = (session.get('backup_add_email') or '').strip().lower()
            bu_id = session.get('backup_add_user_id')

            if not email or not bu_id:
                flash('No pending backup-user invitation found. Start again.', 'warning')
                session.pop('backup_add_stage', None)
                session.pop('backup_add_email', None)
                session.pop('backup_add_user_id', None)
                return redirect(url_for('backup_manage_users'))

            backup_user = _db_get(BackupLoginUser, int(bu_id))
            if not backup_user or (backup_user.email or '').strip().lower() != email:
                flash('Pending user not found. Start again.', 'danger')
                session.pop('backup_add_stage', None)
                session.pop('backup_add_email', None)
                session.pop('backup_add_user_id', None)
                return redirect(url_for('backup_manage_users'))
        else:
            # For initial request
            admin_user_id = request.form.get('admin_user_id')
            if not admin_user_id:
                flash('Please select an admin to add.', 'danger')
                return redirect(url_for('backup_manage_users'))

            admin_user = _db_get(User, int(admin_user_id))
            if not admin_user or str(getattr(admin_user, 'role', '') or '') != 'admin':
                flash('Selected user is not a valid admin.', 'danger')
                return redirect(url_for('backup_manage_users'))

            email = (str(getattr(admin_user, 'email', '') or '')).strip().lower()
            if not email or '@' not in email:
                flash('Selected admin does not have a valid email address.', 'danger')
                return redirect(url_for('backup_manage_users'))

            backup_user = _get_or_create_backup_login_user(email, int(admin_user.id))
            if backup_user.is_verified and backup_user.is_active and backup_user.password_hash:
                flash('This admin already has active backup access.', 'warning')
                return redirect(url_for('backup_manage_users'))

        # Generate and send OTP (common for both request and resend)
        otp_code = _generate_backup_otp_code()
        backup_user.otp_hash = _backup_code_hash(otp_code)
        backup_user.otp_expires_at = get_eat_now() + timedelta(minutes=10)
        backup_user.is_verified = False
        backup_user.is_active = False
        db.session.commit()

        if not _send_backup_login_otp(email, otp_code):
            flash('Failed to send OTP email', 'danger')
            return redirect(url_for('backup_manage_users'))

        session['backup_add_stage'] = 'otp_sent'
        session['backup_add_email'] = email
        session['backup_add_user_id'] = backup_user.id

        if action == 'resend_otp':
            log_audit(
                action='backup_user_invite_otp_resent',
                table='BackupLoginUser',
                record_id=int(backup_user.id),
                user_id=int(current_user.id),
                changes={'email': email},
            )
            flash(f'OTP resent to {email}. Enter the OTP to verify.', 'success')
        else:
            log_audit(
                action='backup_user_invite_otp_sent',
                table='BackupLoginUser',
                record_id=int(backup_user.id),
                user_id=int(current_user.id),
                changes={'email': email, 'linked_admin_id': int(backup_user.created_by_admin_id)},
            )
            flash(f'OTP sent to {email}. Enter the OTP to verify, then set a password.', 'success')

        return redirect(url_for('backup_manage_users'))

    # Step 2: Verify OTP
    if action == 'verify_otp':
        otp_code = (request.form.get('otp_code') or '').strip()
        email = (session.get('backup_add_email') or '').strip().lower()
        bu_id = session.get('backup_add_user_id')

        if not email or not bu_id:
            flash('No pending backup-user invitation found. Start again.', 'warning')
            session.pop('backup_add_stage', None)
            session.pop('backup_add_email', None)
            session.pop('backup_add_user_id', None)
            return redirect(url_for('backup_manage_users'))

        backup_user = _db_get(BackupLoginUser, int(bu_id))
        if not backup_user or (backup_user.email or '').strip().lower() != email:
            flash('Pending user not found. Start again.', 'danger')
            session.pop('backup_add_stage', None)
            session.pop('backup_add_email', None)
            session.pop('backup_add_user_id', None)
            return redirect(url_for('backup_manage_users'))

        now = get_eat_now()
        expires_at = _as_eat_aware(backup_user.otp_expires_at)
        if not backup_user.otp_hash or not expires_at or expires_at < now:
            flash('OTP expired. Send a new OTP.', 'danger')
            session['backup_add_stage'] = 'none'
            return redirect(url_for('backup_manage_users'))

        if _backup_code_hash(otp_code) != backup_user.otp_hash:
            flash('Invalid OTP. Please try again.', 'danger')
            return redirect(url_for('backup_manage_users'))

        backup_user.is_verified = True
        backup_user.verified_at = now
        backup_user.otp_hash = None
        backup_user.otp_expires_at = None
        db.session.commit()

        session['backup_add_stage'] = 'verified'

        log_audit(
            action='backup_user_invite_verified',
            table='BackupLoginUser',
            record_id=int(backup_user.id),
            user_id=int(current_user.id),
            changes={'email': email, 'linked_admin_id': int(backup_user.created_by_admin_id)},
        )

        flash('Email verified. Now set a password for this admin.', 'success')
        return redirect(url_for('backup_manage_users'))

    # Step 3: Set password
    if action == 'set_password':
        email = (session.get('backup_add_email') or '').strip().lower()
        bu_id = session.get('backup_add_user_id')
        if not email or not bu_id or session.get('backup_add_stage') != 'verified':
            flash('OTP verification required before setting a password.', 'warning')
            return redirect(url_for('backup_manage_users'))

        password = request.form.get('password') or ''
        confirm = request.form.get('confirm_password') or ''
        if password != confirm:
            flash('Passwords do not match.', 'danger')
            return redirect(url_for('backup_manage_users'))

        ok, msg = _verify_backup_password_policy(password)
        if not ok:
            flash(msg, 'danger')
            return redirect(url_for('backup_manage_users'))

        backup_user = _db_get(BackupLoginUser, int(bu_id))
        if not backup_user or (backup_user.email or '').strip().lower() != email:
            flash('Pending user not found. Start again.', 'danger')
            return redirect(url_for('backup_manage_users'))

        backup_user.password_hash = generate_password_hash(password)
        backup_user.is_active = True
        backup_user.failed_attempts = 0
        db.session.commit()

        log_audit(
            action='backup_user_password_set',
            table='BackupLoginUser',
            record_id=int(backup_user.id),
            user_id=int(current_user.id),
            changes={'email': email, 'linked_admin_id': int(backup_user.created_by_admin_id)},
        )

        session.pop('backup_add_stage', None)
        session.pop('backup_add_email', None)
        session.pop('backup_add_user_id', None)

        flash(f'Backup access enabled for {email}. They can now log in with email + password.', 'success')
        return redirect(url_for('backup_manage_users'))

    flash('Invalid action.', 'danger')
    return redirect(url_for('backup_manage_users'))


@app.route('/admin/backup/users/<int:user_id>/remove', methods=['POST'])
@login_required
@require_backup_access
def backup_remove_user(user_id: int):
    """Main admin removes backup access from a user."""
    if not _check_is_main_admin():
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    backup_user = _db_get(BackupLoginUser, user_id)
    if not backup_user:
        flash('User not found', 'danger')
        return redirect(url_for('backup_manage_users'))
    
    email = backup_user.email
    db.session.delete(backup_user)
    db.session.commit()
    
    app.logger.info(f'Main admin {current_user.email} removed backup access for {email}')
    flash(f'Backup access removed for {email}', 'success')
    return redirect(url_for('backup_manage_users'))


@app.route('/admin/backup/users/<int:user_id>/toggle', methods=['POST'])
@login_required
@require_backup_access
def backup_toggle_user(user_id: int):
    """Main admin enables/disables backup access for a user."""
    if not _check_is_main_admin():
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    backup_user = _db_get(BackupLoginUser, user_id)
    if not backup_user:
        return jsonify({'success': False, 'error': 'Not found'}), 404
    
    backup_user.is_active = not backup_user.is_active
    db.session.commit()
    
    status = 'enabled' if backup_user.is_active else 'disabled'
    app.logger.info(f'Main admin {current_user.email} {status} backup access for {backup_user.email}')
    flash(f'Backup access {status} for {backup_user.email}', 'success')
    
    return jsonify({'success': True, 'is_active': backup_user.is_active})


@app.context_processor
def inject_backup_access_context():
    """Inject backup access info into all templates."""
    return {
        'has_backup_access': has_backup_access(),
        'backup_user_email': session.get('backup_authenticated_email')
    }


@app.route('/admin/backup/schedule', methods=['POST'])
@login_required
@require_backup_access
def backup_schedule_update():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    daily_enabled = request.form.get('daily_enabled') == 'on'
    daily_time = (request.form.get('daily_time') or '02:00').strip()
    disaster_enabled = request.form.get('disaster_enabled') == 'on'

    if not re.match(r'^(\d{1,2}):(\d{2})$', daily_time):
        flash('Invalid daily time. Use HH:MM format.', 'danger')
        return redirect(url_for('backup_management'))

    cfg = _get_or_create_schedule_config()
    if not cfg:
        flash('Schedule config is not available yet. Run DB migration and try again.', 'danger')
        return redirect(url_for('backup_management'))

    cfg.daily_enabled = bool(daily_enabled)
    cfg.daily_time = daily_time
    cfg.disaster_enabled = bool(disaster_enabled)
    cfg.disaster_interval_minutes = 30
    db.session.commit()

    try:
        if 'scheduler' in globals() and globals().get('scheduler') is not None:
            _scheduler_apply_backup_jobs(globals()['scheduler'])
    except Exception:
        app.logger.exception('Failed to apply scheduler changes')

    flash('Backup schedule updated successfully.', 'success')
    return redirect(url_for('backup_management'))


@app.route('/admin/backup/access/set', methods=['POST'])
@login_required
def backup_access_set_for_admin():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    try:
        is_main_admin = int(current_user.id) == 1
    except Exception:
        is_main_admin = False
    
    # Main admin can set credentials for themselves (first run bootstrap)
    # OR set credentials for other admins (if already logged into backup system)
    target_user_id = request.form.get('target_admin_id')
    password = (request.form.get('backup_access_password') or '').strip()
    
    # If no target specified, main admin is setting up for themselves
    if not target_user_id:
        if not is_main_admin:
            flash('Only the main admin can create backup access credentials.', 'danger')
            return redirect(url_for('backup_management'))
        target_user_id = current_user.id
    else:
        # If target specified, must be main admin AND must have backup access
        if not is_main_admin:
            flash('Only the main admin can create backup access credentials for other admins.', 'danger')
            return redirect(url_for('backup_management'))
        if not has_backup_access():
            flash('You must log in to backup system first to manage other users.', 'warning')
            return redirect(url_for('backup_login_page'))
    
    ok, msg = _password_meets_backup_policy(password)
    if not ok:
        flash(msg, 'danger')
        return redirect(url_for('backup_management'))

    user = _db_get(User, int(target_user_id))
    if not user or user.role != 'admin':
        flash('Selected user is not an admin.', 'danger')
        return redirect(url_for('backup_management'))

    _ensure_backup_access_credential(user_id=user.id, password=password, created_by_user_id=current_user.id)
    db.session.commit()
    flash('Backup access password set successfully.', 'success')
    
    # Auto-login if main admin just created their own credentials
    if int(target_user_id) == current_user.id and is_main_admin:
        backup_user = BackupLoginUser.query.filter_by(email=current_user.email, is_verified=True).first()
        if backup_user:
            session['backup_authenticated_email'] = backup_user.email
            return redirect(url_for('backup_management'))
    
    return redirect(url_for('backup_management'))


@app.route('/admin/backup/access/reset/send-otp', methods=['POST'])
@login_required
@require_backup_access
def backup_access_reset_send_otp():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    email_addr = (getattr(current_user, 'email', '') or '').strip()
    if not email_addr or '@' not in email_addr:
        flash('Your admin account does not have a valid email address configured.', 'danger')
        return redirect(url_for('backup_management'))

    code = _generate_backup_otp_code()
    session['backup_access_reset_hash'] = _backup_code_hash(code)
    session['backup_access_reset_expires'] = (get_eat_now() + timedelta(minutes=10)).isoformat()

    try:
        _send_backup_email(
            recipient=email_addr,
            subject='MMC Backup Password Reset Code',
            html=(
                f"<p>Your backup password reset code is:</p>"
                f"<h2 style='letter-spacing:2px'>{code}</h2>"
                f"<p>This code expires in 10 minutes.</p>"
            ),
        )
    except Exception as e:
        app.logger.error(f'Failed to send backup access reset OTP: {e}', exc_info=True)
        flash('Failed to send reset code. Check email settings and try again.', 'danger')
        return redirect(url_for('backup_management'))

    flash('Reset code sent to your email. Enter the code and your new backup password.', 'success')
    return redirect(url_for('backup_management'))


@app.route('/admin/backup/access/reset/confirm', methods=['POST'])
@login_required
@require_backup_access
def backup_access_reset_confirm():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    code = (request.form.get('backup_reset_code') or '').strip()
    new_password = (request.form.get('backup_reset_new_password') or '').strip()
    ok, msg = _password_meets_backup_policy(new_password)
    if not ok:
        flash(msg, 'danger')
        return redirect(url_for('backup_management'))

    expected_hash = session.get('backup_access_reset_hash')
    exp_iso = session.get('backup_access_reset_expires')
    if not expected_hash or not exp_iso:
        flash('No reset request found. Please send a new reset code.', 'danger')
        return redirect(url_for('backup_management'))

    try:
        exp_dt = datetime.fromisoformat(exp_iso)
        if exp_dt.tzinfo is None:
            exp_dt = exp_dt.replace(tzinfo=EAT)
        if exp_dt < get_eat_now():
            flash('Reset code expired. Please request a new one.', 'danger')
            return redirect(url_for('backup_management'))
    except Exception:
        flash('Reset code expired. Please request a new one.', 'danger')
        return redirect(url_for('backup_management'))

    if _backup_code_hash(code) != expected_hash:
        flash('Invalid reset code. Please try again.', 'danger')
        return redirect(url_for('backup_management'))

    _ensure_backup_access_credential(user_id=current_user.id, password=new_password, created_by_user_id=current_user.id)
    db.session.commit()
    session.pop('backup_access_reset_hash', None)
    session.pop('backup_access_reset_expires', None)

    flash('Backup password reset successfully.', 'success')
    return redirect(url_for('backup_management'))

@app.route('/admin/disaster_recovery', methods=['GET', 'POST'])
@login_required
def disaster_recovery():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'create_recovery_plan':
            try:
                plan = DisasterRecoveryPlan(
                    name=request.form.get('name'),
                    description=request.form.get('description'),
                    recovery_point_objective=int(request.form.get('rpo', 1440)),  # Default 24 hours
                    recovery_time_objective=int(request.form.get('rto', 240)),   # Default 4 hours
                    is_active=True
                )
                db.session.add(plan)
                db.session.commit()
                flash('Disaster recovery plan created successfully', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error creating recovery plan: {str(e)}', 'danger')
        
        elif action == 'update_recovery_plan':
            plan_id = request.form.get('plan_id')
            plan = _db_get_or_404(DisasterRecoveryPlan, plan_id)
            
            try:
                plan.name = request.form.get('name', plan.name)
                plan.description = request.form.get('description', plan.description)
                plan.recovery_point_objective = int(request.form.get('rpo', plan.recovery_point_objective))
                plan.recovery_time_objective = int(request.form.get('rto', plan.recovery_time_objective))
                plan.is_active = request.form.get('is_active', 'off') == 'on'
                db.session.commit()
                flash('Disaster recovery plan updated successfully', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating recovery plan: {str(e)}', 'danger')
        
        elif action == 'test_recovery_plan':
            plan_id = request.form.get('plan_id')
            plan = _db_get_or_404(DisasterRecoveryPlan, plan_id)
            
            try:
                # Find most recent backup
                backup = BackupRecord.query.filter_by(status='completed')\
                    .order_by(BackupRecord.timestamp.desc())\
                    .first()
                
                if not backup:
                    flash('No valid backups found for recovery testing', 'danger')
                    return redirect(url_for('disaster_recovery'))
                
                # Run test restore in background
                from threading import Thread
                thread = Thread(target=test_disaster_recovery, args=(plan.id, backup.id), daemon=True)
                thread.start()
                
                flash('Disaster recovery test initiated. You will be notified when complete.', 'info')
            except Exception as e:
                flash(f'Error initiating recovery test: {str(e)}', 'danger')
        
        return redirect(url_for('disaster_recovery'))
    
    # Get all recovery plans
    recovery_plans = DisasterRecoveryPlan.query.all()
    
    return render_template('admin/disaster_recovery.html', recovery_plans=recovery_plans)

@app.route('/admin/backup/status/<int:backup_id>')
@login_required
@require_backup_access
def backup_status(backup_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    backup = _db_get_or_404(BackupRecord, backup_id)
    stats = _backup_extract_stats(backup.notes)
    restore = _backup_extract_restore_status(backup.notes)
    return jsonify({
        'id': backup.id,
        'status': backup.status,
        'timestamp': backup.timestamp.isoformat(),
        'size_bytes': backup.size_bytes,
        'notes': _backup_strip_restore_status(_backup_strip_stats(backup.notes)),
        'stats': stats,
        'restore': restore,
    })

@app.route('/admin/backup/logs')
@login_required
@require_backup_access
def backup_logs():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    # Get last 50 backup operations
    backups = BackupRecord.query.order_by(BackupRecord.timestamp.desc()).limit(50).all()
    
    return jsonify([{
        'id': b.id,
        'backup_id': b.backup_id,
        'timestamp': b.timestamp.isoformat(),
        'type': b.backup_type,
        'status': b.status,
        'size_mb': round(b.size_bytes / (1024 * 1024), 2) if b.size_bytes else None,
        'user': b.user.username if b.user else 'System'
    } for b in backups])

# ======================
# BACKUP IMPLEMENTATION
# ======================

class _AutoDeleteFile(io.BufferedReader):
    def __init__(self, path: str):
        self._path = path
        super().__init__(open(path, 'rb'))

    def close(self):
        try:
            super().close()
        finally:
            try:
                os.remove(self._path)
            except Exception:
                pass


def _safe_table_name(name: str) -> bool:
    return bool(name) and bool(re.match(r'^[A-Za-z_][A-Za-z0-9_]*$', str(name)))


def _jsonable_value(value):
    if value is None:
        return None
    if isinstance(value, (bytes, bytearray, memoryview)):
        raw = value.tobytes() if isinstance(value, memoryview) else bytes(value)
        return {'__type__': 'bytes', 'b64': base64.b64encode(raw).decode('ascii')}
    if isinstance(value, (datetime, date)):
        return {'__type__': 'datetime', 'iso': value.isoformat()}
    if isinstance(value, Decimal):
        return {'__type__': 'decimal', 'value': str(value)}
    return value


def _restore_value(value):
    if value is None:
        return None
    if isinstance(value, dict) and value.get('__type__') == 'bytes' and 'b64' in value:
        try:
            return base64.b64decode(value['b64'])
        except Exception:
            return None
    if isinstance(value, dict) and value.get('__type__') == 'datetime' and 'iso' in value:
        try:
            return datetime.fromisoformat(value['iso'])
        except Exception:
            return value.get('iso')
    if isinstance(value, dict) and value.get('__type__') == 'decimal' and 'value' in value:
        try:
            return Decimal(value['value'])
        except Exception:
            return value.get('value')

    # Legacy encoding produced by json.dumps(default=str)
    if isinstance(value, str):
        if value.startswith("b'") and value.endswith("'"):
            try:
                import ast

                v = ast.literal_eval(value)
                if isinstance(v, (bytes, bytearray)):
                    return bytes(v)
            except Exception:
                pass
        if value.endswith('+00:00') or 'T' in value:
            try:
                return datetime.fromisoformat(value)
            except Exception:
                pass
    return value


_RESTORE_DT_RE = re.compile(r'^\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?$')
_RESTORE_DATE_RE = re.compile(r'^\d{4}-\d{2}-\d{2}$')
_RESTORE_TIME_RE = re.compile(r'^\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?$')


def _restore_coerce_value_for_column(col, value):
    """Best-effort type coercion for values coming from backups.

    Why: backups may contain strings for SQLite Date/DateTime columns because
    we export via untyped SELECT * queries; SQLite's dialect then rejects
    strings for Date/DateTime on insert.
    """
    if value is None:
        return None

    try:
        from sqlalchemy.sql.sqltypes import Boolean, Date, DateTime, Float, Integer, Numeric, Time
        from datetime import time as dt_time

        col_type = getattr(col, 'type', None)

        # DateTime
        if isinstance(col_type, DateTime):
            if isinstance(value, datetime):
                return value
            if isinstance(value, date) and not isinstance(value, datetime):
                return datetime.combine(value, dt_time(0, 0, 0))
            if isinstance(value, str) and _RESTORE_DT_RE.match(value.strip()):
                v = value.strip().replace('Z', '+00:00')
                try:
                    return datetime.fromisoformat(v)
                except Exception:
                    return value
            return value

        # Date
        if isinstance(col_type, Date):
            if isinstance(value, date) and not isinstance(value, datetime):
                return value
            if isinstance(value, datetime):
                return value.date()
            if isinstance(value, str) and _RESTORE_DATE_RE.match(value.strip()):
                try:
                    return date.fromisoformat(value.strip())
                except Exception:
                    return value
            return value

        # Time
        if isinstance(col_type, Time):
            if isinstance(value, dt_time):
                return value
            if isinstance(value, datetime):
                return value.time()
            if isinstance(value, str) and _RESTORE_TIME_RE.match(value.strip()):
                try:
                    return dt_time.fromisoformat(value.strip())
                except Exception:
                    return value
            return value

        # Numeric/Decimal
        if isinstance(col_type, Numeric):
            if isinstance(value, Decimal):
                return value
            if isinstance(value, (int, float)):
                return Decimal(str(value))
            if isinstance(value, str):
                try:
                    return Decimal(value.strip())
                except Exception:
                    return value
            return value

        # Primitive coercions (only when clearly safe)
        if isinstance(col_type, Boolean):
            if isinstance(value, bool):
                return value
            if isinstance(value, (int, float)):
                return bool(int(value))
            if isinstance(value, str):
                s = value.strip().lower()
                if s in ('true', '1', 'yes', 'y', 'on'):
                    return True
                if s in ('false', '0', 'no', 'n', 'off'):
                    return False
            return value

        if isinstance(col_type, Integer):
            if isinstance(value, int) and not isinstance(value, bool):
                return value
            if isinstance(value, str) and re.fullmatch(r'[-+]?\d+', value.strip()):
                try:
                    return int(value.strip())
                except Exception:
                    return value
            return value

        if isinstance(col_type, Float):
            if isinstance(value, (int, float)) and not isinstance(value, bool):
                return float(value)
            if isinstance(value, str):
                try:
                    return float(value.strip())
                except Exception:
                    return value
            return value

    except Exception:
        return value

    return value


def _compute_sha256_file(path: str) -> str:
    h = hashlib.sha256()
    with open(path, 'rb') as f:
        while True:
            chunk = f.read(1024 * 1024)
            if not chunk:
                break
            h.update(chunk)
    return h.hexdigest()


def _compute_sha256_bytes(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()


def _is_main_admin(user: User) -> bool:
    # Simplest interpretation: the first admin user is the "main admin".
    try:
        return bool(user) and str(user.role) == 'admin' and int(user.id) == 1
    except Exception:
        return False


def _password_meets_backup_policy(pw: str) -> tuple[bool, str]:
    s = (pw or '').strip()
    if len(s) < 8:
        return False, 'Password must be at least 8 characters long.'
    if not re.search(r'[A-Z]', s):
        return False, 'Password must contain at least one uppercase letter.'
    if not re.search(r'[a-z]', s):
        return False, 'Password must contain at least one lowercase letter.'
    if not re.search(r'\d', s):
        return False, 'Password must contain at least one number.'
    if not re.search(r'[^A-Za-z0-9]', s):
        return False, 'Password must contain at least one symbol.'
    return True, ''


def _backup_code_hash(code: str) -> str:
    # Hash code with SECRET_KEY to avoid storing raw OTP.
    secret = (app.config.get('SECRET_KEY') or '').encode('utf-8')
    payload = (str(code or '').strip()).encode('utf-8')
    return hashlib.sha256(secret + b'|' + payload).hexdigest()


def _generate_backup_otp_code() -> str:
    return f"{secrets.randbelow(1_000_000):06d}"


def _get_or_create_schedule_config() -> BackupScheduleConfig | None:
    try:
        cfg = BackupScheduleConfig.query.order_by(BackupScheduleConfig.id.asc()).first()
        if not cfg:
            cfg = BackupScheduleConfig(id=1, daily_enabled=True, daily_time='02:00', disaster_enabled=True, disaster_interval_minutes=30)
            db.session.add(cfg)
            db.session.commit()
        return cfg
    except Exception:
        db.session.rollback()
        return None


def _ensure_backup_access_credential(user_id: int, password: str, created_by_user_id: int | None = None) -> BackupAccessCredential:
    cred = BackupAccessCredential.query.filter_by(user_id=user_id).first()
    if cred:
        cred.password_hash = generate_password_hash(password)
        cred.is_active = True
        cred.created_by_user_id = created_by_user_id
        return cred
    cred = BackupAccessCredential(
        user_id=user_id,
        password_hash=generate_password_hash(password),
        is_active=True,
        created_by_user_id=created_by_user_id,
    )
    db.session.add(cred)
    return cred


def _send_backup_email(
    recipient: str,
    subject: str,
    html: str,
    attachments: list[tuple[str, str, bytes]] | None = None,
) -> None:
    """Send backup-related emails via Resend."""
    
    if not recipient or '@' not in recipient:
        app.logger.error(f"Invalid backup email recipient: {recipient}")
        return
    
    # Log email send attempt
    app.logger.info(f"Attempting to send backup email to: {recipient}, Subject: {subject}")
    
    # Use production email sender
    def _send():
        try:
            with app.app_context():
                if not _email_sender.is_healthy():
                    app.logger.warning("Resend not configured; backup email not sent.")
                    return
                
                app.logger.info(f"Sending backup email via Resend to {recipient}")
                result = _email_sender.send(
                    recipient=recipient,
                    subject=subject,
                    html_body=html,
                    text_body='Your email client does not support HTML.',
                    attachments=attachments,
                )
                _email_audit_logger.log_send(result)
                
                if result.success:
                    app.logger.info(f"✓ Backup email sent successfully to {recipient}")
                else:
                    app.logger.error(f"✗ Backup email send failed to {recipient}: {result.error}")
                    if 'onboarding@resend.dev' in _resend_config.from_address.lower():
                        app.logger.error(
                            f"⚠ Using Resend test domain. {recipient} must be verified in Resend dashboard. "
                            f"Verify your own domain at https://resend.com/domains"
                        )
        except Exception as e:
            try:
                with app.app_context():
                    app.logger.exception(f"Backup email sender failed: {e}")
            except:
                pass
    
    try:
        Thread(target=_send, daemon=True, name="backup-email").start()
    except Exception as e:
        app.logger.error(f"Failed to start backup email thread: {e}")


def _restore_table_order(engine, tables: list[str]) -> list[str]:
    try:
        from sqlalchemy import inspect as sa_inspect

        insp = sa_inspect(engine)
        existing = set(insp.get_table_names())
        tables = [t for t in tables if t in existing]

        parents: dict[str, set[str]] = {t: set() for t in tables}
        children: dict[str, set[str]] = {t: set() for t in tables}

        for t in tables:
            try:
                for fk in (insp.get_foreign_keys(t) or []):
                    rt = fk.get('referred_table')
                    if rt and rt in parents and rt != t:
                        parents[t].add(rt)
                        children[rt].add(t)
            except Exception:
                continue

        ordered: list[str] = []
        ready = sorted([t for t in tables if not parents[t]])
        while ready:
            n = ready.pop(0)
            ordered.append(n)
            for c in sorted(children[n]):
                parents[c].discard(n)
                if not parents[c] and c not in ordered and c not in ready:
                    ready.append(c)

        leftover = [t for t in tables if t not in ordered]
        return ordered + leftover
    except Exception:
        return tables


def _restore_zip_to_engine(engine, zip_bytes: bytes, allowed_tables: set[str] | None) -> dict:
    from sqlalchemy import inspect as sa_inspect

    insp = sa_inspect(engine)
    existing_tables = set(insp.get_table_names())

    with zipfile.ZipFile(io.BytesIO(zip_bytes), 'r') as z:
        try:
            metadata = json.loads(z.read('metadata.json').decode('utf-8'))
        except Exception:
            metadata = {}

        tables_in_backup = metadata.get('tables_backed_up') or []
        if not tables_in_backup:
            for name in z.namelist():
                if name.endswith('.ndjson'):
                    tables_in_backup.append(name[:-len('.ndjson')])
                elif name.endswith('.json') and name != 'metadata.json':
                    tables_in_backup.append(name[:-len('.json')])
            tables_in_backup = sorted(set(tables_in_backup))

        restore_tables = [t for t in tables_in_backup if _safe_table_name(t) and t in existing_tables]
        if allowed_tables:
            filtered = [t for t in restore_tables if t in allowed_tables]
            if filtered:
                restore_tables = filtered

        restore_tables = _restore_table_order(engine, restore_tables)

        restored_counts: dict[str, int] = {}

        with engine.begin() as conn:
            try:
                if insp.dialect.name == 'sqlite':
                    conn.execute(text('PRAGMA foreign_keys=OFF'))
            except Exception:
                pass

            for table_name in restore_tables:
                ndjson_name = f"{table_name}.ndjson"
                json_name = f"{table_name}.json"
                if ndjson_name not in z.namelist() and json_name not in z.namelist():
                    continue

                meta = MetaData()
                table = Table(table_name, meta, autoload_with=engine)
                col_names = set(c.name for c in table.columns)
                col_by_name = {c.name: c for c in table.columns}

                # Clear
                if insp.dialect.name == 'postgresql':
                    conn.execute(text(f'TRUNCATE TABLE "{table_name}" RESTART IDENTITY CASCADE'))
                else:
                    conn.execute(text(f'DELETE FROM "{table_name}"'))
                    if insp.dialect.name == 'sqlite':
                        try:
                            conn.execute(text('DELETE FROM sqlite_sequence WHERE name=:n'), {'n': table_name})
                        except Exception:
                            pass

                inserted = 0
                batch: list[dict] = []
                batch_size = 1000

                def flush_batch():
                    nonlocal inserted, batch
                    if batch:
                        # Coerce values to column types (esp. SQLite Date/DateTime).
                        to_insert = []
                        for row in batch:
                            if not isinstance(row, dict):
                                continue
                            coerced = dict(row)
                            for k, v in list(coerced.items()):
                                col = col_by_name.get(k)
                                if col is None:
                                    continue
                                coerced[k] = _restore_coerce_value_for_column(col, v)
                            to_insert.append(coerced)
                        if to_insert:
                            conn.execute(table.insert(), to_insert)
                        inserted += len(batch)
                        batch = []

                if ndjson_name in z.namelist():
                    with z.open(ndjson_name) as fh:
                        for raw_line in fh:
                            line = raw_line.decode('utf-8').strip()
                            if not line:
                                continue
                            row = json.loads(line)
                            if not isinstance(row, dict):
                                continue
                            restored = {k: _restore_value(v) for k, v in row.items() if k in col_names}
                            batch.append(restored)
                            if len(batch) >= batch_size:
                                flush_batch()
                    flush_batch()
                else:
                    rows = json.loads(z.read(json_name).decode('utf-8'))
                    if isinstance(rows, list):
                        for row in rows:
                            if not isinstance(row, dict):
                                continue
                            restored = {k: _restore_value(v) for k, v in row.items() if k in col_names}
                            batch.append(restored)
                            if len(batch) >= batch_size:
                                flush_batch()
                        flush_batch()

                restored_counts[table_name] = inserted

            try:
                if insp.dialect.name == 'sqlite':
                    conn.execute(text('PRAGMA foreign_keys=ON'))
            except Exception:
                pass

    return {
        'tables_restored': len(restored_counts),
        'row_counts': restored_counts,
    }


def create_backup(backup_id, created_by_user_id=None):
    """Create a database backup in background"""
    with app.app_context():
        backup = db.session.get(BackupRecord, backup_id)
        if not backup:
            return

        try:
            from sqlalchemy import inspect as sa_inspect

            insp = sa_inspect(db.engine)
            existing_tables = set(insp.get_table_names())

            configured = [t for t in BACKUP_CONFIG.get('tables_to_backup', []) if _safe_table_name(t)]
            # Always back up all tables (excluding alembic_version) so new tables/columns are included.
            selected = sorted(t for t in existing_tables if _safe_table_name(t) and t != 'alembic_version')

            with tempfile.TemporaryDirectory() as temp_dir:
                zip_path = os.path.join(temp_dir, f'backup_{backup.backup_id}.zip')
                row_counts: dict[str, int] = {}
                failed_tables: list[str] = []

                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for table_name in selected:
                        try:
                            rc = 0
                            with db.engine.connect() as conn:
                                result = conn.execution_options(stream_results=True).execute(text(f'SELECT * FROM "{table_name}"'))
                                with zipf.open(f"{table_name}.ndjson", 'w') as zf:
                                    for row in result:
                                        row_dict = {k: _jsonable_value(v) for k, v in dict(row._mapping).items()}
                                        zf.write((json.dumps(row_dict, default=str) + "\n").encode('utf-8'))
                                        rc += 1
                            row_counts[table_name] = rc
                        except Exception as e:
                            app.logger.error(f'Error backing up table {table_name}: {str(e)}')
                            failed_tables.append(table_name)
                            continue

                    stats = {
                        'tables_total': int(len(selected)),
                        'tables_backed_up': int(len(row_counts)),
                        'tables_failed': int(len(failed_tables)),
                        'failed_tables': failed_tables[:200],
                    }

                    metadata = {
                        'backup_id': backup.backup_id,
                        'timestamp': get_eat_now().isoformat(),
                        'database_url': str(db.engine.url),
                        'tables_requested': configured,
                        'tables_backed_up': sorted(row_counts.keys()),
                        'tables_total': stats['tables_total'],
                        'tables_failed': stats['tables_failed'],
                        'failed_tables': stats['failed_tables'],
                        'row_counts': row_counts,
                        'dialect': insp.dialect.name,
                        'format': 'ndjson-v2',
                        'key_id': 'fernet-v1',
                    }
                    zipf.writestr('metadata.json', json.dumps(metadata, indent=2))

                checksum = _compute_sha256_file(zip_path)

                cipher_suite = Fernet(BACKUP_CONFIG['encryption_key'].encode())
                with open(zip_path, 'rb') as f:
                    encrypted_bytes = cipher_suite.encrypt(f.read())

                enc_path = os.path.join(temp_dir, f'backup_{backup.backup_id}.zip.enc')
                with open(enc_path, 'wb') as f:
                    f.write(encrypted_bytes)

                file_size = os.path.getsize(enc_path)

                uploaded_to_s3 = False
                if s3_client:
                    try:
                        bucket = (BACKUP_CONFIG.get('s3_bucket') or '').strip()
                        if not _is_valid_s3_bucket_name(bucket):
                            raise ValueError('Invalid AWS_BACKUP_BUCKET; refusing S3 upload')

                        s3_key = f'backups/{backup.backup_id}.zip.enc'
                        s3_client.upload_file(
                            enc_path,
                            bucket,
                            s3_key,
                            ExtraArgs={
                                'ServerSideEncryption': 'AES256',
                                'ACL': 'private',
                                'Metadata': {
                                    'backup-id': backup.backup_id,
                                    'checksum': checksum,
                                    'created-by': str(created_by_user_id) if created_by_user_id is not None else 'system'
                                }
                            }
                        )
                        storage_location = f's3://{bucket}/{s3_key}'
                        uploaded_to_s3 = True
                    except Exception as s3_exc:
                        app.logger.error(f'S3 upload failed; falling back to local storage: {s3_exc}', exc_info=True)

                if not uploaded_to_s3:
                    local_backup_dir = BACKUP_CONFIG['local_storage_path']
                    os.makedirs(local_backup_dir, exist_ok=True)
                    dest = os.path.join(local_backup_dir, f'{backup.backup_id}.zip.enc')
                    os.replace(enc_path, dest)
                    storage_location = dest

                backup.status = 'completed'
                backup.size_bytes = file_size
                backup.storage_location = storage_location
                backup.checksum = checksum
                backup.notes = _backup_notes_with_stats(backup.notes, {
                    **stats,
                    'size_bytes': int(file_size),
                })
                db.session.commit()

                app.logger.info(f'Backup completed: {backup.backup_id} ({file_size} bytes)')

        except Exception as e:
            app.logger.error(f'Backup failed: {str(e)}', exc_info=True)
            backup.status = 'failed'
            backup.notes = f'Error: {str(e)}'
            db.session.commit()


def restore_backup(backup_id):
    """Restore database from backup"""
    with app.app_context():
        backup = db.session.get(BackupRecord, backup_id)
        if not backup:
            return

        try:
            try:
                backup.notes = _backup_notes_with_restore_status(backup.notes, {
                    'status': 'in_progress',
                    'started_at': get_eat_now().isoformat(),
                    'message': 'Restore started. Please wait...',
                })
                db.session.commit()
            except Exception:
                try:
                    db.session.rollback()
                except Exception:
                    pass

            fh = get_backup_file(backup)
            if not fh:
                backup.notes = 'Restore error: backup file not found'
                db.session.commit()
                return
            try:
                encrypted_bytes = fh.read()
            finally:
                try:
                    fh.close()
                except Exception:
                    pass

            cipher_suite = Fernet(BACKUP_CONFIG['encryption_key'].encode())
            zip_bytes = cipher_suite.decrypt(encrypted_bytes)

            if backup.checksum and _compute_sha256_bytes(zip_bytes) != backup.checksum:
                backup.notes = 'Restore error: checksum mismatch (backup may be corrupted)'
                db.session.commit()
                return

            # Ensure schema exists (safe no-op if already created)
            try:
                initialize_database()
            except Exception:
                app.logger.exception('Schema initialization before restore failed')

            # Restore all backed-up tables that exist in the current schema.
            result = _restore_zip_to_engine(db.engine, zip_bytes, allowed_tables=None)
            backup.notes = _backup_notes_with_restore_status(backup.notes, {
                'status': 'completed',
                'finished_at': get_eat_now().isoformat(),
                'tables_restored': int(result.get('tables_restored') or 0),
                'message': f"Restore completed successfully (tables: {result.get('tables_restored')})",
            })
            db.session.commit()

            try:
                rc = result.get('row_counts') or {}
                total_rows = sum(int(v or 0) for v in rc.values()) if isinstance(rc, dict) else None
                app.logger.info(
                    "Restore completed: backup_id=%s tables=%s rows=%s",
                    str(getattr(backup, 'backup_id', backup_id)),
                    str(result.get('tables_restored')),
                    str(total_rows) if total_rows is not None else 'unknown',
                )
            except Exception:
                pass

        except Exception as e:
            app.logger.error(f'Restore failed: {str(e)}', exc_info=True)
            try:
                backup.notes = _backup_notes_with_restore_status(backup.notes, {
                    'status': 'failed',
                    'finished_at': get_eat_now().isoformat(),
                    'message': f'Restore failed: {str(e)}',
                })
            except Exception:
                backup.notes = f'Restore error: {str(e)}'
            db.session.commit()


def test_disaster_recovery(plan_id, backup_id):
    """Test disaster recovery plan by verifying the latest backup can be decrypted and parsed."""
    with app.app_context():
        plan = _db_get(DisasterRecoveryPlan, plan_id)
        backup = _db_get(BackupRecord, backup_id)
        if not plan or not backup:
            return

        try:
            fh = get_backup_file(backup)
            if not fh:
                plan.last_tested = get_eat_now()
                plan.test_results = 'Backup file not found'
                db.session.commit()
                return
            try:
                encrypted_bytes = fh.read()
            finally:
                try:
                    fh.close()
                except Exception:
                    pass

            cipher_suite = Fernet(BACKUP_CONFIG['encryption_key'].encode())
            zip_bytes = cipher_suite.decrypt(encrypted_bytes)

            checksum_ok = True
            if backup.checksum:
                checksum_ok = (_compute_sha256_bytes(zip_bytes) == backup.checksum)

            with zipfile.ZipFile(io.BytesIO(zip_bytes), 'r') as z:
                names = z.namelist()
                has_metadata = 'metadata.json' in names
                meta = {}
                if has_metadata:
                    try:
                        meta = json.loads(z.read('metadata.json').decode('utf-8'))
                    except Exception:
                        meta = {}
                tables = meta.get('tables_backed_up') or sorted({
                    n[:-len('.ndjson')] for n in names if n.endswith('.ndjson')
                })

                # Attempt to parse first line of first few tables
                parse_errors = []
                for t in tables[:5]:
                    fn = f"{t}.ndjson"
                    if fn not in names:
                        continue
                    try:
                        with z.open(fn) as fh2:
                            first = fh2.readline().decode('utf-8').strip()
                            if first:
                                json.loads(first)
                    except Exception as pe:
                        parse_errors.append(f"{t}: {pe}")

            plan.last_tested = get_eat_now()
            plan.test_results = json.dumps({
                'backup_id': backup.backup_id,
                'timestamp': backup.timestamp.isoformat() if backup.timestamp else None,
                'checksum_ok': checksum_ok,
                'has_metadata': has_metadata,
                'table_count': len(tables),
                'parse_errors': parse_errors,
            }, indent=2)
            db.session.commit()

        except Exception as e:
            app.logger.error(f'Disaster recovery test failed: {str(e)}', exc_info=True)
            plan.last_tested = get_eat_now()
            plan.test_results = f"Test failed: {str(e)}"
            db.session.commit()


def verify_backup_exists(backup):
    """Verify that the backup file exists in storage"""
    if not backup.storage_location:
        return False

    if backup.storage_location.startswith('s3://'):
        if not s3_client:
            return False
        bucket, key = backup.storage_location[5:].split('/', 1)
        try:
            s3_client.head_object(Bucket=bucket, Key=key)
            return True
        except ClientError:
            return False
    else:
        try:
            return os.path.exists(backup.storage_location) and os.path.getsize(backup.storage_location) > 0
        except Exception:
            return False


def get_backup_file(backup):
    """Get the backup file from storage"""
    if not backup.storage_location:
        return None

    if backup.storage_location.startswith('s3://'):
        if not s3_client:
            return None
        bucket, key = backup.storage_location[5:].split('/', 1)
        try:
            temp_file = tempfile.NamedTemporaryFile(delete=False)
            s3_client.download_fileobj(bucket, key, temp_file)
            temp_file.close()
            return _AutoDeleteFile(temp_file.name)
        except ClientError as e:
            app.logger.error(f'Error downloading backup from S3: {str(e)}')
            return None
    else:
        try:
            return open(backup.storage_location, 'rb')
        except IOError as e:
            app.logger.error(f'Error opening local backup file: {str(e)}')
            return None


def delete_backup_file(backup):
    """Delete the backup file from storage"""
    if not backup.storage_location:
        return

    if backup.storage_location.startswith('s3://'):
        if not s3_client:
            return
        bucket, key = backup.storage_location[5:].split('/', 1)
        try:
            s3_client.delete_object(Bucket=bucket, Key=key)
        except ClientError as e:
            app.logger.error(f'Error deleting backup from S3: {str(e)}')
    else:
        try:
            os.remove(backup.storage_location)
        except OSError as e:
            app.logger.error(f'Error deleting local backup file: {str(e)}')


def scheduled_backup():
    """Create a scheduled backup"""
    with app.app_context():
        try:
            cfg = _get_or_create_schedule_config()
            if cfg and not cfg.daily_enabled:
                return
            # Create backup record
            backup = BackupRecord(
                backup_type='scheduled',
                notes='Automated scheduled backup',
                status='in_progress'
            )
            db.session.add(backup)
            db.session.commit()
            
            # Run backup
            create_backup(backup.id)
        except Exception as e:
            app.logger.error(f'Error in scheduled backup: {str(e)}')


def disaster_recovery_backup_job():
    """Create a disaster recovery backup (intended to run every 30 minutes)."""
    with app.app_context():
        try:
            cfg = _get_or_create_schedule_config()
            if cfg and not cfg.disaster_enabled:
                return
            backup = BackupRecord(
                backup_type='disaster_recovery',
                notes='Automated disaster recovery backup (30-minute interval)',
                status='in_progress'
            )
            db.session.add(backup)
            db.session.commit()
            create_backup(backup.id)
        except Exception as e:
            app.logger.error(f'Error in disaster recovery backup job: {str(e)}', exc_info=True)


def _scheduler_apply_backup_jobs(scheduler: BackgroundScheduler):
    """(Re)configure backup jobs based on DB settings; falls back to defaults if unavailable."""
    hour, minute = 2, 0
    disaster_minutes = 30
    daily_enabled = True
    disaster_enabled = True
    try:
        with app.app_context():
            cfg = _get_or_create_schedule_config()
            if cfg:
                daily_enabled = bool(cfg.daily_enabled)
                disaster_enabled = bool(cfg.disaster_enabled)
                disaster_minutes = int(cfg.disaster_interval_minutes or 30)
                t = (cfg.daily_time or '02:00').strip()
                m = re.match(r'^(\d{1,2}):(\d{2})$', t)
                if m:
                    hour = max(0, min(23, int(m.group(1))))
                    minute = max(0, min(59, int(m.group(2))))
    except Exception:
        # DB might not be migrated yet; keep defaults
        pass

    # Always add jobs with IDs; jobs can early-return if disabled.
    scheduler.add_job(
        scheduled_backup,
        'cron',
        hour=hour,
        minute=minute,
        id='daily_backup',
        replace_existing=True,
        max_instances=1,
        coalesce=True,
    )
    scheduler.add_job(
        disaster_recovery_backup_job,
        'interval',
        minutes=disaster_minutes,
        id='disaster_backup',
        replace_existing=True,
        max_instances=1,
        coalesce=True,
    )


def _money(v) -> str:
    try:
        return f"Ksh {float(v or 0):,.2f}"
    except Exception:
        return "Ksh 0.00"


def _period_window_dates(period: str, *, now_eat: datetime | None = None) -> tuple[date, date, str]:
    """Return (start_date, end_date, period_id) for a *completed* period.

    - daily: yesterday
    - weekly: previous ISO week (Mon-Sun)
    - monthly: previous calendar month
    - yearly: previous calendar year
    """
    now_eat = now_eat or get_eat_now()
    today = now_eat.date()
    p = (period or 'daily').lower()

    if p == 'daily':
        d = today - timedelta(days=1)
        return d, d, d.isoformat()

    if p == 'weekly':
        # Previous ISO week (Mon-Sun)
        this_monday = today - timedelta(days=today.weekday())
        start = this_monday - timedelta(days=7)
        end = this_monday - timedelta(days=1)
        iso_year, iso_week, _ = start.isocalendar()
        return start, end, f"{iso_year}-W{iso_week:02d}"

    if p == 'monthly':
        first_this_month = today.replace(day=1)
        end = first_this_month - timedelta(days=1)
        start = end.replace(day=1)
        return start, end, f"{start.year}-{start.month:02d}"

    if p == 'yearly':
        y = today.year - 1
        start = date(y, 1, 1)
        end = date(y, 12, 31)
        return start, end, str(y)

    # Fallback: treat as daily
    d = today - timedelta(days=1)
    return d, d, d.isoformat()


def _dt_range_for_dates(start_d: date, end_d: date) -> tuple[datetime, datetime]:
    start_dt = datetime.combine(start_d, datetime.min.time())
    # end exclusive
    end_dt = datetime.combine(end_d + timedelta(days=1), datetime.min.time())
    return start_dt, end_dt


def _render_table(rows: list[dict], columns: list[tuple[str, str]]) -> str:
    if not rows:
        return "<p><em>No data</em></p>"
    th = "".join([f"<th style='text-align:left;border-bottom:1px solid #ddd;padding:6px 8px;'>{escape(label)}</th>" for key, label in columns])
    body_parts = ["<table style='border-collapse:collapse;width:100%;'>", f"<thead><tr>{th}</tr></thead>", "<tbody>"]
    for r in rows:
        tds = []
        for key, _label in columns:
            val = r.get(key)
            tds.append(f"<td style='padding:6px 8px;border-bottom:1px solid #f0f0f0;'>{escape(str(val if val is not None else ''))}</td>")
        body_parts.append("<tr>" + "".join(tds) + "</tr>")
    body_parts.append("</tbody></table>")
    return "".join(body_parts)


def _report_drug_sales_summary(start_dt: datetime, end_dt: datetime) -> dict:
    total_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).join(Sale).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    total_units = db.session.query(func.coalesce(func.sum(SaleItem.quantity), 0)).join(Sale).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    cogs = db.session.query(func.coalesce(func.sum(SaleItem.quantity * Drug.buying_price), 0)).select_from(SaleItem).join(
        Drug, SaleItem.drug_id == Drug.id
    ).join(
        Sale, SaleItem.sale_id == Sale.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    top = db.session.query(
        Drug.name.label('name'),
        func.coalesce(func.sum(SaleItem.quantity), 0).label('units'),
        func.coalesce(func.sum(SaleItem.total_price), 0).label('amount'),
        func.coalesce(func.sum((SaleItem.unit_price - Drug.buying_price) * SaleItem.quantity), 0).label('profit')
    ).select_from(SaleItem).join(
        Drug, SaleItem.drug_id == Drug.id
    ).join(
        Sale, SaleItem.sale_id == Sale.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).group_by(Drug.name).order_by(func.sum(SaleItem.total_price).desc()).limit(10).all()

    rows = [
        {
            'name': r.name,
            'units': int(r.units or 0),
            'revenue': _money(r.amount),
            'profit': _money(r.profit),
        }
        for r in top
    ]

    return {
        'total_revenue': float(total_revenue or 0),
        'total_units': int(total_units or 0),
        'cogs': float(cogs or 0),
        'profit': float(total_revenue or 0) - float(cogs or 0),
        'top_rows': rows,
    }


def _report_controlled_drug_sales_summary(start_dt: datetime, end_dt: datetime) -> dict:
    total_revenue = db.session.query(func.coalesce(func.sum(ControlledSaleItem.total_price), 0)).select_from(ControlledSaleItem).join(
        ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
    ).filter(
        ControlledSale.created_at >= start_dt,
        ControlledSale.created_at < end_dt,
        ControlledSale.status == 'completed'
    ).scalar() or 0

    total_units = db.session.query(func.coalesce(func.sum(ControlledSaleItem.quantity), 0)).select_from(ControlledSaleItem).join(
        ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
    ).filter(
        ControlledSale.created_at >= start_dt,
        ControlledSale.created_at < end_dt,
        ControlledSale.status == 'completed'
    ).scalar() or 0

    cogs = db.session.query(
        func.coalesce(func.sum(ControlledSaleItem.quantity * func.coalesce(ControlledDrug.buying_price, 0)), 0)
    ).select_from(ControlledSaleItem).join(
        ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
    ).outerjoin(
        ControlledDrug, ControlledDrug.id == ControlledSaleItem.controlled_drug_id
    ).filter(
        ControlledSale.created_at >= start_dt,
        ControlledSale.created_at < end_dt,
        ControlledSale.status == 'completed'
    ).scalar() or 0

    top = db.session.query(
        ControlledSaleItem.controlled_drug_name.label('name'),
        func.coalesce(func.sum(ControlledSaleItem.quantity), 0).label('units'),
        func.coalesce(func.sum(ControlledSaleItem.total_price), 0).label('amount'),
        func.coalesce(func.sum((ControlledSaleItem.unit_price - func.coalesce(ControlledDrug.buying_price, 0)) * ControlledSaleItem.quantity), 0).label('profit')
    ).select_from(ControlledSaleItem).join(
        ControlledSale, ControlledSaleItem.sale_id == ControlledSale.id
    ).outerjoin(
        ControlledDrug, ControlledDrug.id == ControlledSaleItem.controlled_drug_id
    ).filter(
        ControlledSale.created_at >= start_dt,
        ControlledSale.created_at < end_dt,
        ControlledSale.status == 'completed'
    ).group_by(ControlledSaleItem.controlled_drug_name).order_by(func.sum(ControlledSaleItem.total_price).desc()).limit(10).all()

    rows = [
        {
            'name': r.name,
            'units': int(r.units or 0),
            'revenue': _money(r.amount),
            'profit': _money(r.profit),
        }
        for r in top
    ]

    return {
        'total_revenue': float(total_revenue or 0),
        'total_units': int(total_units or 0),
        'cogs': float(cogs or 0),
        'profit': float(total_revenue or 0) - float(cogs or 0),
        'top_rows': rows,
    }


def _report_lab_summary(start_dt: datetime, end_dt: datetime) -> dict:
    inpatient_filter = db.or_(Patient.ip_number.isnot(None), Patient.date_of_admission.isnot(None))

    total_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).select_from(SaleItem).join(
        Sale, SaleItem.sale_id == Sale.id
    ).join(
        Patient, Sale.patient_id == Patient.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.lab_test_id.isnot(None),
        inpatient_filter
    ).scalar() or 0

    total_count = db.session.query(func.coalesce(func.count(SaleItem.id), 0)).select_from(SaleItem).join(
        Sale, SaleItem.sale_id == Sale.id
    ).join(
        Patient, Sale.patient_id == Patient.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.lab_test_id.isnot(None),
        inpatient_filter
    ).scalar() or 0

    top_tests = db.session.query(
        LabTest.name.label('name'),
        func.coalesce(func.count(SaleItem.id), 0).label('count'),
        func.coalesce(func.sum(SaleItem.total_price), 0).label('amount')
    ).select_from(SaleItem).join(
        LabTest, SaleItem.lab_test_id == LabTest.id
    ).join(
        Sale, SaleItem.sale_id == Sale.id
    ).join(
        Patient, Sale.patient_id == Patient.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.lab_test_id.isnot(None),
        inpatient_filter
    ).group_by(LabTest.name).order_by(func.sum(SaleItem.total_price).desc()).limit(10).all()

    rows = [
        {
            'name': r.name,
            'count': int(r.count or 0),
            'revenue': _money(r.amount),
        }
        for r in top_tests
    ]

    return {
        'total_revenue': float(total_revenue or 0),
        'total_count': int(total_count or 0),
        'top_rows': rows,
    }


def _report_general_summary(start_dt: datetime, end_dt: datetime) -> dict:
    drug_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).select_from(SaleItem).join(
        Sale, SaleItem.sale_id == Sale.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.drug_id.isnot(None)
    ).scalar() or 0

    lab_revenue = db.session.query(func.coalesce(func.sum(SaleItem.total_price), 0)).select_from(SaleItem).join(
        Sale, SaleItem.sale_id == Sale.id
    ).filter(
        Sale.created_at >= start_dt,
        Sale.created_at < end_dt,
        Sale.status == 'completed',
        SaleItem.lab_test_id.isnot(None)
    ).scalar() or 0

    try:
        expenses_total = db.session.query(func.coalesce(func.sum(Expense.amount), 0)).filter(
            Expense.created_at >= start_dt,
            Expense.created_at < end_dt
        ).scalar() or 0
    except Exception:
        expenses_total = 0

    total_revenue = float(drug_revenue or 0) + float(lab_revenue or 0)
    net_income = total_revenue - float(expenses_total or 0)

    return {
        'total_revenue': total_revenue,
        'drug_revenue': float(drug_revenue or 0),
        'lab_revenue': float(lab_revenue or 0),
        'expenses_total': float(expenses_total or 0),
        'net_income': net_income,
    }


def _should_send_once(key: str, period_id: str) -> bool:
    state = _load_instance_json('auto_email_state.json', default={})
    sent = state.get('sent', {}) if isinstance(state, dict) else {}
    last = (sent.get(key) or '').strip()
    if last == period_id:
        return False
    sent[key] = period_id
    state['sent'] = sent
    state['updated_at'] = get_eat_now().isoformat()
    try:
        _save_instance_json('auto_email_state.json', state)
    except Exception:
        # If state cannot persist, still allow sending (better to notify than to skip forever)
        pass
    return True


def _send_admin_sales_report(period: str) -> None:
    """Send combined sales report email to all admin users."""
    try:
        with app.app_context():
            recipients = _get_admin_recipient_emails()
            if not recipients:
                return

            now_eat = get_eat_now()
            p = (period or '').lower()

            if p == 'daily':
                # Daily sales report cutoff is 22:00 EAT of the current day.
                start_d = now_eat.date()
                end_d = start_d
                period_id = start_d.isoformat()
                key = f"admin_sales_report:{p}"
                if not _should_send_once(key, period_id):
                    return
                start_dt = datetime.combine(start_d, datetime.min.time())
                end_dt = now_eat.replace(hour=22, minute=0, second=0, microsecond=0)
                range_label = f"{start_d.isoformat()} (00:00 to 22:00 EAT)"
            else:
                start_d, end_d, period_id = _period_window_dates(period, now_eat=now_eat)
                key = f"admin_sales_report:{p}"
                if not _should_send_once(key, period_id):
                    return
                start_dt, end_dt = _dt_range_for_dates(start_d, end_d)
                range_label = f"{start_d.isoformat()} to {end_d.isoformat()}"

            drug = _report_drug_sales_summary(start_dt, end_dt)
            controlled = _report_controlled_drug_sales_summary(start_dt, end_dt)
            lab = _report_lab_summary(start_dt, end_dt)
            general = _report_general_summary(start_dt, end_dt)

            subject = f"Sales Report ({period.title()}) - {period_id}"

            parts = [
                "<div style='font-family:Arial,sans-serif;max-width:900px;margin:0 auto;'>",
                f"<h2 style='margin:0 0 6px 0;'>Sales Report ({escape(period.title())})</h2>",
                f"<div style='color:#555;margin-bottom:16px;'>Period: <strong>{escape(range_label)}</strong></div>",

                "<h3>General</h3>",
                "<ul>",
                f"<li>Total revenue: <strong>{escape(_money(general['total_revenue']))}</strong></li>",
                f"<li>Drug revenue: {escape(_money(general['drug_revenue']))}</li>",
                f"<li>Lab revenue: {escape(_money(general['lab_revenue']))}</li>",
                f"<li>Expenses: {escape(_money(general['expenses_total']))}</li>",
                f"<li>Net income: <strong>{escape(_money(general['net_income']))}</strong></li>",
                "</ul>",

                "<h3>Drugs</h3>",
                "<ul>",
                f"<li>Revenue: <strong>{escape(_money(drug['total_revenue']))}</strong></li>",
                f"<li>Units sold: {escape(str(drug['total_units']))}</li>",
                f"<li>COGS: {escape(_money(drug['cogs']))}</li>",
                f"<li>Estimated profit: <strong>{escape(_money(drug['profit']))}</strong></li>",
                "</ul>",
                _render_table(drug['top_rows'], [('name', 'Drug'), ('units', 'Units'), ('revenue', 'Revenue'), ('profit', 'Profit')]),

                "<h3>Controlled Drugs</h3>",
                "<ul>",
                f"<li>Revenue: <strong>{escape(_money(controlled['total_revenue']))}</strong></li>",
                f"<li>Units sold: {escape(str(controlled['total_units']))}</li>",
                f"<li>COGS: {escape(_money(controlled['cogs']))}</li>",
                f"<li>Estimated profit: <strong>{escape(_money(controlled['profit']))}</strong></li>",
                "</ul>",
                _render_table(controlled['top_rows'], [('name', 'Controlled Drug'), ('units', 'Units'), ('revenue', 'Revenue'), ('profit', 'Profit')]),

                "<h3>Labs (Inpatient)</h3>",
                "<ul>",
                f"<li>Revenue: <strong>{escape(_money(lab['total_revenue']))}</strong></li>",
                f"<li>Tests count: {escape(str(lab['total_count']))}</li>",
                "</ul>",
                _render_table(lab['top_rows'], [('name', 'Test'), ('count', 'Count'), ('revenue', 'Revenue')]),

                "<hr style='margin:18px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>This is an automated email generated by Makokha Medical Centre system.</div>",
                "</div>",
            ]
            html = "".join(parts)

            text_body = f"Sales Report ({period.title()})\nPeriod: {range_label}\n\nGeneral: Total {general['total_revenue']}, Net {general['net_income']}\nDrugs: Revenue {drug['total_revenue']}, Units {drug['total_units']}\nControlled: Revenue {controlled['total_revenue']}, Units {controlled['total_units']}\nLabs: Revenue {lab['total_revenue']}, Count {lab['total_count']}\n"

            for r in recipients:
                try:
                    _send_system_email(recipient=r, subject=subject, html=html, text_body=text_body)
                except Exception as e:
                    app.logger.error(f"Report email failed to {r}: {e}")
    except Exception as e:
        try:
            app.logger.error(f"Scheduled report job failed: {e}", exc_info=True)
        except Exception:
            pass


def _scheduler_apply_reporting_jobs(scheduler: BackgroundScheduler):
    """Configure report email jobs.

    Times are in EAT (Africa/Nairobi).
    """
    def _nightly_reports():
        _send_admin_sales_report('daily')

        now_eat = get_eat_now()
        today = now_eat.date()
        # Weekly rollup on Monday night (previous ISO week completed).
        if today.weekday() == 0:
            _send_admin_sales_report('weekly')
        # Monthly rollup on 1st night (previous month completed).
        if today.day == 1:
            _send_admin_sales_report('monthly')
        # Yearly rollup on Jan 1st night (previous year completed).
        if today.month == 1 and today.day == 1:
            _send_admin_sales_report('yearly')

    scheduler.add_job(
        _nightly_reports,
        'cron',
        hour=22,
        minute=0,
        timezone=EAT,
        id='email_reports_nightly',
        replace_existing=True,
        max_instances=1,
        coalesce=True,
        misfire_grace_time=60 * 60 * 48,
    )

    def _monthly_financial_report_job() -> None:
        # Runs on the 1st night of the month, sending the *previous* month report.
        now_eat = get_eat_now()
        if now_eat.month == 1:
            year, month = now_eat.year - 1, 12
        else:
            year, month = now_eat.year, now_eat.month - 1
        _send_admin_monthly_financial_report(year=year, month=month)

    scheduler.add_job(
        _monthly_financial_report_job,
        'cron',
        day=1,
        hour=22,
        minute=20,
        timezone=EAT,
        id='email_financial_monthly_report',
        replace_existing=True,
        max_instances=1,
        coalesce=True,
        misfire_grace_time=60 * 60 * 48,
    )


def _stock_alert_snapshot() -> dict:
    """Build a stable snapshot of current stock alerts."""
    today = get_eat_now().date()

    def drug_rows():
        rows = []
        for d in Drug.query.all():
            try:
                remaining = int(d.remaining_quantity or 0)
                exp = d.expiry_date
                status = None
                if exp and exp < today:
                    status = 'expired'
                elif remaining <= 0:
                    status = 'out-of-stock'
                elif remaining < 10:
                    status = 'low-stock'
                elif exp and (exp - today).days < 30:
                    status = 'expiring-soon'
                if status:
                    rows.append({
                        'kind': 'drug',
                        'id': int(d.id),
                        'name': str(d.name),
                        'remaining': remaining,
                        'expiry': exp.isoformat() if exp else None,
                        'status': status,
                    })
            except Exception:
                continue
        return rows

    def controlled_rows():
        rows = []
        for d in ControlledDrug.query.all():
            try:
                remaining = int(d.remaining_quantity or 0)
                exp = d.expiry_date
                status = None
                if exp and exp < today:
                    status = 'expired'
                elif remaining <= 0:
                    status = 'out-of-stock'
                elif remaining < 10:
                    status = 'low-stock'
                elif exp and (exp - today).days < 30:
                    status = 'expiring-soon'
                if status:
                    rows.append({
                        'kind': 'controlled',
                        'id': int(d.id),
                        'name': str(d.name),
                        'remaining': remaining,
                        'expiry': exp.isoformat() if exp else None,
                        'status': status,
                    })
            except Exception:
                continue
        return rows

    alerts = drug_rows() + controlled_rows()
    # Stable ordering for dedupe
    alerts.sort(key=lambda x: (x.get('kind', ''), x.get('status', ''), x.get('name', ''), x.get('id', 0)))

    # Group counts
    counts = {'out-of-stock': 0, 'low-stock': 0, 'expiring-soon': 0, 'expired': 0}
    for a in alerts:
        s = a.get('status')
        if s in counts:
            counts[s] += 1

    return {
        'date': today.isoformat(),
        'counts': counts,
        'alerts': alerts,
    }


def _send_admin_stock_alerts() -> None:
    try:
        with app.app_context():
            recipients = _get_admin_recipient_emails()
            if not recipients:
                return

            snap = _stock_alert_snapshot()
            # Only send when there are alerts
            total_alerts = int(sum((snap.get('counts') or {}).values()))
            if total_alerts <= 0:
                return

            key = 'admin_stock_alerts'
            # Dedupe by comparing snapshot hash
            payload = json.dumps(snap, ensure_ascii=False, separators=(',', ':'), sort_keys=True)
            digest = hashlib.sha256(payload.encode('utf-8')).hexdigest()

            state = _load_instance_json('auto_stock_state.json', default={})
            last = (state.get('last_digest') if isinstance(state, dict) else None) or None
            if last == digest:
                return
            state['last_digest'] = digest
            state['last_sent_at'] = get_eat_now().isoformat()
            try:
                _save_instance_json('auto_stock_state.json', state)
            except Exception:
                pass

            counts = snap.get('counts') or {}
            subject = f"Drugs Report (Low/Out/Expiry) - {snap.get('date')}"

            # Limit rows in email body to avoid huge emails
            alerts = snap.get('alerts') or []
            max_rows = 80
            shown = alerts[:max_rows]
            omitted = max(0, len(alerts) - len(shown))

            table_rows = []
            for a in shown:
                table_rows.append({
                    'type': 'Controlled Drug' if a.get('kind') == 'controlled' else 'Drug',
                    'name': a.get('name', ''),
                    'status': a.get('status', ''),
                    'remaining': a.get('remaining', ''),
                    'expiry': a.get('expiry', '') or '',
                })

            html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:900px;margin:0 auto;'>",
                "<h2 style='margin:0 0 6px 0;'>Drugs Report (Low stock / Out of stock / Expiring)</h2>",
                f"<div style='color:#555;margin-bottom:10px;'>Date: <strong>{escape(str(snap.get('date') or ''))}</strong></div>",
                "<ul>",
                f"<li>Out of stock: <strong>{escape(str(counts.get('out-of-stock', 0)))}</strong></li>",
                f"<li>Low stock: <strong>{escape(str(counts.get('low-stock', 0)))}</strong></li>",
                f"<li>Expiring soon (&lt;30 days): <strong>{escape(str(counts.get('expiring-soon', 0)))}</strong></li>",
                f"<li>Expired: <strong>{escape(str(counts.get('expired', 0)))}</strong></li>",
                "</ul>",
                _render_table(table_rows, [('type', 'Type'), ('name', 'Item'), ('status', 'Status'), ('remaining', 'Remaining'), ('expiry', 'Expiry')]),
                (f"<p style='color:#777;font-size:12px;'>Showing first {max_rows} alerts; {omitted} more not shown.</p>" if omitted else ""),
                "</div>",
            ])

            text_body = (
                f"Drugs Report ({snap.get('date')})\n"
                f"Out of stock: {counts.get('out-of-stock', 0)}\n"
                f"Low stock: {counts.get('low-stock', 0)}\n"
                f"Expiring soon: {counts.get('expiring-soon', 0)}\n"
                f"Expired: {counts.get('expired', 0)}\n"
            )

            for r in recipients:
                try:
                    _send_system_email(recipient=r, subject=subject, html=html, text_body=text_body)
                except Exception as e:
                    app.logger.error(f"Stock alert email failed to {r}: {e}")
    except Exception as e:
        try:
            app.logger.error(f"Stock alert job failed: {e}", exc_info=True)
        except Exception:
            pass


def _scheduler_apply_stock_jobs(scheduler: BackgroundScheduler):
    # Daily scan at 22:10 EAT
    scheduler.add_job(
        _send_admin_stock_alerts,
        'cron',
        hour=22,
        minute=10,
        timezone=EAT,
        id='email_stock_alerts_daily',
        replace_existing=True,
        max_instances=1,
        coalesce=True,
        misfire_grace_time=60 * 60 * 48,
    )


def _send_admin_monthly_financial_report(*, year: int, month: int) -> None:
    """Generate and email a monthly financial report document to all admins."""
    try:
        with app.app_context():
            recipients = _get_admin_recipient_emails()
            if not recipients:
                return

            year = int(year)
            month = int(month)
            if month < 1 or month > 12:
                return

            period_id = f"{year:04d}-{month:02d}"
            key = "admin_financial_report:monthly"
            if not _should_send_once(key, period_id):
                return

            metrics = get_monthly_financial_summary(year, month) or {}

            start_date = metrics.get('start_date')
            end_date = metrics.get('end_date')
            date_range = metrics.get('date_range') or (
                f"{start_date} to {end_date}" if start_date and end_date else period_id
            )

            def _get_num(name: str) -> float:
                try:
                    return float(metrics.get(name) or 0)
                except Exception:
                    return 0.0

            total_revenue = _get_num('total_revenue')
            total_expense = _get_num('total_expense')
            net_profit = _get_num('net_profit')
            profit_margin = _get_num('profit_margin')

            subject = f"Monthly Financial Report - {period_id}"

            # Build CSV attachment (Excel-friendly)
            import csv
            import io

            csv_buf = io.StringIO()
            w = csv.writer(csv_buf)
            w.writerow([f"Monthly Financial Report - {period_id}"])
            w.writerow(["Date Range", str(date_range)])
            w.writerow([])
            w.writerow(["Summary", "Value"])
            w.writerow(["Total Revenue", total_revenue])
            w.writerow(["Total Expenses", total_expense])
            w.writerow(["Net Profit", net_profit])
            w.writerow(["Profit Margin (%)", profit_margin])
            w.writerow(["Refunds", _get_num('refunds')])
            w.writerow([])

            w.writerow(["Revenue Breakdown", "Value"])
            w.writerow(["Pharmacy", _get_num('pharmacy_revenue')])
            w.writerow(["Lab", _get_num('lab_revenue')])
            w.writerow(["Imaging", _get_num('imaging_revenue')])
            w.writerow(["Consultation/Services", _get_num('consultation_revenue')])
            w.writerow(["Insurance", _get_num('insurance_revenue')])
            w.writerow(["Other", _get_num('other_revenue')])
            w.writerow([])

            w.writerow(["Expense Breakdown", "Value"])
            w.writerow(["Payroll", _get_num('payroll_expense')])
            w.writerow(["Pharmacy/Procurement", _get_num('pharmacy_expense')])
            w.writerow(["Equipment", _get_num('equipment_expense')])
            w.writerow(["Utilities", _get_num('utilities_expense')])
            w.writerow(["Debt Payment", _get_num('debt_payment')])
            w.writerow(["Other", _get_num('other_expense')])
            w.writerow([])

            w.writerow(["Cashflow (In)", "Value"])
            w.writerow(["Cash", _get_num('cash_in')])
            w.writerow(["MPESA", _get_num('mpesa_in')])
            w.writerow(["Card", _get_num('card_in')])
            w.writerow(["Bank", _get_num('bank_in')])
            w.writerow(["Total In", _get_num('total_cash_in')])
            w.writerow([])

            w.writerow(["Cashflow (Out)", "Value"])
            w.writerow(["Cash", _get_num('cash_out')])
            w.writerow(["MPESA", _get_num('mpesa_out')])
            w.writerow(["Card", _get_num('card_out')])
            w.writerow(["Bank", _get_num('bank_out')])
            w.writerow(["Total Out", _get_num('total_cash_out')])
            w.writerow([])

            w.writerow(["Outstanding", "Value"])
            w.writerow(["Outstanding Invoices", _get_num('outstanding_invoices')])
            w.writerow(["Overdue Amount", _get_num('overdue_amount')])
            w.writerow(["Outstanding Debtor", _get_num('outstanding_debtor')])
            w.writerow(["Outstanding Debtor Count", int(metrics.get('outstanding_debtor_count') or 0)])
            w.writerow(["Outstanding Insurance", _get_num('outstanding_insurance')])
            w.writerow(["Outstanding Insurance Count", int(metrics.get('outstanding_insurance_count') or 0)])
            w.writerow([])

            w.writerow(["Patients", "Value"])
            w.writerow(["Total Patients Served", int(metrics.get('total_patients_served') or 0)])
            w.writerow(["New Patients", int(metrics.get('new_patients') or 0)])
            w.writerow(["Returning Patients", int(metrics.get('returning_patients') or 0)])

            csv_bytes = csv_buf.getvalue().encode('utf-8-sig')

            # Build simple HTML attachment + email body
            html_doc = "".join([
                "<html><head><meta charset='utf-8'></head><body style='font-family:Arial,sans-serif;'>",
                f"<h2>Monthly Financial Report - {escape(period_id)}</h2>",
                f"<p><strong>Date Range:</strong> {escape(str(date_range))}</p>",
                "<h3>Summary</h3>",
                "<ul>",
                f"<li>Total revenue: <strong>{escape(_money(total_revenue))}</strong></li>",
                f"<li>Total expenses: <strong>{escape(_money(total_expense))}</strong></li>",
                f"<li>Net profit: <strong>{escape(_money(net_profit))}</strong></li>",
                f"<li>Profit margin: <strong>{escape(f'{profit_margin:.2f}%')}</strong></li>",
                "</ul>",
                "<p>This email includes attached documents (CSV + HTML) for archiving and sharing.</p>",
                "</body></html>",
            ])
            html_bytes = html_doc.encode('utf-8')

            # Email body
            html_body = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:900px;margin:0 auto;'>",
                f"<h2 style='margin:0 0 6px 0;'>Monthly Financial Report - {escape(period_id)}</h2>",
                f"<div style='color:#555;margin-bottom:10px;'>Date Range: <strong>{escape(str(date_range))}</strong></div>",
                "<ul>",
                f"<li>Total revenue: <strong>{escape(_money(total_revenue))}</strong></li>",
                f"<li>Total expenses: <strong>{escape(_money(total_expense))}</strong></li>",
                f"<li>Net profit: <strong>{escape(_money(net_profit))}</strong></li>",
                f"<li>Profit margin: <strong>{escape(f'{profit_margin:.2f}%')}</strong></li>",
                "</ul>",
                "<p style='color:#444;'>Attached: <strong>financial-report.csv</strong> (for Excel) and <strong>financial-report.html</strong>.</p>",
                "<div style='color:#777;font-size:12px;'>Automated email generated by Makokha Medical Centre system.</div>",
                "</div>",
            ])

            attachments = [
                (f"financial-report-{period_id}.csv", "text/csv", csv_bytes),
                (f"financial-report-{period_id}.html", "text/html", html_bytes),
            ]

            text_body = (
                f"Monthly Financial Report - {period_id}\n"
                f"Date Range: {date_range}\n\n"
                f"Total revenue: {total_revenue}\n"
                f"Total expenses: {total_expense}\n"
                f"Net profit: {net_profit}\n"
                f"Profit margin: {profit_margin:.2f}%\n\n"
                f"Attachments: financial-report-{period_id}.csv, financial-report-{period_id}.html\n"
            )

            for r in recipients:
                try:
                    _send_system_email(
                        recipient=r,
                        subject=subject,
                        html=html_body,
                        text_body=text_body,
                        attachments=attachments,
                    )
                except Exception as e:
                    app.logger.error(f"Monthly financial report email failed to {r}: {e}")
    except Exception as e:
        try:
            app.logger.error(f"Monthly financial report job failed: {e}", exc_info=True)
        except Exception:
            pass

# Initialize scheduler (skip in fast dev mode or debug mode)
if not app.config.get('FAST_DEV') and not app.config.get('DEBUG'):
    if not app.debug or os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
        scheduler = BackgroundScheduler()
        _scheduler_apply_backup_jobs(scheduler)
        _scheduler_apply_reporting_jobs(scheduler)
        _scheduler_apply_stock_jobs(scheduler)
        scheduler.add_job(
            scheduled_ai_dosage_agent,
            'interval',
            minutes=30,
            id='ai_dosage_agent',
            replace_existing=True,
            max_instances=1,
            coalesce=True,
        )
        scheduler.start()
elif app.config.get('DEBUG'):
    app.logger.info('DEBUG mode: background schedulers disabled for faster startup.')
else:
    app.logger.warning('FAST_DEV enabled: background schedulers disabled for faster startup.')

# ======================
# MONEY MANAGEMENT ROUTES
# ======================

@app.route('/admin/money')
@login_required
def manage_money():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    mpesa_payouts = []
    mpesa_status_queries = []
    mpesa_payout_receipt_urls = {}
    mpesa_status_receipt_urls = {}
    try:
        if database_has_table('mpesa_payouts'):
            mpesa_payouts = MpesaPayout.query.order_by(MpesaPayout.created_at.desc()).limit(50).all()
        if database_has_table('mpesa_txn_status_queries'):
            mpesa_status_queries = MpesaTransactionStatusQuery.query.order_by(MpesaTransactionStatusQuery.created_at.desc()).limit(50).all()

        # Map each row to a posted ledger Transaction receipt (when available)
        if _transaction_supports_metadata():
            if mpesa_payouts:
                payout_ids = [int(p.id) for p in mpesa_payouts if getattr(p, 'id', None) is not None]
                if payout_ids:
                    txs = (
                        Transaction.query
                        .filter(Transaction.reference_table == 'mpesa_payouts')
                        .filter(Transaction.reference_id.in_(payout_ids))
                        .all()
                    )
                    for tx in (txs or []):
                        try:
                            mpesa_payout_receipt_urls[int(tx.reference_id)] = url_for('admin_transaction_receipt', transaction_id=int(tx.id))
                        except Exception:
                            pass

            if mpesa_status_queries:
                query_ids = [int(q.id) for q in mpesa_status_queries if getattr(q, 'id', None) is not None]
                if query_ids:
                    txs = (
                        Transaction.query
                        .filter(Transaction.reference_table == 'mpesa_txn_status_queries')
                        .filter(Transaction.reference_id.in_(query_ids))
                        .all()
                    )
                    for tx in (txs or []):
                        try:
                            mpesa_status_receipt_urls[int(tx.reference_id)] = url_for('admin_transaction_receipt', transaction_id=int(tx.id))
                        except Exception:
                            pass
    except Exception:
        mpesa_payouts = []
        mpesa_status_queries = []
        mpesa_payout_receipt_urls = {}
        mpesa_status_receipt_urls = {}
    
    return render_template('admin/money.html',
                        drawings=Transaction.query.filter_by(transaction_type='drawing').order_by(Transaction.created_at.desc()).all(),
                        expenses=Expense.query.order_by(Expense.created_at.desc()).all(),
                        purchases=Purchase.query.order_by(Purchase.created_at.desc()).all(),
                        purchase_orders=PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).all(),
                        vendors=Vendor.query.filter_by(is_active=True).order_by(Vendor.name.asc()).all(),
                        payroll=Payroll.query.order_by(Payroll.created_at.desc()).all(),
                        debts=Debt.query.order_by(Debt.created_at.desc()).all(),
                        debtors=Debtor.query.order_by(Debtor.amount_owed.desc()).all(),
                        insurance_providers=InsuranceProvider.query.order_by(InsuranceProvider.name.asc()).all(),
                        insurance_policies=InsurancePolicy.query.order_by(InsurancePolicy.created_at.desc()).limit(200).all(),
                        insurance_claims=InsuranceClaim.query.order_by(InsuranceClaim.created_at.desc()).limit(200).all(),
                        employees=Employee.query.all(),
                        mpesa_payouts=mpesa_payouts,
                        mpesa_status_queries=mpesa_status_queries,
                        mpesa_payout_receipt_urls=mpesa_payout_receipt_urls,
                        mpesa_status_receipt_urls=mpesa_status_receipt_urls,
                        current_date=get_eat_now().date())


@app.route('/admin/money/mpesa/verify', methods=['POST'])
@login_required
def admin_money_mpesa_verify():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if not database_has_table('mpesa_txn_status_queries'):
        flash('M-Pesa tables not ready. Run migrations (flask db upgrade).', 'warning')
        return redirect(url_for('manage_money'))

    from utils.mpesa_daraja import normalize_msisdn_ke

    mpesa_code = (request.form.get('mpesa_code') or '').strip().upper()
    invoice_number = (request.form.get('invoice_number') or '').strip()
    phone_raw = (request.form.get('phone_number') or '').strip()
    phone = normalize_msisdn_ke(phone_raw) if phone_raw else None
    amount = (request.form.get('amount') or '').strip()

    if not mpesa_code:
        flash('M-Pesa code is required.', 'danger')
        return redirect(url_for('manage_money'))

    payload = {
        'mpesa_code': mpesa_code,
        'invoice_number': invoice_number,
        'phone_number': phone,
        'amount': amount,
    }
    ok, result = _mpesa_initiate_transaction_status_query(payload, requested_by_user_id=int(current_user.id))
    if not ok:
        flash(result.get('error') or 'Transaction status query failed.', 'danger')
    else:
        qid = result.get('query_id')
        flash(f'Transaction Status query submitted{(" (ID %s)" % qid) if qid else ""}. Await callback result.', 'success')

    return redirect(url_for('manage_money'))


@app.route('/admin/money/mpesa/payout/b2c', methods=['POST'])
@login_required
def admin_money_mpesa_payout_b2c():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if not database_has_table('mpesa_payouts'):
        flash('M-Pesa tables not ready. Run migrations (flask db upgrade).', 'warning')
        return redirect(url_for('manage_money'))

    from utils.mpesa_daraja import normalize_msisdn_ke

    phone = normalize_msisdn_ke((request.form.get('phone_number') or '').strip())
    amount = (request.form.get('amount') or '').strip()
    remarks = (request.form.get('remarks') or 'Clinic payout').strip()
    occasion = (request.form.get('occasion') or '').strip()

    payload = {
        'phone_number': phone,
        'amount': amount,
        'remarks': remarks,
        'occasion': occasion,
    }
    ok, result = _mpesa_initiate_payout_b2c(payload, initiated_by_user_id=int(current_user.id))
    if not ok:
        flash(result.get('error') or 'B2C payout failed.', 'danger')
    else:
        flash('B2C payout submitted. Await callback result.', 'success')

    return redirect(url_for('manage_money'))


@app.route('/admin/money/mpesa/payout/b2b', methods=['POST'])
@login_required
def admin_money_mpesa_payout_b2b():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if not database_has_table('mpesa_payouts'):
        flash('M-Pesa tables not ready. Run migrations (flask db upgrade).', 'warning')
        return redirect(url_for('manage_money'))

    amount = (request.form.get('amount') or '').strip()
    remarks = (request.form.get('remarks') or 'Clinic payout').strip()
    account_ref = (request.form.get('account_reference') or '').strip()
    paybill = (request.form.get('paybill') or '').strip()
    till = (request.form.get('till') or '').strip()

    payload = {
        'amount': amount,
        'remarks': remarks,
        'account_reference': account_ref,
        'paybill': paybill,
        'till': till,
    }
    ok, result = _mpesa_initiate_payout_b2b(payload, initiated_by_user_id=int(current_user.id))
    if not ok:
        flash(result.get('error') or 'B2B payout failed.', 'danger')
    else:
        flash('B2B payout submitted. Await callback result.', 'success')

    return redirect(url_for('manage_money'))


@app.route('/admin/money/mpesa/payout/b2pochi', methods=['POST'])
@login_required
def admin_money_mpesa_payout_b2pochi():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if not database_has_table('mpesa_payouts'):
        flash('M-Pesa tables not ready. Run migrations (flask db upgrade).', 'warning')
        return redirect(url_for('manage_money'))

    from utils.mpesa_daraja import normalize_msisdn_ke

    phone = normalize_msisdn_ke((request.form.get('phone_number') or '').strip())
    amount = (request.form.get('amount') or '').strip()
    remarks = (request.form.get('remarks') or 'Clinic payout').strip()
    occasion = (request.form.get('occasion') or '').strip()

    payload = {
        'phone_number': phone,
        'amount': amount,
        'remarks': remarks,
        'occasion': occasion,
    }
    ok, result = _mpesa_initiate_payout_b2pochi(payload, initiated_by_user_id=int(current_user.id))
    if not ok:
        flash(result.get('error') or 'B2Pochi payout failed.', 'danger')
    else:
        flash('B2Pochi payout submitted. Await callback result.', 'success')

    return redirect(url_for('manage_money'))


@app.route('/admin/purchase_orders')
@login_required
def purchase_orders():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
    
    pos = PurchaseOrder.query.order_by(PurchaseOrder.created_at.desc()).all()
    return render_template('admin/purchase_orders.html', purchase_orders=pos)

@app.route('/admin/purchase_orders/create', methods=['GET', 'POST'])
@login_required
def create_purchase_order():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
    
    if request.method == 'POST':
        vendor_id = request.form.get('vendor_id')
        notes = request.form.get('notes')
        
        # Items logic
        descriptions = request.form.getlist('item_description')
        quantities = request.form.getlist('item_quantity')
        unit_prices = request.form.getlist('item_unit_price')
        
        po = PurchaseOrder(
            po_number=f"PO-{int(datetime.now().timestamp())}",
            vendor_id=vendor_id,
            date_ordered=get_eat_now(),
            notes=notes,
            created_by_id=current_user.id,
            status='pending'
        )
        db.session.add(po)
        db.session.flush()
        
        total_amount = 0
        for i in range(len(descriptions)):
            try:
                qty = int(quantities[i])
                price = float(unit_prices[i])
                total = qty * price
                
                item = PurchaseOrderItem(
                    purchase_order_id=po.id,
                    description=descriptions[i],
                    quantity=qty,
                    unit_price=price,
                    total_price=total
                )
                db.session.add(item)
                total_amount += total
            except (ValueError, IndexError):
                continue
                
        po.total_amount = total_amount
        db.session.commit()
        flash('Purchase Order created successfully', 'success')
        
        # Handle AJAX requests
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({
                'success': True,
                'message': 'LPO created successfully',
                'po_id': po.id,
                'po_number': po.po_number
            })
        
        return redirect(url_for('manage_money'))
        
    vendors = Vendor.query.filter_by(is_active=True).all()
    return render_template('admin/create_edit_purchase_order.html', vendors=vendors)

@app.route('/admin/purchase_orders/<int:po_id>')
@login_required
def view_purchase_order(po_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    po = _db_get_or_404(PurchaseOrder, po_id)
    return render_template('admin/view_purchase_order.html', po=po)

@app.route('/admin/purchase_order/<int:po_id>/pdf')
@login_required
def purchase_order_pdf(po_id):
    """Generate printable PDF for Local Purchase Order (LPO)"""
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    po = _db_get_or_404(PurchaseOrder, po_id)
    now = get_eat_now()
    return render_template('admin/lpo_pdf.html', 
                         po=po, 
                         now=now,
                         current_user=current_user,
                         signature_date=now.strftime('%d %B %Y'),
                         signer_name="Dr. J. Makokha",
                         signer_title="Medical Director")

@app.route('/admin/purchase_orders/<int:po_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_purchase_order(po_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    po = _db_get_or_404(PurchaseOrder, po_id)
    
    if request.method == 'POST':
        po.vendor_id = request.form.get('vendor_id')
        po.notes = request.form.get('notes')
        status = request.form.get('status')
        if status:
            po.status = status
            
        # Recreate items (simplest approach for now)
        PurchaseOrderItem.query.filter_by(purchase_order_id=po.id).delete()
        
        descriptions = request.form.getlist('item_description')
        quantities = request.form.getlist('item_quantity')
        unit_prices = request.form.getlist('item_unit_price')
        
        total_amount = 0
        for i in range(len(descriptions)):
            try:
                qty = int(quantities[i])
                price = float(unit_prices[i])
                total = qty * price
                
                item = PurchaseOrderItem(
                    purchase_order_id=po.id,
                    description=descriptions[i],
                    quantity=qty,
                    unit_price=price,
                    total_price=total
                )
                db.session.add(item)
                total_amount += total
            except (ValueError, IndexError):
                continue
        
        po.total_amount = total_amount
        db.session.commit()
        flash('Purchase Order updated successfully', 'success')
        
        # Handle AJAX requests
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.headers.get('X-CSRFToken'):
            return jsonify({
                'success': True,
                'message': 'LPO updated successfully'
            })
        
        return redirect(url_for('manage_money'))
        
    vendors = Vendor.query.filter_by(is_active=True).all()
    return render_template('admin/create_edit_purchase_order.html', po=po, vendors=vendors)


@app.route('/admin/delete_purchase-order/<int:po_id>', methods=['POST'])
@login_required
def delete_purchase_order(po_id):
    """Delete a purchase order and its items"""
    try:
        po = _db_get_or_404(PurchaseOrder, po_id)
        po_number = po.po_number
        
        # Delete associated items first
        PurchaseOrderItem.query.filter_by(purchase_order_id=po.id).delete()
        
        # Delete the purchase order
        db.session.delete(po)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': f'LPO {po_number} deleted successfully'
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting purchase order: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'Failed to delete LPO: {str(e)}'
        }), 500


@app.route('/admin/expenses')
@login_required
def expenses():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
    
    all_expenses = Expense.query.order_by(Expense.created_at.desc()).all()
    return render_template('admin/expenses.html', expenses=all_expenses)

@app.route('/admin/expenses/create', methods=['GET', 'POST'])
@login_required
def create_expense():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    if request.method == 'POST':
        category = request.form.get('category')
        amount = float(request.form.get('amount'))
        date_str = request.form.get('date')
        vendor_id = request.form.get('vendor_id')
        description = request.form.get('description')

        # Budget enforcement (warn-only by default)
        try:
            paid_d = datetime.strptime(date_str, '%Y-%m-%d').date() if date_str else get_eat_now().date()
            try:
                paid_dt = datetime(paid_d.year, paid_d.month, paid_d.day, tzinfo=EAT)
            except Exception:
                paid_dt = datetime.combine(paid_d, datetime.min.time())

            budget_check = _budget_check_outflow('admin', float(amount or 0), when_dt=paid_dt)
            if budget_check and budget_check.get('block'):
                flash(budget_check.get('message') or 'Budget exceeded for this month.', 'danger')
                return redirect(url_for('expenses'))
        except Exception:
            pass
        
        expense = Expense(
            expense_number=generate_expense_number(),
            expense_type=category,
            amount=amount,
            paid_date=datetime.strptime(date_str, '%Y-%m-%d').date() if date_str else get_eat_now().date(),
            vendor_id=vendor_id if vendor_id else None,
            description=description,
            user_id=current_user.id,
            status='paid'
        )
        db.session.add(expense)
        db.session.flush()
        
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=amount,
            user_id=current_user.id,
            reference_id=expense.id,
            notes=f"Expense: {category}"
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='expenses',
            direction='OUT',
            status='posted',
            department='admin',
            category=(category or 'expense'),
            payment_method=(request.form.get('payment_method') or '').strip() or None,
        )
        db.session.add(transaction)
        
        db.session.commit()
        flash('Expense created successfully', 'success')
        return redirect(url_for('expenses'))
        
    vendors = Vendor.query.filter_by(is_active=True).all()
    return render_template('admin/create_edit_expense.html', vendors=vendors, expense=None)

@app.route('/admin/expenses/<int:expense_id>/edit', methods=['GET', 'POST'])
@login_required
def edit_expense(expense_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    expense = _db_get_or_404(Expense, expense_id)
    
    if request.method == 'POST':
        expense.expense_type = request.form.get('category')
        expense.amount = float(request.form.get('amount'))
        date_str = request.form.get('date')
        if date_str:
            expense.paid_date = datetime.strptime(date_str, '%Y-%m-%d').date()
            
        vid = request.form.get('vendor_id')
        expense.vendor_id = vid if vid else None
        expense.description = request.form.get('description')

        # Keep ledger in sync (best-effort; legacy rows may not have reference_table)
        try:
            tq = Transaction.query.filter_by(transaction_type='expense', reference_id=expense.id)
            if _transaction_supports_metadata():
                tq = tq.filter((Transaction.reference_table.is_(None)) | (Transaction.reference_table == 'expenses'))
            tx = tq.order_by(Transaction.created_at.desc()).first()
            if tx:
                tx.amount = float(expense.amount or 0)
                tx.notes = f"Expense: {expense.expense_type}" if expense.expense_type else (tx.notes or 'Expense')
                _maybe_set_transaction_meta(
                    tx,
                    department='admin',
                    category=(expense.expense_type or 'expense'),
                    status='posted',
                )
                db.session.add(tx)
        except Exception:
            pass

        db.session.commit()
        flash('Expense updated successfully', 'success')
        return redirect(url_for('expenses'))
        
    vendors = Vendor.query.filter_by(is_active=True).all()
    return render_template('admin/create_edit_expense.html', expense=expense, vendors=vendors)

@app.route('/admin/expenses/<int:expense_id>/delete', methods=['POST'])
@login_required
def delete_expense(expense_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    expense = _db_get_or_404(Expense, expense_id)
    try:
        # Delete associated ledger entries to prevent orphan Transactions.
        tq = Transaction.query.filter_by(transaction_type='expense', reference_id=expense.id)
        if _transaction_supports_metadata():
            tq = tq.filter((Transaction.reference_table.is_(None)) | (Transaction.reference_table == 'expenses'))
        tq.delete(synchronize_session=False)
    except Exception:
        pass

    db.session.delete(expense)
    db.session.commit()
    flash('Expense deleted', 'success')
    return redirect(url_for('expenses'))

@app.route('/admin/debtors')
@login_required
def debtors_list():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
    
    debtors = Debtor.query.order_by(Debtor.amount_owed.desc()).all()
    return render_template('admin/debtors_list.html', debtors=debtors)

@app.route('/admin/debtors/create', methods=['GET', 'POST'])
@app.route('/admin/add_debtor', methods=['GET', 'POST'])
@login_required
def add_debtor():
    if current_user.role != 'admin':
        # Detect AJAX request
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    if request.method == 'POST':
        try:
            name = (request.form.get('name') or '').strip()
            contact = (request.form.get('contact') or '').strip()
            email = (request.form.get('email') or '').strip() or None
            
            # Handle both 'amount_owed' and 'total_debt' field names
            total_debt_raw = request.form.get('total_debt') or request.form.get('amount_owed') or request.form.get('Total_debt')
            if not name or not total_debt_raw:
                error_msg = 'Name and total debt are required'
                if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                    return jsonify({'success': False, 'error': error_msg}), 400
                flash(error_msg, 'danger')
                return render_template('admin/add_edit_debtor.html', debtor=None)
            
            total_debt = float(total_debt_raw)
            notes = (request.form.get('notes') or '').strip() or None
            
            # Parse dates
            last_payment_date = None
            next_payment_date = None
            if request.form.get('last_payment_date'):
                try:
                    last_payment_date = datetime.strptime(request.form.get('last_payment_date'), '%Y-%m-%d').date()
                except:
                    pass
            if request.form.get('next_payment_date'):
                try:
                    next_payment_date = datetime.strptime(request.form.get('next_payment_date'), '%Y-%m-%d').date()
                except:
                    pass
            
            debtor = Debtor(
                name=name,
                contact=contact,
                email=email,
                Total_debt=total_debt,
                amount_paid=0.0,
                amount_owed=total_debt,  # Initially, amount owed equals total debt
                last_payment_date=last_payment_date,
                next_payment_date=next_payment_date,
                notes=notes
            )
            db.session.add(debtor)
            db.session.commit()
            
            # Return JSON for AJAX requests
            if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                return jsonify({'success': True, 'message': 'Debtor created successfully'})
            
            flash('Debtor created successfully', 'success')
            return redirect(url_for('debtors_list'))
        except Exception as e:
            db.session.rollback()
            error_msg = f'Failed to create debtor: {str(e)}'
            if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                return jsonify({'success': False, 'error': error_msg}), 500
            flash(error_msg, 'danger')
            return render_template('admin/add_edit_debtor.html', debtor=None)
        
    return render_template('admin/add_edit_debtor.html', debtor=None)

@app.route('/admin/debtors/<int:debtor_id>')
@login_required
def view_debtor(debtor_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    debtor = _db_get_or_404(Debtor, debtor_id)
    payments = DebtorPayment.query.filter_by(debtor_id=debtor.id).order_by(DebtorPayment.payment_date.desc()).all()
    return render_template('admin/view_debtor.html', debtor=debtor, payments=payments)


@app.route('/admin/debtors/<int:debtor_id>/payment', methods=['POST'])
@login_required
def make_debtor_payment(debtor_id):
    """Compatibility endpoint for templates posting debtor payments.

    The AJAX/UI in `money.html` posts to `/admin/add_debtor_payment/<id>` which returns JSON.
    The standalone debtor view posts a normal form via `url_for('make_debtor_payment')`.
    """
    result = add_debtor_payment(debtor_id)

    if isinstance(result, tuple):
        response, status_code = result
    else:
        response, status_code = result, getattr(result, 'status_code', 200)

    payload = None
    try:
        payload = response.get_json(silent=True)
    except Exception:
        payload = None

    if int(status_code) >= 400:
        flash((payload or {}).get('error', 'Payment could not be recorded.'), 'danger')
    else:
        flash((payload or {}).get('message', 'Payment recorded successfully.'), 'success')

    return redirect(url_for('view_debtor', debtor_id=debtor_id))

@app.route('/admin/debtors/<int:debtor_id>/edit', methods=['GET', 'POST'])
@app.route('/admin/edit_debtor/<int:debtor_id>', methods=['GET', 'POST'])
@app.route('/admin/update_debtor/<int:debtor_id>', methods=['POST'])
@login_required
def edit_debtor(debtor_id):
    if current_user.role != 'admin':
        # Detect AJAX request
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    debtor = _db_get_or_404(Debtor, debtor_id)
    
    if request.method == 'POST':
        try:
            debtor.name = (request.form.get('name') or '').strip()
            debtor.contact = (request.form.get('contact') or '').strip()
            debtor.email = (request.form.get('email') or '').strip() or None
            debtor.notes = request.form.get('notes')
            
            # Handle both 'amount_owed' and 'total_debt' field names
            total_debt_field = request.form.get('total_debt') or request.form.get('Total_debt')
            if total_debt_field:
                debtor.Total_debt = float(total_debt_field)
                # Recalculate amount owed
                debtor.amount_owed = debtor.Total_debt - (debtor.amount_paid or 0.0)
            
            # Parse dates
            if request.form.get('last_payment_date'):
                try:
                    debtor.last_payment_date = datetime.strptime(request.form.get('last_payment_date'), '%Y-%m-%d').date()
                except:
                    pass
            if request.form.get('next_payment_date'):
                try:
                    debtor.next_payment_date = datetime.strptime(request.form.get('next_payment_date'), '%Y-%m-%d').date()
                except:
                    pass

            db.session.commit()
            
            # Return JSON for AJAX requests
            if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                return jsonify({'success': True, 'message': 'Debtor details updated'})
            
            flash('Debtor details updated', 'success')
            return redirect(url_for('debtors_list'))
        except Exception as e:
            db.session.rollback()
            error_msg = f'Failed to update debtor: {str(e)}'
            if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                return jsonify({'success': False, 'error': error_msg}), 500
            flash(error_msg, 'danger')
        
    return render_template('admin/add_edit_debtor.html', debtor=debtor)

@app.route('/admin/debtors/<int:debtor_id>/delete', methods=['POST'])
@app.route('/admin/delete_debtor/<int:debtor_id>', methods=['POST'])
@login_required
def delete_debtor(debtor_id):
    if current_user.role != 'admin':
        # Detect AJAX request
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        flash('Unauthorized access', 'danger')
        return redirect(url_for('dashboard'))
        
    debtor = _db_get_or_404(Debtor, debtor_id)
    try:
        debtor_name = debtor.name
        db.session.delete(debtor)
        db.session.commit()
        
        # Return JSON for AJAX requests
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': True, 'message': f'Debtor {debtor_name} deleted successfully'})
        
        flash('Debtor record deleted', 'success')
        return redirect(url_for('debtors_list'))
    except Exception as e:
        db.session.rollback()
        error_msg = f'Failed to delete debtor: {str(e)}'
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': error_msg}), 500
        flash(error_msg, 'danger')
        return redirect(url_for('debtors_list'))


@app.route('/admin/insurance/provider/add', methods=['POST'])
@login_required
def admin_add_insurance_provider():
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        name = (request.form.get('name') or '').strip()
        if not name:
            return jsonify({'success': False, 'error': 'Provider name is required.'}), 400

        existing = InsuranceProvider.query.filter(func.lower(InsuranceProvider.name) == func.lower(name)).first()
        if existing:
            return jsonify({'success': False, 'error': 'Provider already exists.'}), 400

        provider = InsuranceProvider(
            name=name,
            phone=(request.form.get('phone') or '').strip() or None,
            email=(request.form.get('email') or '').strip() or None,
            address=(request.form.get('address') or '').strip() or None,
            created_at=get_eat_now(),
        )
        db.session.add(provider)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance provider added.'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to add provider: {str(e)}'}), 400


@app.route('/admin/insurance/policy/add', methods=['POST'])
@login_required
def admin_add_insurance_policy():
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        patient_id = request.form.get('patient_id', type=int)
        provider_id = request.form.get('provider_id', type=int)
        if not patient_id or not provider_id:
            return jsonify({'success': False, 'error': 'Patient ID and Provider are required.'}), 400

        patient = db.session.get(Patient, patient_id)
        provider = db.session.get(InsuranceProvider, provider_id)
        if not patient:
            return jsonify({'success': False, 'error': 'Patient not found.'}), 400
        if not provider:
            return jsonify({'success': False, 'error': 'Provider not found.'}), 400

        policy = InsurancePolicy(
            patient_id=patient.id,
            provider_id=provider.id,
            policy_number=(request.form.get('policy_number') or '').strip() or None,
            member_number=(request.form.get('member_number') or '').strip() or None,
            active=(request.form.get('active') or '1') == '1',
            notes=(request.form.get('notes') or '').strip() or None,
            created_at=get_eat_now(),
        )
        db.session.add(policy)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance policy added.'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to add policy: {str(e)}'}), 400


@app.route('/admin/insurance/claim/add', methods=['POST'])
@login_required
def admin_add_insurance_claim():
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    # Best-effort compatibility for SQLite instances that didn't run migrations
    _ensure_insurance_claims_schema_best_effort()

    try:
        sale_id = request.form.get('sale_id', type=int)
        sale_number = (request.form.get('sale_number') or '').strip()

        sale = None
        if sale_id:
            sale = db.session.get(Sale, sale_id)
        elif sale_number:
            sale = Sale.query.filter(Sale.sale_number == sale_number).order_by(Sale.id.desc()).first()

        if not sale:
            return jsonify({'success': False, 'error': 'Sale not found (use Sale ID or Sale Number).'}), 400

        if not sale.patient_id:
            return jsonify({'success': False, 'error': 'Insurance claims require a patient sale (walk-in sale cannot be claimed).'}), 400

        policy_id = request.form.get('policy_id', type=int)
        provider_id = request.form.get('provider_id', type=int)

        policy = None
        provider = None
        if policy_id:
            policy = db.session.get(InsurancePolicy, policy_id)
            if not policy:
                return jsonify({'success': False, 'error': 'Policy not found.'}), 400
            provider = db.session.get(InsuranceProvider, policy.provider_id)
        else:
            if not provider_id:
                return jsonify({'success': False, 'error': 'Select a provider or policy.'}), 400
            provider = db.session.get(InsuranceProvider, provider_id)

        if not provider:
            return jsonify({'success': False, 'error': 'Provider not found.'}), 400

        claimed_amount = float(sale.total_amount or 0)
        submit_now = (request.form.get('submit_now') or '1') == '1'
        claim = InsuranceClaim(
            claim_number=generate_insurance_claim_number(),
            sale_id=sale.id,
            patient_id=int(sale.patient_id),
            provider_id=provider.id,
            policy_id=(policy.id if policy else None),
            status='submitted' if submit_now else 'draft',
            claimed_amount=claimed_amount,
            created_by=current_user.id,
            notes=(request.form.get('notes') or '').strip() or None,
            created_at=get_eat_now(),
            submitted_at=(get_eat_now() if submit_now else None),
        )
        db.session.add(claim)

        # Itemize claim from the sale items (best-effort; only if table exists)
        try:
            db.session.flush()  # ensure claim.id
            if _insurance_claim_items_table_exists():
                total_from_items = 0.0
                for si in (sale.items or []):
                    if not getattr(si, 'id', None):
                        continue

                    item_type = 'other'
                    if getattr(si, 'drug_id', None):
                        item_type = 'drug'
                    elif getattr(si, 'service_id', None):
                        item_type = 'service'
                    elif getattr(si, 'lab_test_id', None):
                        item_type = 'lab_test'
                    elif getattr(si, 'imaging_test_id', None):
                        item_type = 'imaging_test'

                    desc = (getattr(si, 'description', None) or getattr(si, 'drug_name', None) or '').strip() or None
                    qty = int(getattr(si, 'quantity', 1) or 1)
                    unit_price = float(getattr(si, 'unit_price', 0) or 0)
                    line_total = float(getattr(si, 'total_price', qty * unit_price) or 0)
                    total_from_items += line_total

                    db.session.add(InsuranceClaimItem(
                        claim_id=claim.id,
                        sale_item_id=si.id,
                        item_type=item_type,
                        description=desc,
                        quantity=qty,
                        unit_price=unit_price,
                        total_price=line_total,
                        created_at=get_eat_now(),
                    ))

                # Keep claim totals consistent with itemization when available
                if total_from_items > 0:
                    claim.claimed_amount = float(total_from_items)
        except Exception as item_exc:
            try:
                current_app.logger.debug(f"Claim itemization skipped/failed: {item_exc}")
            except Exception:
                pass

        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance claim created.', 'claim_id': claim.id, 'claim_number': claim.claim_number})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to create claim: {str(e)}'}), 400


@app.route('/admin/insurance/claim/<int:claim_id>/payment', methods=['POST'])
@login_required
def admin_record_insurance_claim_payment(claim_id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    claim = db.session.get(InsuranceClaim, claim_id)
    if not claim:
        return jsonify({'success': False, 'error': 'Claim not found.'}), 404

    try:
        amount = float(request.form.get('amount') or 0)
        if amount <= 0:
            return jsonify({'success': False, 'error': 'Payment amount must be positive.'}), 400

        payment_method = (request.form.get('payment_method') or '').strip() or None
        notes = (request.form.get('notes') or '').strip() or None

        payment = InsuranceClaimPayment(
            claim_id=claim.id,
            amount=float(amount),
            payment_method=payment_method,
            received_by=current_user.id,
            notes=notes,
            paid_at=get_eat_now(),
            created_at=get_eat_now(),
        )
        db.session.add(payment)
        db.session.flush()

        # Update claim totals/status
        claim.paid_amount = float(claim.paid_amount or 0) + float(amount)
        if claim.paid_amount >= float(claim.claimed_amount or 0) - 0.005:
            claim.status = 'paid'
        elif (claim.status or '').lower() == 'draft':
            claim.status = 'submitted'

        provider_name = None
        try:
            provider_name = claim.provider.name if claim.provider else None
        except Exception:
            provider_name = None

        # Post into Transaction (golden rule)
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='income',
            amount=float(amount),
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Insurance claim payment {claim.claim_number}",
            created_at=get_eat_now(),
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='insurance_claim_payments',
            direction='IN',
            status='posted',
            department='admin',
            category='insurance',
            payer=provider_name,
            payment_method=payment_method,
        )
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Insurance Payment Receipt</h2>",
                f"<div><strong>Claim:</strong> {escape(str(claim.claim_number))}</div>",
                (f"<div><strong>Provider:</strong> {escape(str(provider_name))}</div>" if provider_name else ""),
                f"<div><strong>Amount:</strong> {escape(_money(amount))}</div>",
                f"<div><strong>Date:</strong> {escape(get_eat_now().strftime('%Y-%m-%d %H:%M'))}</div>",
                (f"<div><strong>Method:</strong> {escape(str(payment_method))}</div>" if payment_method else ""),
                (f"<div><strong>Notes:</strong> {escape(str(notes))}</div>" if notes else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='INS', force=True)
        except Exception:
            pass
        db.session.add(transaction)
        db.session.add(claim)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance payment recorded.', 'transaction_number': transaction.transaction_number})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to record payment: {str(e)}'}), 400

@app.route('/admin/delete_insurance-policy/<int:policy_id>', methods=['POST'])
@login_required
def delete_insurance_policy(policy_id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        policy = _db_get_or_404(InsurancePolicy, policy_id)
        db.session.delete(policy)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance policy deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to delete policy: {str(e)}'}), 500

@app.route('/admin/delete_insurance-claim/<int:claim_id>', methods=['POST'])
@login_required
def delete_insurance_claim(claim_id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        claim = _db_get_or_404(InsuranceClaim, claim_id)
        db.session.delete(claim)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance claim deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': f'Failed to delete claim: {str(e)}'}), 500

# ==============
# DRAWING ROUTES
# ==============

@app.route('/admin/add_drawing', methods=['POST'])
@login_required
def add_drawing():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        amount = float(request.form.get('amount'))
        description = request.form.get('description')

        # Budget enforcement (warn-only by default)
        try:
            budget_check = _budget_check_outflow('admin', float(amount or 0), when_dt=get_eat_now())
            if budget_check and budget_check.get('block'):
                return jsonify({'success': False, 'error': budget_check.get('message') or 'Budget exceeded for this month.'}), 400
        except Exception:
            pass
        
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='drawing',  # Changed from 'expense' to 'drawing'
            amount=amount,
            user_id=current_user.id,
            notes=f"Owner's drawing: {description}"
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='drawings',
            direction='OUT',
            status='posted',
            department='admin',
            category='drawing',
            payment_method=None,
        )
        db.session.add(transaction)
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Owner Drawing Receipt</h2>",
                f"<div><strong>Amount:</strong> {escape(_money(amount))}</div>",
                f"<div><strong>Date:</strong> {escape(get_eat_now().strftime('%Y-%m-%d %H:%M'))}</div>",
                (f"<div><strong>Description:</strong> {escape(str(description))}</div>" if description else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='DRW', force=True)
        except Exception:
            pass
        db.session.commit()
        return jsonify({'success': True, 'message': 'Drawing added successfully'})
    except ValueError:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Invalid data provided'}), 400
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500


@app.route('/admin/pay_payroll/<int:id>', methods=['POST'])
@login_required
def pay_payroll(id):
    if current_user.role not in ('admin', 'accountant'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    payroll = _db_get_or_404(Payroll, id)
    try:
        # Ensure DB schema for payroll_payments has expected columns (helps when migrations weren't run)
        try:
            with db.engine.connect() as conn:
                # For SQLite this returns rows with columns: cid, name, type, notnull, dflt_value, pk
                res = conn.execute(text("PRAGMA table_info('payroll_payments')"))
                cols = [r[1] for r in res.fetchall()]
                if 'paid_by' not in cols:
                    app.logger.info('Schema fix: adding missing column payroll_payments.paid_by')
                    conn.execute(text('ALTER TABLE payroll_payments ADD COLUMN paid_by INTEGER'))
        except Exception as schema_exc:
            # Log but continue; if table missing entirely the normal flow will error and be returned to client
            current_app.logger.debug(f"Schema check/alter failed: {schema_exc}")
        amount = float(request.form.get('amount', 0))
        notes = request.form.get('notes', '')
        # allow user to pass payment_date (YYYY-MM-DD)
        payment_date_str = request.form.get('payment_date')

        if amount <= 0:
            return jsonify({'success': False, 'error': 'Amount must be positive'}), 400

        # Calculate total already paid
        total_paid = sum([p.amount for p in payroll.payments]) if payroll.payments else 0.0
        remaining = payroll.amount - total_paid

        if amount > remaining + 0.0001:
            return jsonify({'success': False, 'error': f'Amount exceeds remaining balance (Ksh {remaining:.2f})'}), 400

        # Parse payment date if provided, otherwise use now
        if payment_date_str:
            try:
                pd = datetime.strptime(payment_date_str, '%Y-%m-%d')
                payment_dt = datetime(pd.year, pd.month, pd.day, tzinfo=EAT)
            except Exception:
                payment_dt = get_eat_now()
        else:
            payment_dt = get_eat_now()

        payment = PayrollPayment(
            payroll_id=payroll.id,
            amount=amount,
            paid_by=current_user.id,
            payment_date=payment_dt,
            notes=notes
        )
        db.session.add(payment)
        db.session.flush()

        # Create transaction record for the payroll payment (treat as expense)
        payment_method = (request.form.get('payment_method') or '').strip() or None
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=amount,
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Payroll payment for {payroll.payroll_number}: {notes}"
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='payroll_payments',
            direction='OUT',
            status='posted',
            department='admin',
            category='payroll',
            payment_method=payment_method,
        )
        db.session.add(transaction)

        # Generate a simple receipt for email/audit
        try:
            employee = _db_get(Employee, payroll.employee_id) if getattr(payroll, 'employee_id', None) else None
            employee_name = getattr(employee, 'name', None) if employee else None
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Payroll Payment Receipt</h2>",
                f"<div><strong>Payroll:</strong> {escape(str(payroll.payroll_number))}</div>",
                (f"<div><strong>Employee:</strong> {escape(str(employee_name))}</div>" if employee_name else ""),
                f"<div><strong>Amount:</strong> {escape(_money(amount))}</div>",
                f"<div><strong>Date:</strong> {escape(payment_dt.strftime('%Y-%m-%d %H:%M'))}</div>",
                (f"<div><strong>Notes:</strong> {escape(str(notes))}</div>" if notes else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='PAY')
        except Exception:
            pass

        # Update payroll status if fully paid
        total_paid += amount
        if abs(total_paid - payroll.amount) < 0.005 or total_paid >= payroll.amount:
            payroll.status = 'paid'
        else:
            payroll.status = 'partial'

        db.session.commit()

        # Email receipt to payee (best-effort)
        try:
            employee = _db_get(Employee, payroll.employee_id) if getattr(payroll, 'employee_id', None) else None
            payee_email = None
            if employee and getattr(employee, 'user', None) and getattr(employee.user, 'email', None):
                payee_email = str(employee.user.email)
            if (not payee_email) and employee and getattr(employee, 'contact', None):
                c = str(employee.contact or '').strip()
                if '@' in c:
                    payee_email = c
            if payee_email and _is_valid_email_address(payee_email):
                subject = f"Payment Receipt - Payroll {payroll.payroll_number}"
                html = (transaction.receipt_html or '')
                if not html:
                    html = f"<p>Payroll payment received: {escape(_money(amount))}</p>"
                _send_email_best_effort_async(recipient=payee_email, subject=subject, html=html, text_body=None)
        except Exception:
            pass

        return jsonify({'success': True, 'message': 'Payment recorded successfully', 'remaining': round(payroll.amount - total_paid, 2)})
    except ValueError:
        db.session.rollback()
        current_app.logger.exception(f"ValueError processing payroll payment {id}")
        return jsonify({'success': False, 'error': 'Invalid amount provided'}), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.exception(f"Error processing payroll payment {id}: {str(e)}")
        return jsonify({'success': False, 'error': 'An unexpected error occurred while processing payment'}), 500
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 400

@app.route('/admin/update_drawing/<int:id>', methods=['POST'])
@login_required
def update_drawing(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    drawing = _db_get_or_404(Transaction, id)
    try:
        drawing.amount = float(request.form.get('amount'))
        description = request.form.get('description')
        drawing.notes = f"Owner's drawing: {description}" if description is not None else drawing.notes
        db.session.commit()
        return jsonify({'success': True, 'message': 'Drawing updated successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

@app.route('/admin/delete_drawing/<int:id>', methods=['POST'])
@login_required
def delete_drawing(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    drawing = _db_get_or_404(Transaction, id)
    try:
        db.session.delete(drawing)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Drawing deleted successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

# =============
# BILLS ROUTES
# =============

@app.route('/admin/add_bill', methods=['POST'])
@login_required
def add_bill():
    try:
        # Extract form data - handle both 'bill_type' and 'expense_type' for compatibility
        expense_type = request.form.get('bill_type') or request.form.get('expense_type')
        amount = float(request.form.get('amount', 0))
        due_date = request.form.get('due_date')
        description = request.form.get('description')
        payment_method = request.form.get('payment_method', 'cash')
        status = request.form.get('status', 'pending')
        paid_date = request.form.get('paid_date')
        user_id = current_user.id

        # Parse due_date and paid_date if provided
        due_date_obj = datetime.strptime(due_date, '%Y-%m-%d').date() if due_date else None
        paid_date_obj = datetime.strptime(paid_date, '%Y-%m-%d').date() if paid_date else None

        # Generate expense number
        expense_number = generate_expense_number()

        expense = Expense(
            expense_number=expense_number,
            expense_type=expense_type,
            amount=amount,
            user_id=user_id,
            description=description,
            due_date=due_date_obj,
            payment_method=payment_method,
            status=status,
            paid_date=paid_date_obj
        )

        db.session.add(expense)
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='add_expense',
            table_name='expenses',
            record_id=expense.id,
            description=f"Added new expense {expense.expense_number} of type {expense.expense_type}",
            new_values={
                'expense_id': expense.id,
                'amount': expense.amount,
                'expense_type': expense.expense_type,
                'due_date': expense.due_date.isoformat() if expense.due_date else None
            }
        )

        return jsonify({'success': True, 'message': 'Bill added successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/update_bill/<int:id>', methods=['POST'])
@login_required
def update_bill(id):
    try:
        bill = _db_get_or_404(Expense, id)

        old_values = {
            'expense_type': bill.expense_type,
            'amount': float(bill.amount),
            'description': bill.description,
            'due_date': bill.due_date.isoformat() if bill.due_date else None
        }

        bill.expense_type = request.form.get('bill_type')
        bill.amount = float(request.form.get('amount'))
        bill.description = request.form.get('description')
        bill.due_date = datetime.strptime(request.form.get('due_date'), '%Y-%m-%d').date()
        
        new_values = {
            'expense_type': bill.expense_type,
            'amount': bill.amount,
            'description': bill.description,
            'due_date': bill.due_date.isoformat() if bill.due_date else None
        }
        
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='update_expense',
            table_name='expenses',
            record_id=bill.id,
            description=f"Updated expense {bill.expense_number}",
            old_values=old_values,
            new_values=new_values
        )

        return jsonify({'success': True, 'message': 'Bill updated successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/admin/delete_bill/<int:id>', methods=['POST'])
@login_required
def delete_bill(id):
    bill = _db_get_or_404(Expense, id)
    try:
        old_values = {
            'expense_id': bill.id,
            'expense_number': bill.expense_number,
            'expense_type': bill.expense_type,
            'amount': float(bill.amount),
            'description': bill.description,
            'due_date': bill.due_date.isoformat() if bill.due_date else None
        }
        db.session.delete(bill)
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='delete_expense',
            table_name='expenses',
            record_id=id,
            description=f"Deleted expense {old_values['expense_number']}",
            old_values=old_values
        )

        return jsonify({'success': True, 'message': 'Bill deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/admin/pay_bill/<int:id>', methods=['POST'])
@login_required
def pay_bill(id):
    bill = _db_get_or_404(Expense, id)
    if bill.status == 'paid':
        return jsonify({'success': False, 'error': 'Bill already paid'}), 400

    payment_method = request.form.get('payment_method', 'cash')
    try:
        bill.status = 'paid'
        bill.paid_date = date.today()
        db.session.commit()

        # Create transaction record
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=bill.amount,
            user_id=current_user.id,
            reference_id=bill.id,
            reference_table='expenses',
            direction='OUT',
            status='posted',
            department=None,
            category=bill.expense_type,
            payment_method=payment_method,
        )
        db.session.add(transaction)
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='pay_expense',
            table_name='expenses',
            record_id=bill.id,
            description=f"Paid expense {bill.expense_number}",
            new_values={
                'expense_id': bill.id,
                'status': 'paid',
                'paid_date': bill.paid_date.isoformat() if bill.paid_date else None,
                'payment_method': payment_method
            }
        )

        return jsonify({'success': True, 'message': 'Bill paid successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/admin/pay_bill_v2/<int:id>', methods=['POST'])
@login_required
def pay_bill_v2(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    bill = _db_get_or_404(Expense, id)
    try:
        bill.status = 'paid'
        bill.paid_date = get_eat_now().date()

        payment_method = request.form.get('payment_method')
        
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=bill.amount,
            user_id=current_user.id,
            reference_id=bill.id,
            notes=f"Bill payment: {bill.expense_type}"
        )
        db.session.add(transaction)
        _maybe_set_transaction_meta(
            transaction,
            reference_table='expenses',
            direction='OUT',
            status='posted',
            department='admin',
            category='bill',
            payment_method=payment_method,
        )
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Bill Payment Receipt</h2>",
                f"<div><strong>Bill:</strong> {escape(str(bill.expense_number))}</div>",
                f"<div><strong>Type:</strong> {escape(str(bill.expense_type))}</div>",
                f"<div><strong>Amount:</strong> {escape(_money(float(bill.amount or 0)))}</div>",
                f"<div><strong>Date:</strong> {escape(get_eat_now().strftime('%Y-%m-%d %H:%M'))}</div>",
                (f"<div><strong>Payment Method:</strong> {escape(str(payment_method))}</div>" if payment_method else ""),
                (f"<div><strong>Description:</strong> {escape(str(bill.description))}</div>" if bill.description else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='BILL', force=True)
        except Exception:
            pass
        db.session.commit()
        return jsonify({'success': True, 'message': 'Bill paid successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

# ================
# PURCHASE ROUTES
# ================

@app.route('/admin/add_purchase', methods=['POST'])
@login_required
def add_purchase():
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        # Budget enforcement (warn-only by default)
        try:
            purchase_amount = float(request.form.get('amount') or 0)
            purchase_date_d = datetime.strptime(request.form.get('purchase_date'), '%Y-%m-%d').date()
            try:
                purchase_dt = datetime(purchase_date_d.year, purchase_date_d.month, purchase_date_d.day, tzinfo=EAT)
            except Exception:
                purchase_dt = datetime.combine(purchase_date_d, datetime.min.time())
            budget_check = _budget_check_outflow('admin', purchase_amount, when_dt=purchase_dt)
            if budget_check and budget_check.get('block'):
                return jsonify({'success': False, 'error': budget_check.get('message') or 'Budget exceeded for this month.'}), 400
        except Exception:
            pass

        purchase = Purchase(
            purchase_number=generate_purchase_number(),
            purchase_type=request.form.get('purchase_type'),
            amount=float(request.form.get('amount')),
            purchase_date=datetime.strptime(request.form.get('purchase_date'), '%Y-%m-%d').date(),
            supplier=request.form.get('supplier'),
            description=request.form.get('description'),
            user_id=current_user.id
        )
        db.session.add(purchase)
        db.session.flush()
        
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='purchase',
            amount=purchase.amount,
            user_id=current_user.id,
            reference_id=purchase.id,
            notes=f"Purchase: {purchase.purchase_type}"
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='purchases',
            direction='OUT',
            status='posted',
            department='admin',
            category='purchase',
            payment_method=None,
        )
        db.session.add(transaction)
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Purchase Receipt</h2>",
                f"<div><strong>Purchase:</strong> {escape(str(purchase.purchase_number))}</div>",
                f"<div><strong>Type:</strong> {escape(str(purchase.purchase_type))}</div>",
                f"<div><strong>Amount:</strong> {escape(_money(float(purchase.amount or 0)))}</div>",
                f"<div><strong>Date:</strong> {escape(str(purchase.purchase_date))}</div>",
                (f"<div><strong>Supplier:</strong> {escape(str(purchase.supplier))}</div>" if purchase.supplier else ""),
                (f"<div><strong>Description:</strong> {escape(str(purchase.description))}</div>" if purchase.description else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='PUR', force=True)
        except Exception:
            pass
        db.session.commit()
        return jsonify({'success': True, 'message': 'Purchase added successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

@app.route('/admin/update_purchase/<int:id>', methods=['POST'])
@login_required
def update_purchase(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    purchase = _db_get_or_404(Purchase, id)
    try:
        purchase.purchase_type = request.form.get('purchase_type')
        purchase.amount = float(request.form.get('amount'))
        purchase.purchase_date = datetime.strptime(request.form.get('purchase_date'), '%Y-%m-%d').date()
        purchase.supplier = request.form.get('supplier')
        purchase.description = request.form.get('description')

        # Keep ledger in sync
        try:
            tq = Transaction.query.filter_by(transaction_type='purchase', reference_id=purchase.id)
            if _transaction_supports_metadata():
                tq = tq.filter((Transaction.reference_table.is_(None)) | (Transaction.reference_table == 'purchases'))
            tx = tq.order_by(Transaction.created_at.desc()).first()
            if tx:
                tx.amount = float(purchase.amount or 0)
                tx.notes = f"Purchase: {purchase.purchase_type}" if purchase.purchase_type else (tx.notes or 'Purchase')
                _maybe_set_transaction_meta(
                    tx,
                    reference_table='purchases',
                    direction='OUT',
                    status='posted',
                    department='admin',
                    category='purchase',
                )
                db.session.add(tx)
        except Exception:
            pass

        db.session.commit()
        return jsonify({'success': True, 'message': 'Purchase updated successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

@app.route('/admin/delete_purchase/<int:id>', methods=['POST'])
@login_required
def delete_purchase(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    purchase = _db_get_or_404(Purchase, id)
    try:
        # Delete associated transaction first
        q = Transaction.query.filter_by(transaction_type='purchase', reference_id=id)
        if _transaction_supports_metadata():
            q = q.filter((Transaction.reference_table.is_(None)) | (Transaction.reference_table == 'purchases'))
        q.delete(synchronize_session=False)
        db.session.delete(purchase)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Purchase deleted successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500
# ===============
# PAYROLL ROUTES (Updated)
# ===============

@app.route('/admin/add_payroll', methods=['POST'])
@login_required
def add_payroll():
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        # Validate required fields (backward compatible with older form names)
        employee_id = (request.form.get('employee_id') or '').strip()
        payment_date_raw = (request.form.get('payment_date') or '').strip()
        amount_raw = request.form.get('amount')
        salary_raw = request.form.get('salary')
        amount_paid_raw = request.form.get('amount_paid')

        if not employee_id or not payment_date_raw:
            return jsonify({'success': False, 'error': 'Please fill all required fields'}), 400

        # Newer UI posts `salary` + `amount_paid`; older UI posted `amount`.
        total_amount_raw = salary_raw if (salary_raw is not None and str(salary_raw).strip() != '') else amount_raw
        if total_amount_raw is None or str(total_amount_raw).strip() == '':
            return jsonify({'success': False, 'error': 'Please provide salary/amount'}), 400

        employee = db.session.get(Employee, employee_id)
        if not employee:
            return jsonify({'success': False, 'error': 'Employee not found'}), 404

        amount = float(total_amount_raw)
        if amount <= 0:
            return jsonify({'success': False, 'error': 'Salary/amount must be positive'}), 400

        # Amount paid is optional; allow creating a payroll entry without payment.
        amount_paid = 0.0
        if amount_paid_raw is not None and str(amount_paid_raw).strip() != '':
            amount_paid = float(amount_paid_raw)
        if amount_paid < 0:
            return jsonify({'success': False, 'error': 'Amount paid cannot be negative'}), 400
        if amount_paid > amount + 0.0001:
            return jsonify({'success': False, 'error': 'Amount paid cannot exceed salary/amount'}), 400

        payment_date = datetime.strptime(payment_date_raw, '%Y-%m-%d').date()

        if amount_paid <= 0:
            status = 'pending'
        elif abs(amount_paid - amount) < 0.005 or amount_paid >= amount:
            status = 'paid'
        else:
            status = 'partial'
        
        payroll = Payroll(
            payroll_number=generate_payroll_number(),
            employee_id=employee.id,
            amount=amount,
            payment_date=payment_date,
            pay_period=request.form.get('pay_period', 'monthly'),
            notes=request.form.get('notes', ''),
            status=status,
            user_id=current_user.id
        )
        db.session.add(payroll)
        db.session.flush()

        transaction = None
        payment = None
        if amount_paid > 0:
            # Record an initial payment (mirrors /admin/pay_payroll behavior)
            payment_method = (request.form.get('payment_method') or '').strip() or None
            payment_dt = get_eat_now()
            try:
                # Use provided date for payment timestamp when available
                payment_dt = datetime(payment_date.year, payment_date.month, payment_date.day, tzinfo=EAT)
            except Exception:
                payment_dt = get_eat_now()

            payment = PayrollPayment(
                payroll_id=payroll.id,
                amount=amount_paid,
                paid_by=current_user.id,
                payment_date=payment_dt,
                notes=payroll.notes or ''
            )
            db.session.add(payment)
            db.session.flush()

            # Create transaction record (as expense) for the paid portion only
            transaction = Transaction(
                transaction_number=generate_transaction_number(),
                transaction_type='expense',
                amount=amount_paid,
                user_id=current_user.id,
                reference_id=payment.id,
                notes=f"Payroll payment for {payroll.payroll_number}: {employee.name}",
                created_at=get_eat_now()
            )
            _maybe_set_transaction_meta(
                transaction,
                reference_table='payroll_payments',
                direction='OUT',
                status='posted',
                department='admin',
                category='payroll',
                payment_method=payment_method,
            )
            db.session.add(transaction)

            # Store receipt for audit + email
            try:
                receipt_html = "".join([
                    "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                    "<h2 style='margin:0 0 8px 0;'>Payroll Payment Receipt</h2>",
                    f"<div><strong>Payroll:</strong> {escape(str(payroll.payroll_number))}</div>",
                    f"<div><strong>Employee:</strong> {escape(str(employee.name))}</div>",
                    f"<div><strong>Amount Paid:</strong> {escape(_money(amount_paid))}</div>",
                    f"<div><strong>Total Salary/Amount:</strong> {escape(_money(amount))}</div>",
                    f"<div><strong>Date:</strong> {escape(payment_dt.strftime('%Y-%m-%d %H:%M'))}</div>",
                    (f"<div><strong>Notes:</strong> {escape(str(payroll.notes))}</div>" if payroll.notes else ""),
                    "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                    "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                    "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                    f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                    f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                    "</div>",
                    "</div>",
                ])
                _ensure_transaction_receipt(transaction, receipt_html, prefix='PAY')
            except Exception:
                pass
        
        db.session.commit()

        # Email receipt to payee (best-effort)
        try:
            if not transaction:
                raise Exception('No payment transaction created; skipping receipt email')
            payee_email = None
            if getattr(employee, 'user', None) and getattr(employee.user, 'email', None):
                payee_email = str(employee.user.email)
            if (not payee_email) and getattr(employee, 'contact', None):
                c = str(employee.contact or '').strip()
                if '@' in c:
                    payee_email = c
            if payee_email and _is_valid_email_address(payee_email):
                subject = f"Payment Receipt - Payroll {payroll.payroll_number}"
                html = (transaction.receipt_html or '')
                if not html:
                    html = f"<p>Payroll payment recorded: {escape(_money(amount_paid))}</p>"
                _send_email_best_effort_async(recipient=payee_email, subject=subject, html=html, text_body=None)
        except Exception:
            pass

        remaining = max(0.0, amount - amount_paid)
        return jsonify({
            'success': True,
            'message': 'Payroll added successfully',
            'payroll_id': payroll.id,
            'status': payroll.status,
            'remaining': round(remaining, 2),
        })
    except ValueError:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Invalid data format'}), 400
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

@app.route('/admin/update_payroll/<int:id>', methods=['POST'])
@login_required
def update_payroll(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    payroll = _db_get_or_404(Payroll, id)
    try:
        employee_id = (request.form.get('employee_id') or '').strip()
        payment_date_raw = (request.form.get('payment_date') or '').strip()
        amount_raw = request.form.get('amount')
        salary_raw = request.form.get('salary')
        total_amount_raw = salary_raw if (salary_raw is not None and str(salary_raw).strip() != '') else amount_raw
        if not employee_id or not payment_date_raw or total_amount_raw is None or str(total_amount_raw).strip() == '':
            return jsonify({'success': False, 'error': 'Please fill all required fields'}), 400

        employee = _db_get(Employee, employee_id)
        if not employee:
            return jsonify({'success': False, 'error': 'Employee not found'}), 404

        amount = float(total_amount_raw)
        if amount <= 0:
            return jsonify({'success': False, 'error': 'Amount must be positive'}), 400

        # Update payroll
        payroll.employee_id = employee.id
        payroll.amount = amount
        payroll.payment_date = datetime.strptime(payment_date_raw, '%Y-%m-%d').date()
        payroll.pay_period = request.form.get('pay_period', payroll.pay_period)
        payroll.notes = request.form.get('notes', payroll.notes)

        # Backward compatibility: older payrolls may have a direct 'payrolls' expense transaction.
        # Newer payroll flow uses PayrollPayment transactions; do not attempt to rewrite historical payments here.
        if not payroll.payments:
            transaction_query = Transaction.query.filter_by(transaction_type='expense', reference_id=id)
            if _transaction_supports_metadata():
                transaction_query = transaction_query.filter((Transaction.reference_table.is_(None)) | (Transaction.reference_table == 'payrolls'))
            transaction = transaction_query.order_by(Transaction.created_at.desc()).first()
            if transaction and (payroll.status == 'paid'):
                transaction.amount = amount
                transaction.notes = f"Payroll payment for {employee.name}"
                transaction.created_at = get_eat_now()
        
        db.session.commit()
        return jsonify({'success': True, 'message': 'Payroll updated successfully'})
    except ValueError:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Invalid data format'}), 400
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

# Add a new route to get employee salary
@app.route('/admin/get_employee_salary/<int:employee_id>')
@login_required
def get_employee_salary(employee_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    employee = _db_get_or_404(Employee, employee_id)
    return jsonify({'salary': employee.salary})

# ================
# DEBTOR ROUTES
# ================
# Legacy add_debtor removed

# Legacy add_debtor (duplicate) removed

# Third legacy snippet removed


@app.route('/admin/add_debtor_payment/<int:debtor_id>', methods=['POST'])
@login_required
def add_debtor_payment(debtor_id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    debtor = _db_get_or_404(Debtor, debtor_id)
    try:
        if not all([request.form.get('amount'), request.form.get('payment_date')]):
            return jsonify({'success': False, 'error': 'Amount and payment date are required'}), 400

        payment_amount = float(request.form.get('amount'))
        if payment_amount <= 0:
            return jsonify({'success': False, 'error': 'Payment amount must be positive'}), 400

        if payment_amount > debtor.amount_owed:
            return jsonify({'success': False, 'error': 'Payment amount exceeds owed amount'}), 400

        payment_date = datetime.strptime(request.form.get('payment_date'), '%Y-%m-%d').date()
        
        # Update debtor records
        debtor.amount_paid += payment_amount
        debtor.amount_owed = debtor.Total_debt - debtor.amount_paid
        debtor.last_payment_date = payment_date
        
        # Create payment record
        payment = DebtorPayment(
            debtor_id=debtor_id,
            amount=payment_amount,
            payment_date=payment_date,
            payment_method=request.form.get('payment_method', 'cash'),
            notes=request.form.get('notes', ''),
            user_id=current_user.id
        )
        db.session.add(payment)
        db.session.flush()
        
        # Create transaction record
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='income',
            amount=payment_amount,
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Payment from {debtor.name}",
            created_at=get_eat_now()
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='debtor_payments',
            direction='IN',
            status='posted',
            department='admin',
            category='debtor_payment',
            payment_method=getattr(payment, 'payment_method', None),
            payer=getattr(debtor, 'name', None),
        )
        db.session.add(transaction)

        # Store receipt for audit + email
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Debtor Payment Receipt</h2>",
                f"<div><strong>Debtor:</strong> {escape(str(debtor.name))}</div>",
                f"<div><strong>Amount:</strong> {escape(_money(payment_amount))}</div>",
                f"<div><strong>Payment method:</strong> {escape(str(payment.payment_method or ''))}</div>",
                f"<div><strong>Date:</strong> {escape(str(payment_date))}</div>",
                f"<div><strong>Balance owed:</strong> {escape(_money(debtor.amount_owed))}</div>",
                (f"<div><strong>Notes:</strong> {escape(str(payment.notes))}</div>" if payment.notes else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='DBT')
        except Exception:
            pass
        
        db.session.commit()

        # Email receipt to debtor (best-effort)
        try:
            payee_email = (str(getattr(debtor, 'email', '') or '').strip() or None)
            if not payee_email and getattr(debtor, 'contact', None):
                c = str(debtor.contact or '').strip()
                if '@' in c:
                    payee_email = c
            if payee_email and _is_valid_email_address(payee_email):
                subject = f"Payment Receipt - {debtor.name}"
                html = (transaction.receipt_html or '')
                if not html:
                    html = f"<p>Payment received: {escape(_money(payment_amount))}</p>"
                _send_email_best_effort_async(recipient=payee_email, subject=subject, html=html, text_body=None)
        except Exception:
            pass

        return jsonify({
            'success': True,
            'message': 'Payment recorded successfully',
            'amount_paid': debtor.amount_paid,
            'amount_owed': debtor.amount_owed
        })
    except ValueError:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'Invalid amount or date format'}), 400
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500


# ======================
# CREDITOR DEBT ROUTES
# ======================

@app.route('/admin/add_debt', methods=['POST'])
@login_required

def add_debt():
    try:
        # Extract form data
        debt_number = request.form.get('debt_number')
        debt_type = request.form.get('debt_type')
        amount = float(request.form.get('amount', 0))
        creditor = request.form.get('creditor')
        due_date = request.form.get('due_date')
        interest_rate = float(request.form.get('interest_rate', 0))
        description = request.form.get('description')
        status = request.form.get('status', 'active')
        user_id = current_user.id

        debt = Debt(
            debt_number=debt_number,
            debt_type=debt_type,
            amount=amount,
            creditor=creditor,
            due_date=datetime.strptime(due_date, '%Y-%m-%d') if due_date else None,
            interest_rate=interest_rate,
            description=description,
            status=status,
            user_id=user_id
        )

        db.session.add(debt)
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='add_debt',
            table_name='debts',
            record_id=debt.id,
            description=f"Added new debt {debt.debt_number} for creditor {debt.creditor}",
            new_values={
                'debt_id': debt.id,
                'amount': debt.amount,
                'creditor': debt.creditor,
                'due_date': debt.due_date.isoformat() if debt.due_date else None
            }
        )

        return jsonify({'success': True, 'message': 'Debt added successfully'})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error adding debt: {e}", exc_info=True)
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        creditor = (request.form.get('creditor') or '').strip()
        debt_type = (request.form.get('debt_type') or '').strip() or 'supplier'
        amount_raw = request.form.get('amount')
        due_date_raw = (request.form.get('due_date') or '').strip() or None
        interest_raw = (request.form.get('interest_rate') or '').strip() or None
        description = (request.form.get('description') or '').strip() or None

        if not creditor:
            return jsonify({'success': False, 'error': 'Creditor is required'}), 400
        if amount_raw is None or str(amount_raw).strip() == '':
            return jsonify({'success': False, 'error': 'Amount is required'}), 400

        try:
            amount = float(amount_raw)
        except (TypeError, ValueError):
            return jsonify({'success': False, 'error': 'Invalid amount'}), 400
        if amount <= 0:
            return jsonify({'success': False, 'error': 'Amount must be positive'}), 400

        due_date = None
        if due_date_raw:
            try:
                due_date = datetime.strptime(due_date_raw, '%Y-%m-%d').date()
            except Exception:
                return jsonify({'success': False, 'error': 'Invalid due date'}), 400

        interest_rate = 0.0
        if interest_raw:
            try:
                interest_rate = float(interest_raw)
            except (TypeError, ValueError):
                return jsonify({'success': False, 'error': 'Invalid interest rate'}), 400

        debt = Debt(
            debt_number=generate_debt_number(),
            debt_type=debt_type,
            amount=amount,
            creditor=creditor,
            due_date=due_date,
            interest_rate=interest_rate,
            description=description,
            status='active',
            user_id=current_user.id,
        )
        db.session.add(debt)
        db.session.commit()

        return jsonify({'success': True, 'message': 'Debt recorded successfully', 'id': debt.id})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500


@app.route('/admin/update_debt/<int:id>', methods=['POST'])
@login_required
def update_debt(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    debt = _db_get_or_404(Debt, id)
    try:
        creditor = (request.form.get('creditor') or '').strip()
        debt_type = (request.form.get('debt_type') or '').strip() or debt.debt_type
        amount_raw = request.form.get('amount')
        due_date_raw = (request.form.get('due_date') or '').strip() or None
        interest_raw = (request.form.get('interest_rate') or '').strip() or None
        description = (request.form.get('description') or '').strip() or None
        status = (request.form.get('status') or '').strip() or debt.status

        if creditor:
            debt.creditor = creditor
        if debt_type:
            debt.debt_type = debt_type

        if amount_raw is not None and str(amount_raw).strip() != '':
            try:
                amount = float(amount_raw)
            except (TypeError, ValueError):
                return jsonify({'success': False, 'error': 'Invalid amount'}), 400
            if amount <= 0:
                return jsonify({'success': False, 'error': 'Amount must be positive'}), 400
            debt.amount = amount

        if due_date_raw:
            try:
                debt.due_date = datetime.strptime(due_date_raw, '%Y-%m-%d').date()
            except Exception:
                return jsonify({'success': False, 'error': 'Invalid due date'}), 400
        else:
            debt.due_date = None

        if interest_raw is not None and str(interest_raw).strip() != '':
            try:
                debt.interest_rate = float(interest_raw)
            except (TypeError, ValueError):
                return jsonify({'success': False, 'error': 'Invalid interest rate'}), 400

        debt.description = description
        debt.status = status
        db.session.commit()

        return jsonify({'success': True, 'message': 'Debt updated successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500


@app.route('/admin/delete_debt/<int:id>', methods=['POST'])
@login_required
def delete_debt(id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    debt = _db_get_or_404(Debt, id)
    try:
        # Prevent deleting debts that already have payment records.
        payments_count = 0
        try:
            payments_count = len(debt.payments or [])
        except Exception:
            payments_count = 0
        if payments_count > 0:
            return jsonify({'success': False, 'error': 'Cannot delete a debt that has payments. Delete payments first or mark as closed.'}), 400

        db.session.delete(debt)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Debt deleted successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500


@app.route('/admin/add_debt_payment/<int:debt_id>', methods=['POST'])
@login_required
def add_debt_payment(debt_id):
    try:
        debt = _db_get_or_404(Debt, debt_id)
        amount = float(request.form.get('amount', 0))
        payment_method = request.form.get('payment_method', '')
        payment_date = request.form.get('payment_date', date.today())
        notes = request.form.get('notes', '')

        # Budget enforcement (warn-only by default)
        try:
            budget_check = _budget_check_outflow('finance', float(amount or 0), when_dt=get_eat_now())
            if budget_check and budget_check.get('block'):
                return jsonify({'success': False, 'error': budget_check.get('message') or 'Budget exceeded for this month.'}), 400
        except Exception:
            pass

        payment = DebtPayment(
            debtor_id=debt.id,
            amount=amount,
            payment_date=payment_date,
            payment_method=payment_method,
            notes=notes,
            user_id=current_user.id
        )
        db.session.add(payment)
        db.session.flush()  # get payment.id

        # Create transaction
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='debt_payment',
            amount=amount,
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Debt payment for {debt.debt_number}",
            created_at=get_eat_now(),
            updated_at=get_eat_now()
        )

        _maybe_set_transaction_meta(
            transaction,
            reference_table='debt_payments',
            direction='OUT',
            status='posted',
            department='finance',
            category='debt_repayment',
            payer=debt.creditor,
            payment_method=payment_method,
        )
        db.session.add(transaction)
        db.session.commit()

        # Log audit event
        log_audit_event(
            action='add_debt_payment',
            table_name='debt_payments',
            record_id=payment.id,
            description=f"Recorded debt payment of {payment.amount} for debt {debt.debt_number}",
            new_values={
                'debt_payment_id': payment.id,
                'debt_id': debt.id,
                'amount': payment.amount,
                'payment_method': payment.payment_method
            }
        )

        return jsonify({'success': True, 'message': 'Payment added successfully'})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error adding debt payment: {e}", exc_info=True)
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500
def add_debt_payment(debt_id):
    if current_user.role != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    debt = _db_get_or_404(Debt, debt_id)
    try:
        amount_raw = request.form.get('amount')
        payment_date_raw = request.form.get('payment_date')
        payment_method = (request.form.get('payment_method') or '').strip() or 'cash'
        notes = (request.form.get('notes') or '').strip() or None

        if amount_raw is None or str(amount_raw).strip() == '':
            return jsonify({'success': False, 'error': 'Payment amount is required'}), 400
        if not payment_date_raw:
            return jsonify({'success': False, 'error': 'Payment date is required'}), 400

        try:
            payment_amount = float(amount_raw)
        except (TypeError, ValueError):
            return jsonify({'success': False, 'error': 'Invalid payment amount'}), 400
        if payment_amount <= 0:
            return jsonify({'success': False, 'error': 'Payment amount must be positive'}), 400

        try:
            payment_date = datetime.strptime(payment_date_raw, '%Y-%m-%d').date()
        except Exception:
            return jsonify({'success': False, 'error': 'Invalid payment date'}), 400

        # Cap at remaining balance
        remaining = float(debt.balance or 0)
        if payment_amount > remaining + 0.0001:
            return jsonify({'success': False, 'error': f'Payment exceeds remaining balance (Ksh {remaining:.2f})'}), 400

        payment = DebtPayment(
            debtor_id=debt.id,
            amount=payment_amount,
            payment_date=payment_date,
            payment_method=payment_method,
            notes=notes,
            user_id=current_user.id,
        )
        db.session.add(payment)
        db.session.flush()

        # Post actual cash outflow into Transaction
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='expense',
            amount=payment_amount,
            user_id=current_user.id,
            reference_id=payment.id,
            notes=f"Debt payment to {debt.creditor} ({debt.debt_number})",
            created_at=get_eat_now(),
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='debt_payments',
            direction='OUT',
            status='posted',
            department='admin',
            category='creditor_debt_payment',
            payment_method=payment_method,
            payer=debt.creditor,
        )
        db.session.add(transaction)

        # Receipt for audit/reprint
        try:
            receipt_html = "".join([
                "<div style='font-family:Arial,sans-serif;max-width:700px;margin:0 auto;'>",
                "<h2 style='margin:0 0 8px 0;'>Creditor Payment Receipt</h2>",
                f"<div><strong>Creditor:</strong> {escape(str(debt.creditor))}</div>",
                f"<div><strong>Debt:</strong> {escape(str(debt.debt_number))}</div>",
                f"<div><strong>Amount:</strong> {escape(_money(payment_amount))}</div>",
                f"<div><strong>Payment method:</strong> {escape(str(payment_method))}</div>",
                f"<div><strong>Date:</strong> {escape(str(payment_date))}</div>",
                f"<div><strong>Remaining balance:</strong> {escape(_money(float(debt.balance or 0) - payment_amount))}</div>",
                (f"<div><strong>Notes:</strong> {escape(str(notes))}</div>" if notes else ""),
                "<hr style='margin:12px 0;border:none;border-top:1px solid #eee;' />",
                "<div style='color:#777;font-size:12px;'>Generated automatically by Makokha Medical Centre system.</div>",
                "<div style='margin-top:30px;display:flex;justify-content:space-between;align-items:flex-end;'>",
                f"<div style='flex:0 0 45%;'>{generate_digital_signature(signer_name='Makokha', signer_title='Medical Director')}</div>",
                f"<div style='flex:0 0 45%;'>{generate_rubber_stamp()}</div>",
                "</div>",
                "</div>",
            ])
            _ensure_transaction_receipt(transaction, receipt_html, prefix='CRD')
        except Exception:
            pass

        # Update debt status
        new_remaining = float(debt.balance or 0) - payment_amount
        if new_remaining <= 0.005:
            debt.status = 'paid'
        else:
            debt.status = 'partial'

        db.session.commit()
        return jsonify({'success': True, 'message': 'Payment recorded successfully'})
    except Exception:
        db.session.rollback()
        return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

# Legacy update_debtor removed



# Legacy delete_debtor removed to resolve conflict with new template-compatible route

    
# =====================
# TRANSACTION ROUTES
# =====================

@app.route('/admin/delete_transaction/<int:id>', methods=['POST'])
@login_required
def delete_transaction(id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    transaction = _db_get_or_404(Transaction, id)
    try:
        # Handle linked records when we can safely identify them.
        ref_table = None
        try:
            ref_table = transaction.reference_table
        except Exception:
            ref_table = None

        if ref_table == 'purchases' or transaction.transaction_type == 'purchase':
            Purchase.query.filter_by(id=transaction.reference_id).delete()
        elif ref_table == 'payrolls':
            Payroll.query.filter_by(id=transaction.reference_id).delete()
        elif ref_table == 'payroll_payments':
            PayrollPayment.query.filter_by(id=transaction.reference_id).delete()
        elif ref_table == 'debtor_payments' or transaction.transaction_type == 'debtor_payment':
            DebtorPayment.query.filter_by(id=transaction.reference_id).delete()
        elif ref_table == 'debt_payments':
            DebtPayment.query.filter_by(id=transaction.reference_id).delete()
        
        db.session.delete(transaction)
        db.session.commit()
        flash('Transaction deleted successfully', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error deleting transaction: {str(e)}', 'danger')
    return redirect(url_for('manage_money'))

# ========================
# PENDING PAYMENTS CHECK
# =======================
@app.route('/admin/check_pending_payments')
@login_required
def check_pending_payments():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    today = get_eat_now().date()
    
    # Pending bills (status is pending and due date is today or passed)
    pending_bills = Expense.query.filter(
        Expense.status == 'pending',
        Expense.due_date <= today
    ).count()
    
    # Pending payroll (payment date is today or passed)
    pending_payroll = Payroll.query.filter(
        Payroll.payment_date <= today
    ).count()
    
    # Pending debtor payments (next payment date is today or passed)
    pending_debtor_payments = Debtor.query.filter(
        Debtor.next_payment_date <= today
    ).count()
    
    total_pending = pending_bills + pending_payroll + pending_debtor_payments
    
    return jsonify({
        'count': total_pending,
        'pending_bills': pending_bills,
        'pending_payroll': pending_payroll,
        'pending_debtor_payments': pending_debtor_payments
    })

@app.route('/admin/pending_payments_details')
@login_required
def pending_payments_details():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        today = get_eat_now().date()
        
        # Pending bills
        pending_bills = Expense.query.filter(
            Expense.status == 'pending',
            Expense.due_date <= today
        ).all()
        
        bills_data = []
        for bill in pending_bills:
            bills_data.append({
                'id': bill.id,
                'expense_number': bill.expense_number,
                'expense_type': bill.expense_type,
                'amount': float(bill.amount),
                'due_date': bill.due_date.strftime('%Y-%m-%d') if bill.due_date else ''
            })
        
        # Pending payroll
        pending_payroll = Payroll.query.filter(
            Payroll.status.in_(['pending', 'partial']),
            Payroll.payment_date <= today
        ).all()
        
        payroll_data = []
        for payroll in pending_payroll:
            employee = _db_get(Employee, payroll.employee_id) if payroll.employee_id else None
            payroll_data.append({
                'id': payroll.id,
                'payroll_number': payroll.payroll_number,
                'employee_name': employee.name if employee else 'Unknown',
                'amount': float(payroll.amount),
                'payment_date': payroll.payment_date.strftime('%Y-%m-%d') if payroll.payment_date else ''
            })
        
        # Pending debtor payments
        pending_debtor_payments = Debtor.query.filter(
            Debtor.amount_owed > 0,
            Debtor.next_payment_date <= today
        ).all()
        
        debtors_data = []
        for debtor in pending_debtor_payments:
            debtors_data.append({
                'id': debtor.id,
                'name': debtor.name,
                'amount_owed': float(debtor.amount_owed),
                'next_payment_date': debtor.next_payment_date.strftime('%Y-%m-%d') if debtor.next_payment_date else ''
            })
        
        return jsonify({
            'pending_bills': bills_data,
            'pending_payroll': payroll_data,
            'pending_debtor_payments': debtors_data
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/admin/money/summary')
@login_required
def money_summary():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # Calculate total income from ALL income transactions in the system
        total_income = db.session.query(
            func.coalesce(func.sum(Transaction.amount), 0)
        ).filter(
            Transaction.transaction_type == 'income'
        ).scalar() or 0

        # Calculate total expenses from ALL expense-related transactions in the system
        total_expenses = db.session.query(
            func.coalesce(func.sum(Transaction.amount), 0)
        ).filter(
            # Include all types of expenses/outflows
            Transaction.transaction_type.in_(['expense', 'drawing', 'purchase', 'payroll', 'payroll_payment'])
        ).scalar() or 0

        # Calculate net profit (income - expenses)
        net_profit = float(total_income) - float(total_expenses)
        
        return jsonify({
            'total_income': float(total_income),
            'total_expenses': float(total_expenses),
            'net_profit': float(net_profit),
        })
    except Exception as e:
        current_app.logger.error(f"Error calculating money summary: {str(e)}")
        return jsonify({'error': str(e)}), 500
    
@app.route('/admin/dosage', methods=['GET', 'POST'])
@login_required
def manage_dosage():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            try:
                dosage = DrugDosage(
                    drug_id=request.form.get('drug_id'),
                    source='manual',
                    indication=request.form.get('indication'),
                    contraindication=request.form.get('contraindication'),
                    interaction=request.form.get('interaction'),
                    side_effects=request.form.get('side_effects'),
                    dosage_peds=request.form.get('dosage_peds'),
                    dosage_adults=request.form.get('dosage_adults'),
                    dosage_geriatrics=request.form.get('dosage_geriatrics'),
                    important_notes=request.form.get('important_notes')
                )
                db.session.add(dosage)
                db.session.commit()
                
                log_audit('create', 'DrugDosage', dosage.id, None, {
                    'drug_id': dosage.drug_id,
                    'indication': dosage.indication,
                    'contraindication': dosage.contraindication,
                    'interaction': dosage.interaction,
                    'side_effects': dosage.side_effects,
                    'dosage_peds': dosage.dosage_peds,
                    'dosage_adults': dosage.dosage_adults,
                    'dosage_geriatrics': dosage.dosage_geriatrics,
                    'important_notes': dosage.important_notes
                })
                
                flash('Dosage information added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding dosage information: {str(e)}', 'danger')
        
        elif action == 'edit':
            dosage_id = request.form.get('dosage_id')
            dosage = _db_get(DrugDosage, dosage_id)
            if dosage:
                try:
                    old_values = {
                        'drug_id': dosage.drug_id,
                        'indication': dosage.indication,
                        'contraindication': dosage.contraindication,
                        'interaction': dosage.interaction,
                        'side_effects': dosage.side_effects,
                        'dosage_peds': dosage.dosage_peds,
                        'dosage_adults': dosage.dosage_adults,
                        'dosage_geriatrics': dosage.dosage_geriatrics,
                        'important_notes': dosage.important_notes
                    }
                    
                    dosage.indication = request.form.get('indication')
                    dosage.contraindication = request.form.get('contraindication')
                    dosage.interaction = request.form.get('interaction')
                    dosage.side_effects = request.form.get('side_effects')
                    dosage.dosage_peds = request.form.get('dosage_peds')
                    dosage.dosage_adults = request.form.get('dosage_adults')
                    dosage.dosage_geriatrics = request.form.get('dosage_geriatrics')
                    dosage.important_notes = request.form.get('important_notes')
                    try:
                        dosage.source = 'manual'
                    except Exception:
                        pass
                    
                    db.session.commit()
                    
                    log_audit('update', 'DrugDosage', dosage.id, old_values, {
                        'drug_id': dosage.drug_id,
                        'indication': dosage.indication,
                        'contraindication': dosage.contraindication,
                        'interaction': dosage.interaction,
                        'side_effects': dosage.side_effects,
                        'dosage_peds': dosage.dosage_peds,
                        'dosage_adults': dosage.dosage_adults,
                        'dosage_geriatrics': dosage.dosage_geriatrics,
                        'important_notes': dosage.important_notes
                    })
                    
                    flash('Dosage information updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating dosage information: {str(e)}', 'danger')
            else:
                flash('Dosage information not found', 'danger')
        
        elif action == 'delete':
            dosage_id = request.form.get('dosage_id')
            dosage = db.session.get(DrugDosage, dosage_id)
            if dosage:
                try:
                    log_audit('delete', 'DrugDosage', dosage.id, {
                        'drug_id': dosage.drug_id,
                        'indication': dosage.indication,
                        'contraindication': dosage.contraindication,
                        'interaction': dosage.interaction,
                        'side_effects': dosage.side_effects,
                        'dosage_peds': dosage.dosage_peds,
                        'dosage_adults': dosage.dosage_adults,
                        'dosage_geriatrics': dosage.dosage_geriatrics,
                        'important_notes': dosage.important_notes
                    }, None)
                    
                    db.session.delete(dosage)
                    db.session.commit()
                    flash('Dosage information deleted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error deleting dosage information: {str(e)}', 'danger')
            else:
                flash('Dosage information not found', 'danger')
        
        return redirect(url_for('manage_dosage'))
    
    dosages = DrugDosage.query.join(Drug).all()
    drugs = Drug.query.all()

    total_drugs = Drug.query.count()
    drugs_with_dosage = Drug.query.filter(Drug.dosages.any()).count()
    drugs_without_dosage = max(0, total_drugs - drugs_with_dosage)
    ai_generated = 0
    try:
        ai_generated = DrugDosage.query.filter(DrugDosage.source == 'ai').count()
    except Exception:
        ai_generated = 0

    return render_template(
        'admin/dosage.html',
        dosages=dosages,
        drugs=drugs,
        ai_dosage_agent_enabled=_get_ai_dosage_agent_enabled(),
        stats={
            'total_drugs': total_drugs,
            'with_dosage': drugs_with_dosage,
            'without_dosage': drugs_without_dosage,
            'ai_generated': ai_generated,
        },
    )


@app.route('/admin/dosage-dashboard')
@login_required
def admin_dosage_dashboard():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    total_drugs = Drug.query.count()
    drugs_with_dosage = Drug.query.filter(Drug.dosages.any()).count()
    drugs_without_dosage = max(0, total_drugs - drugs_with_dosage)
    drugs_ai = 0
    try:
        drugs_ai = DrugDosage.query.filter(DrugDosage.source == 'ai').count()
    except Exception:
        drugs_ai = 0

    total_controlled = ControlledDrug.query.count()
    controlled_with_dosage = ControlledDrug.query.filter(ControlledDrug.dosages.any()).count()
    controlled_without_dosage = max(0, total_controlled - controlled_with_dosage)
    controlled_ai = 0
    try:
        controlled_ai = ControlledDrugDosage.query.filter(ControlledDrugDosage.source == 'ai').count()
    except Exception:
        controlled_ai = 0

    return render_template(
        'admin/dosage_dashboard.html',
        ai_dosage_agent_enabled=_get_ai_dosage_agent_enabled(),
        drug_stats={
            'total_drugs': total_drugs,
            'with_dosage': drugs_with_dosage,
            'without_dosage': drugs_without_dosage,
            'ai_generated': drugs_ai,
        },
        controlled_stats={
            'total_drugs': total_controlled,
            'with_dosage': controlled_with_dosage,
            'without_dosage': controlled_without_dosage,
            'ai_generated': controlled_ai,
        },
    )

@app.route('/admin/dosage/<int:dosage_id>')
@login_required
def get_dosage(dosage_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    dosage = _db_get_or_404(DrugDosage, dosage_id)
    
    return jsonify({
        'id': dosage.id,
        'drug': {
            'id': dosage.drug_record.id,
            'drug_number': dosage.drug_record.drug_number,
            'name': dosage.drug_record.name
        },
        'indication': dosage.indication,
        'contraindication': dosage.contraindication,
        'interaction': dosage.interaction,
        'side_effects': dosage.side_effects,
        'dosage_peds': dosage.dosage_peds,
        'dosage_adults': dosage.dosage_adults,
        'dosage_geriatrics': dosage.dosage_geriatrics,
        'important_notes': dosage.important_notes
    })

@app.route('/admin/drugs/without-dosage')
@login_required
def get_drugs_without_dosage():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    # Get drugs that don't have dosage information
    drugs = Drug.query.filter(~Drug.dosages.any()).all()
    
    return jsonify([{
        'id': drug.id,
        'drug_number': drug.drug_number,
        'name': drug.name
    } for drug in drugs])

@app.route('/admin/drugs/<int:drug_id>/dosage')
@login_required
def get_drug_dosage(drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    drug = _db_get_or_404(Drug, drug_id)
    dosage = DrugDosage.query.filter_by(drug_id=drug.id).first()
    
    return jsonify({
        'drug': {
            'id': drug.id,
            'name': drug.name,
            'drug_number': drug.drug_number
        },
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/admin/controlled-drugs/<int:controlled_drug_id>/dosage')
@login_required
def get_controlled_drug_dosage(controlled_drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    controlled_drug = _db_get_or_404(ControlledDrug, controlled_drug_id)
    dosage = ControlledDrugDosage.query.filter_by(controlled_drug_id=controlled_drug.id).first()
    
    return jsonify({
        'drug': {
            'id': controlled_drug.id,
            'name': controlled_drug.name,
            'controlled_drug_number': controlled_drug.controlled_drug_number
        },
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/admin/dosage/load-index-book', methods=['POST'])
@login_required
def admin_load_dosage_index_book():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    entries = _load_dosage_index_book()
    if not entries:
        flash('Dosage index book not found or empty. Place it at instance/dosage_index.json or static/dosage_index.json', 'warning')
        return redirect(url_for('manage_dosage'))

    name_map = { _normalize_drug_name(e.get('name')): e for e in entries if e.get('name') }
    created = 0
    try:
        drugs = Drug.query.filter(~Drug.dosages.any()).all()
        for drug in drugs:
            e = name_map.get(_normalize_drug_name(drug.name))
            if not e:
                continue
            d = DrugDosage(
                drug_id=drug.id,
                indication=e.get('indication'),
                contraindication=e.get('contraindication'),
                interaction=e.get('interaction'),
                side_effects=e.get('side_effects'),
                dosage_peds=e.get('dosage_peds'),
                dosage_adults=e.get('dosage_adults'),
                dosage_geriatrics=e.get('dosage_geriatrics'),
                important_notes=e.get('important_notes'),
            )
            db.session.add(d)
            created += 1
        db.session.commit()
        flash(f'Loaded {created} drug dosage entries from index book.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Failed to load dosage index book: {str(e)}', 'danger')

    return redirect(url_for('manage_dosage'))

@app.before_request
def log_request_info():
    """Log detailed information about each request"""
    if request.method != 'POST':
        return

    # Avoid logging PHI and secrets (cookies, CSRF tokens, full form bodies) in production.
    # Large request bodies also create noisy logs and can contribute to memory pressure.
    verbose = bool(app.debug or current_app.config.get('LOG_VERBOSE_REQUESTS'))

    def _clip(value, limit: int = 250) -> str:
        if value is None:
            return ""
        text = value if isinstance(value, str) else str(value)
        text = text.strip()
        if len(text) <= limit:
            return text
        return text[:limit] + "..."

    # Minimal, safe log line (always on)
    patient_id = request.form.get('patient_id')
    section = request.form.get('section')
    app.logger.info(
        "POST %s patient_id=%s section=%s content_length=%s",
        request.path,
        patient_id or "-",
        section or "-",
        request.content_length or "-",
    )

    if not verbose:
        return

    sensitive_headers = {
        'cookie',
        'authorization',
        'x-csrftoken',
        'x-csrf-token',
    }
    headers = {
        k: _clip(v, 500)
        for k, v in request.headers.items()
        if k.lower() not in sensitive_headers
    }
    app.logger.info(f"Headers (redacted): {headers}")

    # Log only a small subset of form/json fields to avoid PHI leakage.
    form_preview = {
        k: _clip(v)
        for k, v in request.form.items()
        if k.lower() in {'patient_id', 'section', 'active_tab', 'action'}
    }
    if form_preview:
        app.logger.info(f"Form preview: {form_preview}")

    json_data = request.get_json(silent=True)
    if isinstance(json_data, dict):
        json_preview = {
            k: _clip(v)
            for k, v in json_data.items()
            if str(k).lower() in {'patient_id', 'section', 'active_tab', 'action'}
        }
        if json_preview:
            app.logger.info(f"JSON preview: {json_preview}")
        
# Admin Patient Management Routes
@app.route('/admin/patients', methods=['GET'])
@login_required
def manage_patients():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Handle date filtering
    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')
    
    # Build query with all necessary relationships
    query = Patient.query\
        .outerjoin(PatientLab)\
        .outerjoin(PatientService)\
        .outerjoin(Prescription)\
        .outerjoin(PatientDiagnosis)\
        .options(
            db.joinedload(Patient.labs).joinedload(PatientLab.test),
            db.joinedload(Patient.services).joinedload(PatientService.service),
            db.joinedload(Patient.prescriptions).joinedload(Prescription.items),
            db.joinedload(Patient.diagnoses)
        )
    
    if start_date:
        try:
            start_date = datetime.strptime(start_date, '%Y-%m-%d')
            query = query.filter(Patient.created_at >= start_date)
        except ValueError:
            flash('Invalid start date format', 'danger')
    
    if end_date:
        try:
            end_date = datetime.strptime(end_date, '%Y-%m-%d') + timedelta(days=1)
            query = query.filter(Patient.created_at <= end_date)
        except ValueError:
            flash('Invalid end date format', 'danger')
    
    patients = query.order_by(Patient.created_at.desc()).distinct().all()
    
    # Calculate summary totals
    total_lab_amount = 0
    total_service_amount = 0
    total_drug_amount = 0
    
    for patient in patients:
        # Lab tests total
        for lab in patient.labs:
            total_lab_amount += lab.test.price
        
        # Services total (assuming you have a PatientService model)
        for service in patient.services:
            total_service_amount += service.service.price
        
        # Prescriptions total
        for prescription in patient.prescriptions:
            for item in prescription.items:
                total_drug_amount += item.drug.selling_price * item.quantity
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add':
            try:
                raw_patient_type = request.form.get('patient_type')
                patient_type = (raw_patient_type or '').strip().upper()
                if patient_type not in {'OP', 'IP'}:
                    patient_type = 'OP'

                patient_number = generate_patient_number(patient_type)
                
                patient = Patient(
                    op_number=patient_number if patient_type == 'OP' else None,
                    ip_number=patient_number if patient_type == 'IP' else None,
                    name=Config.encrypt_data_static(request.form.get('name')),
                    age=_parse_age_years(request.form.get('age')),
                    gender=request.form.get('gender'),
                    address=Config.encrypt_data_static(request.form.get('address')) if request.form.get('address') else None,
                    phone=Config.encrypt_data_static(request.form.get('phone')) if request.form.get('phone') else None,
                    nok_name=Config.encrypt_data_static(request.form.get('nok_name')) if request.form.get('nok_name') else None,
                    nok_contact=Config.encrypt_data_static(request.form.get('nok_contact')) if request.form.get('nok_contact') else None,
                    chief_complaints=request.form.get('chief_complaints'),
                    diagnosis=request.form.get('diagnosis'),
                    tca=datetime.strptime(request.form.get('tca'), '%Y-%m-%d').date() if request.form.get('tca') else None,
                    status='active'
                )
                db.session.add(patient)
                db.session.commit()
                
                log_audit('create', 'Patient', patient.id, None, {
                    'patient_number': patient_number,
                    'name': request.form.get('name'),
                    'age': request.form.get('age'),
                    'gender': request.form.get('gender')
                })
                
                flash('Patient added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding patient: {str(e)}', 'danger')
        
        elif action == 'edit':
            patient_id = request.form.get('patient_id')
            patient = _db_get(Patient, patient_id)
            if patient:
                try:
                    old_values = {
                        'name': Config.decrypt_data_static(patient.name),
                        'age': patient.age,
                        'gender': patient.gender,
                        'address': Config.decrypt_data_static(patient.address),
                        'phone': Config.decrypt_data_static(patient.phone),
                        'nok_name': Config.decrypt_data_static(patient.nok_name),
                        'nok_contact': Config.decrypt_data_static(patient.nok_contact),
                        'chief_complaints': patient.chief_complaints,
                        'diagnosis': patient.diagnosis,
                        'tca': patient.tca,
                        'status': patient.status
                    }
                    
                    patient.name = Config.encrypt_data_static(request.form.get('name'))
                    patient.age = _parse_age_years(request.form.get('age'))
                    patient.gender = request.form.get('gender')
                    patient.address = Config.encrypt_data_static(request.form.get('address')) if request.form.get('address') else None
                    patient.phone = Config.encrypt_data_static(request.form.get('phone')) if request.form.get('phone') else None
                    patient.nok_name = Config.encrypt_data_static(request.form.get('nok_name')) if request.form.get('nok_name') else None
                    patient.nok_contact = Config.encrypt_data_static(request.form.get('nok_contact')) if request.form.get('nok_contact') else None
                    patient.chief_complaints = request.form.get('chief_complaints')
                    patient.diagnosis = request.form.get('diagnosis')
                    patient.tca = datetime.strptime(request.form.get('tca'), '%Y-%m-%d').date() if request.form.get('tca') else None
                    patient.status = request.form.get('status')
                    
                    db.session.commit()
                    
                    log_audit('update', 'Patient', patient.id, old_values, {
                        'name': request.form.get('name'),
                        'age': request.form.get('age'),
                        'gender': request.form.get('gender'),
                        'address': request.form.get('address'),
                        'phone': request.form.get('phone'),
                        'nok_name': request.form.get('nok_name'),
                        'nok_contact': request.form.get('nok_contact'),
                        'chief_complaints': request.form.get('chief_complaints'),
                        'diagnosis': request.form.get('diagnosis'),
                        'tca': request.form.get('tca'),
                        'status': request.form.get('status')
                    })
                    
                    flash('Patient updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating patient: {str(e)}', 'danger')
            else:
                flash('Patient not found', 'danger')
        
        return redirect(url_for('manage_patients'))
    
    lab_tests = LabTest.query.all()
    services = Service.query.all()
    
    return render_template('admin/patients.html',
        patients=patients,
        lab_tests=lab_tests,
        services=services,
        total_lab_amount=total_lab_amount,
        total_service_amount=total_service_amount,
        total_drug_amount=total_drug_amount,
        total_amount=total_lab_amount + total_service_amount + total_drug_amount
    )

@app.route('/admin/patients/<int:patient_id>')
@login_required
def get_patient(patient_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    patient = _db_get_or_404(Patient, patient_id)
    
    return jsonify({
        'id': patient.id,
        'op_number': patient.op_number,
        'ip_number': patient.ip_number,
        'name': patient.name,
        'age': patient.age,
        'gender': patient.gender,
        'address': patient.address,
        'phone': patient.phone,
        'nok_name': patient.nok_name,
        'nok_contact': patient.nok_contact,
        'chief_complaints': patient.chief_complaints,
        'diagnosis': patient.diagnosis,
        'tca': patient.tca.strftime('%Y-%m-%d') if patient.tca else None,
        'status': patient.status
    })

@app.route('/admin/patients/<int:patient_id>/details')
@login_required
def patient_details(patient_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    patient = _db_get_or_404(Patient, patient_id)
    
    # Calculate financial totals
    total_lab_amount = sum(lab.test.price for lab in patient.labs)
    total_service_amount = sum(service.service.price for service in patient.services)
    total_drug_amount = sum(
        item.drug.selling_price * item.quantity 
        for prescription in patient.prescriptions 
        for item in prescription.items
    )
    
    return jsonify({
        'patient_number': patient.op_number or patient.ip_number,
        'name': Config.decrypt_data_static(patient.name),
        'age': patient.age,
        'gender': patient.gender,
        'type': 'OP' if patient.op_number else 'IP',
        'address': Config.decrypt_data_static(patient.address),
        'phone': Config.decrypt_data_static(patient.phone),
        'nok_name': Config.decrypt_data_static(patient.nok_name),
        'nok_contact': Config.decrypt_data_static(patient.nok_contact),
        'complaints': patient.chief_complaints,
        'diagnosis': patient.diagnosis,
        'treatment': patient.treatment,
        'tca': patient.tca.strftime('%Y-%m-%d') if patient.tca else None,
        'status': patient.status,
        'total_lab_amount': total_lab_amount,
        'total_service_amount': total_service_amount,
        'total_drug_amount': total_drug_amount,
        'total_amount': total_lab_amount + total_service_amount + total_drug_amount,
        'lab_tests': [{
            'id': lab.id,
            'name': lab.test.name,
            'price': lab.test.price,
            'results': lab.results,
            'comments': lab.comments,
            'date': lab.created_at.strftime('%Y-%m-%d')
        } for lab in patient.labs],
        'services': [{
            'id': service.id,
            'name': service.service.name,
            'price': service.service.price,
            'notes': service.notes,
            'date': service.created_at.strftime('%Y-%m-%d')
        } for service in patient.services],
        'prescriptions': [{
            'id': item.id,
            'drug_name': item.drug.name,
            'quantity': item.quantity,
            'unit_price': item.drug.selling_price,
            'status': item.status,
            'date': prescription.created_at.strftime('%Y-%m-%d')
        } for prescription in patient.prescriptions for item in prescription.items]
    })
    
# Medical Tests Management
@app.route('/admin/medical-tests')
@login_required
def manage_tests():
    if current_user.role != 'admin':
        abort(403)
    
    services = Service.query.order_by(Service.name).all()
    lab_tests = LabTest.query.order_by(LabTest.name).all()
    imaging_tests = ImagingTest.query.order_by(ImagingTest.name).all()
    
    return render_template('admin/medical_tests.html', 
                         services=services,
                         lab_tests=lab_tests,
                         imaging_tests=imaging_tests)

# Service CRUD
@app.route('/admin/services/add', methods=['POST'])
@limiter.limit("10 per minute")
@admin_required_json
def add_service():
    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    is_active = True if request.form.get('is_active') is None else parse_bool(request.form.get('is_active'))

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    service = Service(name=name, price=float(price), description=description, is_active=is_active)
    try:
        db.session.add(service)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'add_service failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('add_service', 'Service', service.id, None, {
            'name': service.name,
            'price': service.price,
            'is_active': service.is_active,
        })
    except Exception as e:
        current_app.logger.error(f'audit add_service failed: {str(e)}', exc_info=True)

    return success_response({'id': service.id, 'name': service.name, 'price': service.price, 'description': service.description, 'is_active': service.is_active}, status=201)

@app.route('/admin/services/<int:id>')
@limiter.limit("60 per minute")
@admin_required_json
def get_service(id):
    service = _db_get(Service, id)
    if not service:
        return jsonify({'success': False, 'error': 'Not found'}), 404
    return success_response({
        'id': service.id,
        'name': service.name,
        'price': service.price,
        'description': service.description,
        'is_active': service.is_active,
    })

@app.route('/admin/services/<int:id>/update', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def update_service(id):
    service = _db_get(Service, id)
    if not service:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_data = {
        'name': service.name,
        'price': service.price,
        'description': service.description,
        'is_active': getattr(service, 'is_active', True),
    }

    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    has_is_active = 'is_active' in request.form
    is_active = parse_bool(request.form.get('is_active')) if has_is_active else None

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    try:
        service.name = name
        service.price = float(price)
        service.description = description
        if has_is_active:
            service.is_active = is_active
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'update_service failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('update_service', 'Service', service.id, old_data, {
            'name': service.name,
            'price': service.price,
            'description': service.description,
            'is_active': getattr(service, 'is_active', True),
        })
    except Exception as e:
        current_app.logger.error(f'audit update_service failed: {str(e)}', exc_info=True)

    return success_response({'id': service.id, 'name': service.name, 'price': service.price, 'description': service.description, 'is_active': getattr(service, 'is_active', True)})


@app.route('/admin/services/<int:id>/toggle-active', methods=['POST'])
@limiter.limit("30 per minute")
@admin_required_json
def toggle_service_active(id):
    service = _db_get(Service, id)
    if not service:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_is_active = getattr(service, 'is_active', True)
    try:
        service.is_active = not bool(old_is_active)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'toggle_service_active failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('toggle_service_active', 'Service', service.id, {'is_active': old_is_active}, {'is_active': service.is_active})
    except Exception as e:
        current_app.logger.error(f'audit toggle_service_active failed: {str(e)}', exc_info=True)

    return success_response({'id': service.id, 'is_active': service.is_active})

@app.route('/admin/services/<int:id>/delete', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def delete_service(id):
    service = _db_get(Service, id)
    if not service:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    try:
        db.session.delete(service)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'delete_service failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('delete_service', 'Service', service.id, {'name': service.name, 'price': service.price}, None)
    except Exception as e:
        current_app.logger.error(f'audit delete_service failed: {str(e)}', exc_info=True)

    return success_response()

# Lab Test CRUD
@app.route('/admin/lab-tests/add', methods=['POST'])
@limiter.limit("10 per minute")
@admin_required_json
def add_lab_test():
    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    is_active = True if request.form.get('is_active') is None else parse_bool(request.form.get('is_active'))

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    lab_test = LabTest(name=name, price=float(price), description=description, is_active=is_active)
    try:
        db.session.add(lab_test)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'add_lab_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('add_lab_test', 'LabTest', lab_test.id, None, {
            'name': lab_test.name,
            'price': lab_test.price,
            'is_active': lab_test.is_active,
        })
    except Exception as e:
        current_app.logger.error(f'audit add_lab_test failed: {str(e)}', exc_info=True)

    return success_response({'id': lab_test.id, 'name': lab_test.name, 'price': lab_test.price, 'description': lab_test.description, 'is_active': lab_test.is_active}, status=201)

@app.route('/admin/lab-tests/<int:id>')
@limiter.limit("60 per minute")
@admin_required_json
def get_lab_test(id):
    lab_test = _db_get(LabTest, id)
    if not lab_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404
    return success_response({
        'id': lab_test.id,
        'name': lab_test.name,
        'price': lab_test.price,
        'description': lab_test.description,
        'is_active': lab_test.is_active,
    })

@app.route('/admin/lab-tests/<int:id>/update', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def update_lab_test(id):
    lab_test = _db_get(LabTest, id)
    if not lab_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_data = {
        'name': lab_test.name,
        'price': lab_test.price,
        'description': lab_test.description,
        'is_active': getattr(lab_test, 'is_active', True),
    }

    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    has_is_active = 'is_active' in request.form
    is_active = parse_bool(request.form.get('is_active')) if has_is_active else None

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    try:
        lab_test.name = name
        lab_test.price = float(price)
        lab_test.description = description
        if has_is_active:
            lab_test.is_active = is_active
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'update_lab_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('update_lab_test', 'LabTest', lab_test.id, old_data, {
            'name': lab_test.name,
            'price': lab_test.price,
            'description': lab_test.description,
            'is_active': getattr(lab_test, 'is_active', True),
        })
    except Exception as e:
        current_app.logger.error(f'audit update_lab_test failed: {str(e)}', exc_info=True)

    return success_response({'id': lab_test.id, 'name': lab_test.name, 'price': lab_test.price, 'description': lab_test.description, 'is_active': getattr(lab_test, 'is_active', True)})


@app.route('/admin/lab-tests/<int:id>/toggle-active', methods=['POST'])
@limiter.limit("30 per minute")
@admin_required_json
def toggle_lab_test_active(id):
    lab_test = _db_get(LabTest, id)
    if not lab_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_is_active = getattr(lab_test, 'is_active', True)
    try:
        lab_test.is_active = not bool(old_is_active)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'toggle_lab_test_active failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('toggle_lab_test_active', 'LabTest', lab_test.id, {'is_active': old_is_active}, {'is_active': lab_test.is_active})
    except Exception as e:
        current_app.logger.error(f'audit toggle_lab_test_active failed: {str(e)}', exc_info=True)

    return success_response({'id': lab_test.id, 'is_active': lab_test.is_active})

@app.route('/admin/lab-tests/<int:id>/delete', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def delete_lab_test(id):
    lab_test = _db_get(LabTest, id)
    if not lab_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    try:
        db.session.delete(lab_test)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'delete_lab_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('delete_lab_test', 'LabTest', lab_test.id, {
            'name': lab_test.name,
            'price': lab_test.price
        }, None)
    except Exception as e:
        current_app.logger.error(f'audit delete_lab_test failed: {str(e)}', exc_info=True)

    return success_response()

# Imaging Test CRUD
@app.route('/admin/imaging-tests/add', methods=['POST'])
@limiter.limit("10 per minute")
@admin_required_json
def add_imaging_test():
    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    is_active = parse_bool(request.form.get('is_active'))

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    imaging_test = ImagingTest(
        name=name,
        price=float(price),
        description=description,
        is_active=is_active
    )
    try:
        db.session.add(imaging_test)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'add_imaging_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('add_imaging_test', 'ImagingTest', imaging_test.id, None, {
            'name': imaging_test.name,
            'price': imaging_test.price,
            'is_active': imaging_test.is_active
        })
    except Exception as e:
        current_app.logger.error(f'audit add_imaging_test failed: {str(e)}', exc_info=True)

    return success_response({'id': imaging_test.id, 'name': imaging_test.name, 'price': imaging_test.price, 'description': imaging_test.description, 'is_active': imaging_test.is_active}, status=201)

@app.route('/admin/imaging-tests/<int:id>')
@limiter.limit("60 per minute")
@admin_required_json
def get_imaging_test(id):
    imaging_test = _db_get(ImagingTest, id)
    if not imaging_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404
    return success_response({
        'id': imaging_test.id,
        'name': imaging_test.name,
        'price': imaging_test.price,
        'description': imaging_test.description,
        'is_active': imaging_test.is_active
    })

@app.route('/admin/imaging-tests/<int:id>/update', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def update_imaging_test(id):
    imaging_test = _db_get(ImagingTest, id)
    if not imaging_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_data = {
        'name': imaging_test.name,
        'price': imaging_test.price,
        'description': imaging_test.description,
        'is_active': imaging_test.is_active
    }

    name = (request.form.get('name') or '').strip()
    price_str = request.form.get('price')
    description = (request.form.get('description') or '').strip() or None
    is_active = parse_bool(request.form.get('is_active'))

    if not name:
        return bad_request('Name is required')
    price, err = parse_price(price_str)
    if err:
        return bad_request(err)

    try:
        imaging_test.name = name
        imaging_test.price = float(price)
        imaging_test.description = description
        imaging_test.is_active = is_active
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'update_imaging_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('update_imaging_test', 'ImagingTest', imaging_test.id, old_data, {
            'name': imaging_test.name,
            'price': imaging_test.price,
            'description': imaging_test.description,
            'is_active': imaging_test.is_active
        })
    except Exception as e:
        current_app.logger.error(f'audit update_imaging_test failed: {str(e)}', exc_info=True)

    return success_response({'id': imaging_test.id, 'name': imaging_test.name, 'price': imaging_test.price, 'description': imaging_test.description, 'is_active': imaging_test.is_active})


@app.route('/admin/imaging-tests/<int:id>/toggle-active', methods=['POST'])
@limiter.limit("30 per minute")
@admin_required_json
def toggle_imaging_test_active(id):
    imaging_test = _db_get(ImagingTest, id)
    if not imaging_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    old_is_active = imaging_test.is_active
    try:
        imaging_test.is_active = not bool(imaging_test.is_active)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'toggle_imaging_test_active failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('toggle_imaging_test_active', 'ImagingTest', imaging_test.id, {'is_active': old_is_active}, {'is_active': imaging_test.is_active})
    except Exception as e:
        current_app.logger.error(f'audit toggle_imaging_test_active failed: {str(e)}', exc_info=True)

    return success_response({'id': imaging_test.id, 'is_active': imaging_test.is_active})

@app.route('/admin/imaging-tests/<int:id>/delete', methods=['POST'])
@limiter.limit("20 per minute")
@admin_required_json
def delete_imaging_test(id):
    imaging_test = _db_get(ImagingTest, id)
    if not imaging_test:
        return jsonify({'success': False, 'error': 'Not found'}), 404

    try:
        db.session.delete(imaging_test)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'delete_imaging_test failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Server error'}), 500

    try:
        log_audit('delete_imaging_test', 'ImagingTest', imaging_test.id, {
            'name': imaging_test.name,
            'price': imaging_test.price
        }, None)
    except Exception as e:
        current_app.logger.error(f'audit delete_imaging_test failed: {str(e)}', exc_info=True)

    return success_response()

@app.route('/pharmacist')
@login_required
def pharmacist_dashboard():
    try:
        # Compare role as string (handles EncryptedType)
        user_role = str(current_user.role).lower().strip() if current_user.role else ''
        if user_role != 'pharmacist':
            flash('Unauthorized access', 'danger')
            return redirect(url_for('home'))
        
        # Get counts for dashboard cards
        low_stock = Drug.query.filter(Drug.remaining_quantity < 10).count()
        expiring_soon = Drug.query.filter(
            Drug.expiry_date <= date.today() + timedelta(days=30),
            Drug.expiry_date >= date.today()
        ).count()
        
        # Get recent sales (last 5)
        recent_sales = Sale.query.order_by(Sale.created_at.desc()).limit(5).all()
        
        # Get pending prescriptions count
        pending_prescriptions = Prescription.query.filter_by(status='pending').count()
        
        return render_template('pharmacist/dashboard.html',
            low_stock=low_stock,
            expiring_soon=expiring_soon,
            recent_sales=recent_sales,
            pending_prescriptions=pending_prescriptions
        )
    except Exception as e:
        current_app.logger.error(f"Error in pharmacist_dashboard: {str(e)}")
        flash('An error occurred while loading the dashboard', 'danger')
        return redirect(url_for('home'))

# Pharmacist API routes
@app.route('/pharmacist/api/dashboard-stats')
@login_required
def pharmacist_dashboard_stats():
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        total_drugs = Drug.query.count()
        low_stock = Drug.query.filter(Drug.remaining_quantity < 10, Drug.remaining_quantity > 0).count()
        expiring_soon = Drug.query.filter(
            Drug.expiry_date <= date.today() + timedelta(days=30),
            Drug.expiry_date >= date.today()
        ).count()
        pending_prescriptions = Prescription.query.filter_by(status='pending').count()

        return jsonify({
            'success': True,
            'data': {
                'total_drugs': total_drugs,
                'low_stock': low_stock,
                'expiring_soon': expiring_soon,
                'pending_prescriptions': pending_prescriptions,
            }
        })
    except Exception as e:
        current_app.logger.error(f"Failed to load pharmacist dashboard stats: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to load dashboard stats'}), 500

@app.route('/pharmacist/api/insurance-providers')
@login_required
def pharmacist_insurance_providers():
    """Fetch all insurance providers for pharmacist use."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('pharmacist', 'receptionist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        providers = InsuranceProvider.query.order_by(InsuranceProvider.name).all()
        return jsonify({
            'success': True,
            'providers': [{
                'id': p.id,
                'name': p.name,
                'phone': p.phone,
                'email': p.email
            } for p in providers]
        })
    except Exception as e:
        current_app.logger.error(f"Error fetching insurance providers: {str(e)}")
        return jsonify({'success': False, 'error': 'Internal server error'}), 500

@app.route('/pharmacist/sale/<int:sale_id>/receipt-data')
@login_required
def pharmacist_sale_receipt_data(sale_id):
    sale = db.session.get(Sale, sale_id)
    if not sale:
        abort(404)
    
    # Basic authorization: only admin or the pharmacist who made the sale
    if not (current_user.role == 'admin' or sale.user_id == current_user.id):
        abort(403)

    items = [{
        'name': item.drug_name,
        'spec': item.drug_specification,
        'qty': item.quantity,
        'price': float(item.unit_price),
        'total': float(item.total_price)
    } for item in sale.items]

    return jsonify({
        'sale_number': sale.sale_number,
        'date': sale.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': sale.patient.name if sale.patient else 'Walk-in Customer',
        'pharmacist': sale.pharmacist_name,
        'items': items,
        'total': float(sale.total_amount)
    })
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    sale = Sale.query.options(
        db.joinedload(Sale.user),
        db.joinedload(Sale.items),
        db.joinedload(Sale.patient)
    ).get(sale_id)
    
    if not sale:
        return jsonify({'error': 'Sale not found'}), 404
    
    receipt_data = {
        'sale_id': sale.id,
        'sale_number': sale.sale_number,
        'date': sale.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': sale.patient.get_decrypted_name if sale.patient else 'Walk-in Customer',
        'patient_number': sale.patient.op_number or sale.patient.ip_number if sale.patient else 'N/A',
        'pharmacist_name': sale.user.username,
        'payment_method': sale.payment_method,
        'total_amount': sale.total_amount,
        'items': []
    }
    
    for item in sale.items:
        receipt_data['items'].append({
            'name': item.drug_name,
            'specification': item.drug_specification,
            'quantity': item.quantity,
            'unit_price': item.unit_price,
            'total_price': item.total_price
        })
    
    return jsonify(receipt_data)

@app.route('/pharmacist/refund/<int:refund_id>/receipt-data')
@login_required
def pharmacist_refund_receipt_data(refund_id):
    refund = db.session.get(Refund, refund_id)
    if not refund:
        abort(404)
    
    # Basic authorization: only admin or the pharmacist who processed refund
    if not (current_user.role == 'admin' or refund.user_id == current_user.id):
        abort(403)

    items = [{
        'name': item.sale_item.drug_name,
        'spec': item.sale_item.drug_specification,
        'qty': item.quantity,
        'price': float(item.unit_price),
        'total': float(item.total_price)
    } for item in refund.items]

    return jsonify({
        'refund_number': refund.refund_number,
        'original_sale': refund.sale.sale_number,
        'date': refund.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': refund.sale.patient.name if refund.sale.patient else 'Walk-in Customer',
        'pharmacist': refund.user.username,
        'items': items,
        'total': float(refund.total_amount)
    })
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    refund = Refund.query.options(
        db.joinedload(Refund.sale).joinedload(Sale.patient),
        db.joinedload(Refund.user),
        db.joinedload(Refund.items).joinedload(RefundItem.sale_item)
    ).get(refund_id)
    
    if not refund:
        return jsonify({'error': 'Refund not found'}), 404
    
    receipt_data = {
        'refund_id': refund.id,
        'refund_number': refund.refund_number,
        'sale_number': refund.sale.sale_number,
        'date': refund.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': refund.sale.patient.get_decrypted_name if refund.sale.patient else 'Walk-in Customer',
        'reason': refund.reason,
        'total_amount': refund.total_amount,
        'items': []
    }
    
    for item in refund.items:
        receipt_data['items'].append({
            'drug_name': item.sale_item.drug_name,
            'quantity': item.quantity,
            'unit_price': item.unit_price,
            'total_price': item.total_price
        })
    
    return jsonify(receipt_data)

# Add decrypt_data to Jinja context
@app.context_processor
def utility_processor():
    def decrypt_data(value):
        if value is None:
            return ""
        try:
            return Config.decrypt_data_static(value)
        except Exception:
            # Some fields may already be plain text (or not decryptable).
            try:
                return str(value)
            except Exception:
                return ""

    return {
        'decrypt_data': decrypt_data,
    }

@app.route('/pharmacist/drugs')
@login_required
def pharmacist_drugs():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    # Get filter parameters
    filter_type = request.args.get('filter', 'all')
    search_query = request.args.get('search', '')
    sort_by = request.args.get('sort', 'name_asc')
    
    # Base query
    query = Drug.query
    
    # Apply filters
    if filter_type == 'low':
        query = query.filter(Drug.remaining_quantity < 10)
    elif filter_type == 'out':
        query = query.filter(Drug.remaining_quantity == 0)
    elif filter_type == 'expiring':
        query = query.filter(Drug.expiry_date <= date.today() + timedelta(days=30))
    
    # Apply search
    if search_query:
        query = query.filter(
            or_(
                Drug.name.ilike(f'%{search_query}%'),
                Drug.drug_number.ilike(f'%{search_query}%'),
            )
        )
    
    # Apply sorting
    if sort_by == 'name_asc':
        query = query.order_by(Drug.name.asc())
    elif sort_by == 'name_desc':
        query = query.order_by(Drug.name.desc())
    elif sort_by == 'stock_asc':
        query = query.order_by(Drug.remaining_quantity.asc())
    elif sort_by == 'stock_desc':
        query = query.order_by(Drug.remaining_quantity.desc())
    elif sort_by == 'expiry_asc':
        query = query.order_by(Drug.expiry_date.asc())
    elif sort_by == 'expiry_desc':
        query = query.order_by(Drug.expiry_date.desc())
    
    drugs = query.all()
    
    # Prepare response data
    drugs_data = []
    for drug in drugs:
        drugs_data.append({
            'id': drug.id,
            'drug_number': drug.drug_number,
            'name': drug.name,
            'specification': drug.specification,
            'expiry_date': drug.expiry_date.isoformat() if drug.expiry_date else None,
            'selling_price': float(drug.selling_price),
            'remaining_quantity': drug.remaining_quantity
        })
    
    return jsonify(drugs_data)

@app.route('/pharmacist/controlled-drugs')
@login_required
def pharmacist_controlled_drugs():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    # Get filter parameters
    filter_type = request.args.get('filter', 'all')
    search_query = request.args.get('search', '')
    
    # Base query
    query = ControlledDrug.query
    
    # Apply filters
    if filter_type == 'low':
        query = query.filter(ControlledDrug.remaining_quantity < 5)
    elif filter_type == 'out':
        query = query.filter(ControlledDrug.remaining_quantity == 0)
    elif filter_type == 'expiring':
        query = query.filter(ControlledDrug.expiry_date <= date.today() + timedelta(days=30))
    
    # Apply search
    if search_query:
        query = query.filter(
            or_(
                ControlledDrug.name.ilike(f'%{search_query}%'),
                ControlledDrug.controlled_drug_number.ilike(f'%{search_query}%'),
            )
        )
    
    # Sort by name
    query = query.order_by(ControlledDrug.name.asc())
    
    drugs = query.all()
    
    # Prepare response data
    drugs_data = []
    for drug in drugs:
        drugs_data.append({
            'id': drug.id,
            'controlled_drug_number': drug.controlled_drug_number,
            'name': drug.name,
            'specification': drug.specification,
            'expiry_date': drug.expiry_date.isoformat() if drug.expiry_date else None,
            'selling_price': float(drug.selling_price),
            'remaining_quantity': drug.remaining_quantity
        })
    
    return jsonify(drugs_data)

@app.route('/pharmacist/controlled-sale', methods=['POST'])
@login_required
def process_controlled_sale():
    """Process a controlled drug sale from the cart with patient details and prescription image"""
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        # Parse form data
        cart_json = request.form.get('items')
        if not cart_json:
            return jsonify({'success': False, 'error': 'Missing items'}), 400
        
        try:
            items = json.loads(cart_json)
        except Exception:
            return jsonify({'success': False, 'error': 'Invalid items format'}), 400
        
        if not items:
            return jsonify({'success': False, 'error': 'Cart is empty'}), 400
        
        # Get patient details
        patient_name = (request.form.get('patient_name') or '').strip()
        patient_age = request.form.get('patient_age')
        patient_gender = (request.form.get('patient_gender') or '').strip()
        patient_phone = (request.form.get('patient_phone') or '').strip()
        patient_destination = (request.form.get('patient_destination') or '').strip()
        patient_diagnosis = (request.form.get('patient_diagnosis') or '').strip()
        
        if not patient_name or not patient_gender or not patient_phone or not patient_destination:
            return jsonify({'success': False, 'error': 'Missing required patient details'}), 400
        
        # Get prescription image
        prescription_image = request.files.get('prescription_image')
        if not prescription_image or not prescription_image.filename:
            return jsonify({'success': False, 'error': 'Prescription image is required'}), 400
        
        # Save prescription image
        prescription_path = _save_prescription_image(prescription_image)
        
        # Validate stock and compute totals
        resolved_items = []
        total_amount = 0.0
        for idx, item in enumerate(items):
            cd_id = item.get('controlled_drug_id')
            qty = int(item.get('quantity', 0))
            
            if not cd_id or qty <= 0:
                return jsonify({'success': False, 'error': f'Invalid quantity for item {idx+1}'}), 400
            
            cd = db.session.get(ControlledDrug, int(cd_id))
            if not cd:
                return jsonify({'success': False, 'error': f'Controlled drug not found: {cd_id}'}), 400
            
            if cd.remaining_quantity < qty:
                return jsonify({
                    'success': False, 
                    'error': f'Insufficient stock for {cd.name}',
                    'available': cd.remaining_quantity,
                    'requested': qty
                }), 400
            
            unit_price = float(cd.selling_price or 0)
            line_total = unit_price * qty
            total_amount += line_total
            resolved_items.append((cd, qty, unit_price))
        
        # Generate sale number
        sale_number = generate_controlled_sale_number()
        
        # Get EAT timezone (Africa/Nairobi)
        from pytz import timezone as pytz_timezone
        eat = pytz_timezone('Africa/Nairobi')
        sale_datetime = datetime.now(tz=eat)
        
        # Create ControlledSale record
        sale = ControlledSale(
            sale_number=sale_number,
            user_id=current_user.id,
            pharmacist_name=f"{current_user.username}",
            total_amount=float(total_amount),
            payment_method='cash',
            status='completed',
            notes='Controlled inventory sale',
            customer_name=patient_name,
            customer_age=int(patient_age) if patient_age not in (None, '') else None,
            customer_gender=patient_gender,
            customer_phone=patient_phone,
            destination=patient_destination,
            diagnosis=patient_diagnosis,
            prescription_image_path=prescription_path,
            created_at=sale_datetime
        )
        db.session.add(sale)
        db.session.flush()
        
        # Create ControlledSaleItem records and deduct stock
        for idx, (cd, qty, unit_price) in enumerate(resolved_items):
            db.session.add(ControlledSaleItem(
                sale_id=sale.id,
                controlled_drug_id=cd.id,
                controlled_drug_name=cd.name,
                controlled_drug_specification=cd.specification or '',
                individual_sale_number=f"{sale_number}-{idx + 1:02d}",
                description=f"Controlled inventory sale: {cd.name}",
                prescription_source='inventory',
                prescription_sheet_path=prescription_path,
                quantity=int(qty),
                unit_price=float(unit_price),
                total_price=float(unit_price) * int(qty),
                created_at=get_eat_now()
            ))
            
            # Deduct from remaining quantity
            cd.remaining_quantity = (cd.remaining_quantity or 0) - int(qty)
            cd.sold_quantity = (cd.sold_quantity or 0) + int(qty)
            db.session.add(cd)
        
        # Generate receipt HTML before committing so we can store it and post to the ledger atomically.
        receipt_html = ''
        try:
            db.session.flush()
            sale_for_receipt = db.session.query(ControlledSale).options(
                db.joinedload(ControlledSale.user),
                db.joinedload(ControlledSale.items)
            ).filter(ControlledSale.id == sale.id).first()
            receipt_html = render_template('pharmacist/controlled_receipt_simple.html', sale=sale_for_receipt)
            sale.receipt_html = receipt_html
            db.session.add(sale)
        except Exception as e:
            current_app.logger.error(f"Failed to generate controlled receipt: {str(e)}", exc_info=True)

        # Post into ledger (golden rule) - required
        _ensure_controlled_sale_transaction(sale, receipt_html=receipt_html or None)
        
        # Log audit
        try:
            log_audit('controlled_sale', 'ControlledSale', sale.id, None, {
                'sale_number': sale.sale_number,
                'total_amount': sale.total_amount,
                'patient_name': patient_name,
            })
        except Exception:
            pass
        
        return jsonify({
            'success': True,
            'sale_id': sale.id,
            'receipt_number': sale.sale_number,
            'total_amount': sale.total_amount,
            'receipt_html': receipt_html
        })
    
    except ValueError as ve:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(ve)}), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error processing controlled sale: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to process controlled sale'}), 500


@app.route('/pharmacist/dosage')
@login_required
def pharmacist_dosage():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    dosages = DrugDosage.query.join(Drug).all()
    drugs = Drug.query.all()
    
    return render_template('pharmacist/dosage.html', dosages=dosages, drugs=drugs)

@app.route('/pharmacist/dosage/<int:dosage_id>')
@login_required
def pharmacist_get_dosage(dosage_id):
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    dosage = _db_get_or_404(DrugDosage, dosage_id)
    
    return jsonify({
        'id': dosage.id,
        'drug': {
            'id': dosage.drug_record.id,
            'drug_number': dosage.drug_record.drug_number,
            'name': dosage.drug_record.name
        },
        'indication': dosage.indication,
        'contraindication': dosage.contraindication,
        'interaction': dosage.interaction,
        'side_effects': dosage.side_effects,
        'dosage_peds': dosage.dosage_peds,
        'dosage_adults': dosage.dosage_adults,
        'dosage_geriatrics': dosage.dosage_geriatrics,
        'important_notes': dosage.important_notes
    })

@app.route('/pharmacist/drugs/without-dosage')
@login_required
def pharmacist_get_drugs_without_dosage():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    drugs = Drug.query.filter(~Drug.dosages.any()).all()
    
    return jsonify([{
        'id': drug.id,
        'drug_number': drug.drug_number,
        'name': drug.name
    } for drug in drugs])

@app.route('/pharmacist/drugs/<int:drug_id>/dosage')
@login_required
def pharmacist_get_drug_dosage(drug_id):
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    drug = _db_get_or_404(Drug, drug_id)
    dosage = DrugDosage.query.filter_by(drug_id=drug.id).first()
    
    return jsonify({
        'drug': {
            'id': drug.id,
            'name': drug.name,
            'drug_number': drug.drug_number
        },
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/pharmacist/drug/<int:drug_id>/dosage')
@login_required
def pharmacist_get_drug_dosage_alias(drug_id):
    """Alias for older JS callers using singular path."""
    return pharmacist_get_drug_dosage(drug_id)


@app.route('/pharmacist/controlled-drugs/<int:drug_id>/dosage')
@login_required
def pharmacist_get_controlled_drug_dosage(drug_id):
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    drug = _db_get_or_404(ControlledDrug, drug_id)
    dosage = ControlledDrugDosage.query.filter_by(controlled_drug_id=drug.id).first()
    return jsonify({
        'drug': {
            'id': drug.id,
            'name': drug.name,
            'drug_number': drug.controlled_drug_number
        },
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/admin/controlled-dosage', methods=['GET', 'POST'])
@login_required
def manage_controlled_dosage():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if request.method == 'POST':
        action = request.form.get('action')

        if action == 'add':
            try:
                dosage = ControlledDrugDosage(
                    controlled_drug_id=request.form.get('controlled_drug_id'),
                    source='manual',
                    indication=request.form.get('indication'),
                    contraindication=request.form.get('contraindication'),
                    interaction=request.form.get('interaction'),
                    side_effects=request.form.get('side_effects'),
                    dosage_peds=request.form.get('dosage_peds'),
                    dosage_adults=request.form.get('dosage_adults'),
                    dosage_geriatrics=request.form.get('dosage_geriatrics'),
                    important_notes=request.form.get('important_notes')
                )
                db.session.add(dosage)
                db.session.commit()
                flash('Controlled drug dosage information added successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error adding controlled drug dosage: {str(e)}', 'danger')

        elif action == 'edit':
            dosage_id = request.form.get('dosage_id')
            dosage = _db_get(ControlledDrugDosage, dosage_id)
            if dosage:
                try:
                    dosage.indication = request.form.get('indication')
                    dosage.contraindication = request.form.get('contraindication')
                    dosage.interaction = request.form.get('interaction')
                    dosage.side_effects = request.form.get('side_effects')
                    dosage.dosage_peds = request.form.get('dosage_peds')
                    dosage.dosage_adults = request.form.get('dosage_adults')
                    dosage.dosage_geriatrics = request.form.get('dosage_geriatrics')
                    dosage.important_notes = request.form.get('important_notes')
                    try:
                        dosage.source = 'manual'
                    except Exception:
                        pass
                    db.session.commit()
                    flash('Controlled drug dosage information updated successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error updating controlled drug dosage: {str(e)}', 'danger')
            else:
                flash('Controlled drug dosage information not found', 'danger')

        elif action == 'delete':
            dosage_id = request.form.get('dosage_id')
            dosage = _db_get(ControlledDrugDosage, dosage_id)
            if dosage:
                try:
                    db.session.delete(dosage)
                    db.session.commit()
                    flash('Controlled drug dosage information deleted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error deleting controlled drug dosage: {str(e)}', 'danger')
            else:
                flash('Controlled drug dosage information not found', 'danger')

        return redirect(url_for('manage_controlled_dosage'))

    dosages = ControlledDrugDosage.query.join(ControlledDrug).all()
    drugs = ControlledDrug.query.all()

    total_drugs = ControlledDrug.query.count()
    drugs_with_dosage = ControlledDrug.query.filter(ControlledDrug.dosages.any()).count()
    drugs_without_dosage = max(0, total_drugs - drugs_with_dosage)
    ai_generated = 0
    try:
        ai_generated = ControlledDrugDosage.query.filter(ControlledDrugDosage.source == 'ai').count()
    except Exception:
        ai_generated = 0
    return render_template(
        'admin/controlled_dosage.html',
        dosages=dosages,
        drugs=drugs,
        ai_dosage_agent_enabled=_get_ai_dosage_agent_enabled(),
        stats={
            'total_drugs': total_drugs,
            'with_dosage': drugs_with_dosage,
            'without_dosage': drugs_without_dosage,
            'ai_generated': ai_generated,
        },
    )


@app.route('/admin/controlled-dosage/<int:dosage_id>')
@login_required
def admin_get_controlled_dosage(dosage_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    dosage = _db_get_or_404(ControlledDrugDosage, dosage_id)
    return jsonify({
        'id': dosage.id,
        'drug': {
            'id': dosage.controlled_drug_record.id,
            'drug_number': dosage.controlled_drug_record.controlled_drug_number,
            'name': dosage.controlled_drug_record.name,
        },
        'indication': dosage.indication,
        'contraindication': dosage.contraindication,
        'interaction': dosage.interaction,
        'side_effects': dosage.side_effects,
        'dosage_peds': dosage.dosage_peds,
        'dosage_adults': dosage.dosage_adults,
        'dosage_geriatrics': dosage.dosage_geriatrics,
        'important_notes': dosage.important_notes,
    })


@app.route('/admin/controlled-drugs/without-dosage')
@login_required
def admin_get_controlled_drugs_without_dosage():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    drugs = ControlledDrug.query.filter(~ControlledDrug.dosages.any()).all()
    return jsonify([{
        'id': d.id,
        'drug_number': d.controlled_drug_number,
        'name': d.name,
    } for d in drugs])


@app.route('/admin/controlled-drugs/<int:drug_id>/dosage')
@login_required
def admin_get_controlled_drug_dosage(drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    drug = _db_get_or_404(ControlledDrug, drug_id)
    dosage = ControlledDrugDosage.query.filter_by(controlled_drug_id=drug.id).first()
    return jsonify({
        'drug': {
            'id': drug.id,
            'name': drug.name,
            'drug_number': drug.controlled_drug_number,
        },
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes,
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/admin/controlled-dosage/load-index-book', methods=['POST'])
@login_required
def admin_load_controlled_dosage_index_book():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    entries = _load_dosage_index_book()
    if not entries:
        flash('Dosage index book not found or empty. Place it at instance/dosage_index.json or static/dosage_index.json', 'warning')
        return redirect(url_for('manage_controlled_dosage'))

    name_map = { _normalize_drug_name(e.get('name')): e for e in entries if e.get('name') }
    created = 0
    try:
        drugs = ControlledDrug.query.filter(~ControlledDrug.dosages.any()).all()
        for drug in drugs:
            e = name_map.get(_normalize_drug_name(drug.name))
            if not e:
                continue
            d = ControlledDrugDosage(
                controlled_drug_id=drug.id,
                indication=e.get('indication'),
                contraindication=e.get('contraindication'),
                interaction=e.get('interaction'),
                side_effects=e.get('side_effects'),
                dosage_peds=e.get('dosage_peds'),
                dosage_adults=e.get('dosage_adults'),
                dosage_geriatrics=e.get('dosage_geriatrics'),
                important_notes=e.get('important_notes'),
            )
            db.session.add(d)
            created += 1
        db.session.commit()
        flash(f'Loaded {created} controlled drug dosage entries from index book.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Failed to load controlled dosage index book: {str(e)}', 'danger')

    return redirect(url_for('manage_controlled_dosage'))


@app.route('/admin/dosage/assistant-suggest')
@login_required
def admin_ai_suggest_dosage():
    """Admin-only helper that returns suggested dosage fields for a drug.

    Query params:
      kind=drug|controlled
      drug_id=<int>
    """
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    kind = (request.args.get('kind') or 'drug').strip().lower()
    try:
        drug_id = int(request.args.get('drug_id') or 0)
    except Exception:
        drug_id = 0

    if kind not in ('drug', 'controlled') or drug_id <= 0:
        return jsonify({'error': 'Invalid request'}), 400

    if kind == 'drug':
        drug = _db_get_or_404(Drug, drug_id)
        existing = DrugDosage.query.filter_by(drug_id=drug.id).first()
        try:
            structured = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
        except (APIConnectionError, APITimeoutError) as e:
            return jsonify({'error': 'AI service unavailable', 'message': f"{type(e).__name__}: {str(e)}"}), 503
        return jsonify({
            'kind': 'drug',
            'drug': {'id': drug.id, 'name': drug.name, 'drug_number': drug.drug_number},
            'suggested': structured,
            'existing': {
                'indication': existing.indication if existing else None,
                'contraindication': existing.contraindication if existing else None,
                'interaction': existing.interaction if existing else None,
                'side_effects': existing.side_effects if existing else None,
                'dosage_peds': existing.dosage_peds if existing else None,
                'dosage_adults': existing.dosage_adults if existing else None,
                'dosage_geriatrics': existing.dosage_geriatrics if existing else None,
                'important_notes': existing.important_notes if existing else None,
            }
        })

    drug = _db_get_or_404(ControlledDrug, drug_id)
    existing = ControlledDrugDosage.query.filter_by(controlled_drug_id=drug.id).first()
    try:
        structured = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
    except (APIConnectionError, APITimeoutError) as e:
        return jsonify({'error': 'AI service unavailable', 'message': f"{type(e).__name__}: {str(e)}"}), 503
    return jsonify({
        'kind': 'controlled',
        'drug': {'id': drug.id, 'name': drug.name, 'drug_number': drug.controlled_drug_number},
        'suggested': structured,
        'existing': {
            'indication': existing.indication if existing else None,
            'contraindication': existing.contraindication if existing else None,
            'interaction': existing.interaction if existing else None,
            'side_effects': existing.side_effects if existing else None,
            'dosage_peds': existing.dosage_peds if existing else None,
            'dosage_adults': existing.dosage_adults if existing else None,
            'dosage_geriatrics': existing.dosage_geriatrics if existing else None,
            'important_notes': existing.important_notes if existing else None,
        }
    })


@app.route('/admin/dosage/assistant-fill-missing', methods=['POST'])
@login_required
def admin_ai_fill_missing_dosage_fields():
    """Admin-only batch helper: fills ONLY missing dosage fields using AI generation (+ optional local index-book context).

    Does not overwrite any non-empty fields.
    """
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    kind = (request.form.get('kind') or 'drug').strip().lower()
    if kind not in ('drug', 'controlled'):
        flash('Invalid dosage kind', 'danger')
        return redirect(url_for('manage_dosage'))

    # Keep this conservative to avoid timeouts.
    try:
        limit = int(request.form.get('limit') or 50)
    except Exception:
        limit = 50
    limit = max(1, min(limit, 50))

    updated_records = 0
    updated_fields = 0
    processed = 0
    error_count = 0

    try:
        if kind == 'drug':
            rows = DrugDosage.query.join(Drug).all()
            for dosage in rows:
                if processed >= limit:
                    break
                try:
                    missing_any = any([
                        _is_blank(dosage.indication),
                        _is_blank(dosage.contraindication),
                        _is_blank(dosage.interaction),
                        _is_blank(dosage.side_effects),
                        _is_blank(dosage.dosage_peds),
                        _is_blank(dosage.dosage_adults),
                        _is_blank(dosage.dosage_geriatrics),
                        _is_blank(dosage.important_notes),
                    ])
                    if not missing_any:
                        continue

                    processed += 1
                    drug = dosage.drug_record
                    suggestion = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
                    if not isinstance(suggestion, dict):
                        continue

                    before = updated_fields
                    if _is_blank(dosage.indication) and suggestion.get('indication'):
                        dosage.indication = suggestion.get('indication'); updated_fields += 1
                    if _is_blank(dosage.contraindication) and suggestion.get('contraindication'):
                        dosage.contraindication = suggestion.get('contraindication'); updated_fields += 1
                    if _is_blank(dosage.interaction) and suggestion.get('interaction'):
                        dosage.interaction = suggestion.get('interaction'); updated_fields += 1
                    if _is_blank(dosage.side_effects) and suggestion.get('side_effects'):
                        dosage.side_effects = suggestion.get('side_effects'); updated_fields += 1
                    if _is_blank(dosage.dosage_peds) and suggestion.get('dosage_peds'):
                        dosage.dosage_peds = suggestion.get('dosage_peds'); updated_fields += 1
                    if _is_blank(dosage.dosage_adults) and suggestion.get('dosage_adults'):
                        dosage.dosage_adults = suggestion.get('dosage_adults'); updated_fields += 1
                    if _is_blank(dosage.dosage_geriatrics) and suggestion.get('dosage_geriatrics'):
                        dosage.dosage_geriatrics = suggestion.get('dosage_geriatrics'); updated_fields += 1
                    if _is_blank(dosage.important_notes) and suggestion.get('important_notes'):
                        dosage.important_notes = suggestion.get('important_notes'); updated_fields += 1

                    if updated_fields > before:
                        updated_records += 1
                        try:
                            dosage.source = 'ai'
                        except Exception:
                            pass
                except Exception:
                    error_count += 1

        else:
            rows = ControlledDrugDosage.query.join(ControlledDrug).all()
            for dosage in rows:
                if processed >= limit:
                    break
                try:
                    missing_any = any([
                        _is_blank(dosage.indication),
                        _is_blank(dosage.contraindication),
                        _is_blank(dosage.interaction),
                        _is_blank(dosage.side_effects),
                        _is_blank(dosage.dosage_peds),
                        _is_blank(dosage.dosage_adults),
                        _is_blank(dosage.dosage_geriatrics),
                        _is_blank(dosage.important_notes),
                    ])
                    if not missing_any:
                        continue

                    processed += 1
                    drug = dosage.controlled_drug_record
                    suggestion = _ai_generate_dosage_fields_from_name(drug.name, context_entry=None)
                    if not isinstance(suggestion, dict):
                        continue

                    before = updated_fields
                    if _is_blank(dosage.indication) and suggestion.get('indication'):
                        dosage.indication = suggestion.get('indication'); updated_fields += 1
                    if _is_blank(dosage.contraindication) and suggestion.get('contraindication'):
                        dosage.contraindication = suggestion.get('contraindication'); updated_fields += 1
                    if _is_blank(dosage.interaction) and suggestion.get('interaction'):
                        dosage.interaction = suggestion.get('interaction'); updated_fields += 1
                    if _is_blank(dosage.side_effects) and suggestion.get('side_effects'):
                        dosage.side_effects = suggestion.get('side_effects'); updated_fields += 1
                    if _is_blank(dosage.dosage_peds) and suggestion.get('dosage_peds'):
                        dosage.dosage_peds = suggestion.get('dosage_peds'); updated_fields += 1
                    if _is_blank(dosage.dosage_adults) and suggestion.get('dosage_adults'):
                        dosage.dosage_adults = suggestion.get('dosage_adults'); updated_fields += 1
                    if _is_blank(dosage.dosage_geriatrics) and suggestion.get('dosage_geriatrics'):
                        dosage.dosage_geriatrics = suggestion.get('dosage_geriatrics'); updated_fields += 1
                    if _is_blank(dosage.important_notes) and suggestion.get('important_notes'):
                        dosage.important_notes = suggestion.get('important_notes'); updated_fields += 1

                    if updated_fields > before:
                        updated_records += 1
                        try:
                            dosage.source = 'ai'
                        except Exception:
                            pass
                except Exception:
                    error_count += 1

        db.session.commit()
        msg = f'AI agent processed {processed} record(s); updated {updated_records} record(s); filled {updated_fields} missing field(s).'
        if error_count:
            msg += f' Skipped {error_count} record(s) due to errors.'
        msg += ' Please review before clinical use.'
        flash(msg, 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'AI agent failed: {str(e)}', 'danger')

    return redirect(url_for('manage_controlled_dosage' if kind == 'controlled' else 'manage_dosage'))


@app.route('/admin/dosage/assistant-agent/toggle', methods=['POST'])
@login_required
def admin_toggle_ai_dosage_agent():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    enabled = (request.form.get('enabled') or '').strip().lower() in ('1', 'true', 'yes', 'on')
    _set_ai_dosage_agent_enabled(enabled)
    flash(f"AI dosage agent is now {'ENABLED' if enabled else 'DISABLED'}.", 'success' if enabled else 'warning')
    return redirect(request.referrer or url_for('manage_dosage'))


@app.route('/admin/dosage/assistant-agent/run-now', methods=['POST'])
@login_required
def admin_run_ai_dosage_agent_now():
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if not _get_ai_dosage_agent_enabled():
        flash('AI dosage agent is disabled. Enable it first to run.', 'warning')
        return redirect(request.referrer or url_for('manage_dosage'))

    kind = (request.form.get('kind') or 'both').strip().lower()
    if kind not in ('drug', 'controlled', 'both'):
        kind = 'both'

    try:
        result = run_ai_dosage_agent_once(
            kind=kind,
            create_limit=50,
            update_limit=50,
            ai_generation_limit=50,
            max_run_seconds=300,
        )
        app.logger.info(f"AI dosage agent result: {result}")
        reason = result.get('reason', '')
        msg = f"AI dosage agent (kind={kind}): created {result.get('created', 0)}, updated {result.get('updated_records', 0)}, filled {result.get('filled_fields', 0)} fields."
        if reason:
            msg += f" Reason: {reason}"
        else:
            msg += f" AI budget remaining: {result.get('ai_generation_remaining', 0)}. Errors: {result.get('errors', 0)}."
        flash(msg, 'warning' if reason else 'success')
    except Exception as e:
        try:
            db.session.rollback()
        except Exception:
            pass
        flash(f'AI dosage agent run failed: {str(e)}', 'danger')

    return redirect(request.referrer or url_for('manage_dosage'))


@app.route('/admin/dosage/assistant-agent/start-job', methods=['POST'])
@login_required
def admin_start_ai_dosage_agent_job():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    if not _get_ai_dosage_agent_enabled():
        return jsonify({'error': 'AI dosage agent is disabled. Enable it first.'}), 400

    kind = (request.form.get('kind') or 'drug').strip().lower()
    if kind not in ('drug', 'controlled'):
        kind = 'drug'

    mode = (request.form.get('mode') or 'full').strip().lower()
    if mode not in ('full', 'fill'):
        mode = 'full'

    if current_app.config.get('FAST_DEV'):
        return jsonify({'error': 'FAST_DEV enabled: AI dosage jobs are disabled.'}), 503

    try:
        limit = int(request.form.get('limit') or 10)
    except Exception:
        limit = 10
    limit = max(1, min(limit, 25))

    job_id = str(uuid.uuid4())
    initial = {
        'job_id': job_id,
        'kind': kind,
        'mode': mode,
        'requested_by_user_id': current_user.id,
        'status': 'starting',
        'total': int(limit),
        'processed': 0,
        'completed': 0,
        'failed': 0,
        'created': 0,
        'updated_records': 0,
        'filled_fields': 0,
        'errors': 0,
        'updates': [],
        'update_seq': 0,
        'started_at': get_eat_now().isoformat(),
        'updated_at': get_eat_now().isoformat(),
    }
    _write_ai_job_state(job_id, initial)

    t = threading.Thread(
        target=_ai_dosage_job_thread,
        kwargs={
            'job_id': job_id,
            'kind': kind,
            'mode': mode,
            'limit': limit,
            'requested_by_user_id': current_user.id,
        },
        daemon=True,
    )
    t.start()

    # Total gets recalculated by the runner based on availability/budget.
    return jsonify({'job_id': job_id})


@app.route('/admin/dosage/assistant-agent/job/<job_id>/status')
@login_required
def admin_ai_dosage_agent_job_status(job_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    state = _read_ai_job_state(job_id)
    if not state:
        return jsonify({'error': 'Job not found'}), 404
    if int(state.get('requested_by_user_id') or 0) != int(current_user.id):
        return jsonify({'error': 'Forbidden'}), 403

    try:
        since = int(request.args.get('since') or 0)
    except Exception:
        since = 0
    updates = [u for u in (state.get('updates') or []) if int(u.get('seq') or 0) > since]

    total = int(state.get('total') or 0)
    processed = int(state.get('processed') or 0)
    remaining = max(0, total - processed)

    complete_url = url_for('admin_ai_dosage_agent_job_complete', job_id=job_id)
    return jsonify({
        'job_id': job_id,
        'status': state.get('status') or 'unknown',
        'kind': state.get('kind'),
        'mode': state.get('mode'),
        'total': total,
        'processed': processed,
        'completed': int(state.get('completed') or 0),
        'failed': int(state.get('failed') or 0),
        'remaining': remaining,
        'created': int(state.get('created') or 0),
        'updated_records': int(state.get('updated_records') or 0),
        'filled_fields': int(state.get('filled_fields') or 0),
        'errors': int(state.get('errors') or 0),
        'message': state.get('message') or '',
        'updates': updates,
        'last_seq': int(state.get('update_seq') or 0),
        'complete_url': complete_url,
    })


@app.route('/admin/dosage/assistant-agent/job/<job_id>/complete')
@login_required
def admin_ai_dosage_agent_job_complete(job_id):
    if current_user.role != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    state = _read_ai_job_state(job_id)
    if not state:
        flash('AI job not found', 'danger')
        return redirect(url_for('manage_dosage'))
    if int(state.get('requested_by_user_id') or 0) != int(current_user.id):
        flash('Forbidden', 'danger')
        return redirect(url_for('manage_dosage'))

    status = state.get('status') or 'unknown'
    kind = state.get('kind') or 'drug'
    created = int(state.get('created') or 0)
    updated_records = int(state.get('updated_records') or 0)
    filled_fields = int(state.get('filled_fields') or 0)
    failed = int(state.get('failed') or 0)
    errors = int(state.get('errors') or 0)
    total = int(state.get('total') or 0)
    processed = int(state.get('processed') or 0)

    if status == 'failed':
        msg = f'AI dosage generation failed: processed {processed}/{total}. Errors: {errors}. {state.get("message") or ""}'
        flash(msg, 'danger')
    else:
        msg = (
            f'AI dosage generation complete: processed {processed}/{total}; '
            f'created {created}, updated {updated_records}, filled {filled_fields} field(s); '
            f'failed {failed}, errors {errors}.'
        )
        flash(msg, 'success' if errors == 0 and failed == 0 else 'warning')

    return redirect(url_for('manage_controlled_dosage' if kind == 'controlled' else 'manage_dosage'))


@app.route('/doctor/drugs/<int:drug_id>/dosage')
@login_required
def doctor_get_drug_dosage(drug_id):
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403
    drug = _db_get_or_404(Drug, drug_id)
    dosage = DrugDosage.query.filter_by(drug_id=drug.id).first()
    return jsonify({
        'drug': {'id': drug.id, 'name': drug.name, 'drug_number': drug.drug_number},
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes,
        } if dosage else None,
        'source': 'db' if dosage else None
    })


@app.route('/doctor/controlled-drugs/<int:drug_id>/dosage')
@login_required
def doctor_get_controlled_drug_dosage(drug_id):
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403
    drug = _db_get_or_404(ControlledDrug, drug_id)
    dosage = ControlledDrugDosage.query.filter_by(controlled_drug_id=drug.id).first()
    return jsonify({
        'drug': {'id': drug.id, 'name': drug.name, 'drug_number': drug.controlled_drug_number},
        'dosage': {
            'indication': dosage.indication,
            'contraindication': dosage.contraindication,
            'interaction': dosage.interaction,
            'side_effects': dosage.side_effects,
            'dosage_peds': dosage.dosage_peds,
            'dosage_adults': dosage.dosage_adults,
            'dosage_geriatrics': dosage.dosage_geriatrics,
            'important_notes': dosage.important_notes,
        } if dosage else None,
        'source': 'db' if dosage else None
    })

@app.route('/pharmacist/inventory')
@login_required
def pharmacist_inventory():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        drugs = Drug.query.options(db.joinedload(Drug.dosages)).order_by(Drug.name).all()
        
        total_drugs = Drug.query.count()
        low_stock = Drug.query.filter(Drug.remaining_quantity < 10, Drug.remaining_quantity > 0).count()
        expiring_soon = Drug.query.filter(
            Drug.expiry_date <= date.today() + timedelta(days=30),
            Drug.expiry_date >= date.today()
        ).count()
        out_of_stock = Drug.query.filter(Drug.remaining_quantity == 0).count()
        
        return render_template('pharmacist/inventory.html',
            drugs=drugs,
            total_drugs=total_drugs,
            low_stock=low_stock,
            expiring_soon=expiring_soon,
            out_of_stock=out_of_stock
        )
        
    except Exception as e:
        current_app.logger.error(f"Error loading inventory: {str(e)}")
        flash('An error occurred while loading inventory', 'danger')
        return redirect(url_for('pharmacist_dashboard'))


@app.route('/pharmacist/controlled-inventory')
@login_required
def pharmacist_controlled_inventory():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    try:
        search_query = (request.args.get('search') or '').strip()
        filter_type = (request.args.get('filter') or 'all').strip()
        is_embed = request.args.get('embed') == '1'

        query = ControlledDrug.query

        if filter_type == 'in':
            query = query.filter(ControlledDrug.remaining_quantity > 0)
        elif filter_type == 'low':
            query = query.filter(ControlledDrug.remaining_quantity < 10, ControlledDrug.remaining_quantity > 0)
        elif filter_type == 'out':
            query = query.filter(ControlledDrug.remaining_quantity == 0)

        if search_query:
            like = f"%{search_query}%"
            query = query.filter(or_(
                ControlledDrug.name.ilike(like),
                ControlledDrug.controlled_drug_number.ilike(like),
                ControlledDrug.specification.ilike(like),
            ))

        controlled_drugs = query.order_by(ControlledDrug.name).all()

        controlled_sales = db.session.query(ControlledSale).options(
            db.joinedload(ControlledSale.patient)
        ).filter(
            ControlledSale.status == 'completed'
        ).order_by(
            ControlledSale.created_at.desc()
        ).limit(50).all()
        return render_template(
            'pharmacist/controlled_inventory.html',
            controlled_drugs=controlled_drugs,
            search_query=search_query,
            filter_type=filter_type,
            controlled_sales=controlled_sales,
            is_embed=is_embed,
        )
    except Exception as e:
        current_app.logger.error(f"Error loading controlled inventory: {str(e)}")
        flash('An error occurred while loading controlled inventory', 'danger')
        return redirect(url_for('pharmacist_dashboard'))


@app.route('/pharmacist/api/controlled-prescriptions')
@login_required
def pharmacist_get_controlled_prescriptions():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        prescriptions = db.session.query(ControlledPrescription).options(
            db.joinedload(ControlledPrescription.patient),
            db.joinedload(ControlledPrescription.doctor),
            db.joinedload(ControlledPrescription.items).joinedload(ControlledPrescriptionItem.controlled_drug),
        ).order_by(ControlledPrescription.created_at.desc()).all()

        data = []
        for p in prescriptions:
            patient_name = 'Unknown Patient'
            try:
                if p.patient and hasattr(p.patient, 'get_decrypted_name'):
                    patient_name = p.patient.get_decrypted_name
                elif p.patient:
                    patient_name = str(p.patient)
            except Exception:
                patient_name = 'Error loading patient'

            data.append({
                'id': p.id,
                'patient_name': patient_name,
                'patient_number': p.patient.op_number or p.patient.ip_number if p.patient else 'N/A',
                'doctor_name': p.doctor.username if p.doctor else 'Unknown Doctor',
                'status': p.status,
                'created_at': p.created_at.strftime('%Y-%m-%d %H:%M') if p.created_at else '',
                'item_count': len(p.items) if p.items else 0,
            })
        return jsonify(data)
    except Exception as e:
        current_app.logger.error(f"Error fetching controlled prescriptions: {str(e)}")
        return jsonify({'error': 'Failed to fetch controlled prescriptions'}), 500


@app.route('/pharmacist/api/controlled-prescription/<int:prescription_id>')
@login_required
def pharmacist_get_controlled_prescription_details(prescription_id):
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        p = db.session.query(ControlledPrescription).options(
            db.joinedload(ControlledPrescription.items).joinedload(ControlledPrescriptionItem.controlled_drug),
            db.joinedload(ControlledPrescription.patient),
            db.joinedload(ControlledPrescription.doctor),
        ).filter(ControlledPrescription.id == prescription_id).first()

        if not p:
            return jsonify({'error': 'Controlled prescription not found'}), 404

        patient_name = 'Unknown Patient'
        try:
            if p.patient and hasattr(p.patient, 'get_decrypted_name'):
                patient_name = p.patient.get_decrypted_name
            elif p.patient:
                patient_name = str(p.patient)
        except Exception:
            patient_name = 'Error loading patient'

        items = []
        for item in p.items:
            cd = item.controlled_drug
            items.append({
                'id': item.id,
                'controlled_drug_id': item.controlled_drug_id,
                'controlled_drug_name': cd.name if cd else 'Unknown Drug',
                'controlled_drug_number': cd.controlled_drug_number if cd else 'N/A',
                'quantity': item.quantity,
                'dosage': item.dosage or '',
                'frequency': item.frequency or '',
                'duration': item.duration or '',
                'notes': item.notes or '',
                'remaining_quantity': cd.remaining_quantity if cd else 0,
                'status': item.status,
            })

        return jsonify({
            'id': p.id,
            'patient_id': p.patient_id,
            'patient_name': patient_name,
            'patient_number': p.patient.op_number or p.patient.ip_number if p.patient else 'N/A',
            'doctor_name': p.doctor.username if p.doctor else 'Unknown Doctor',
            'notes': p.notes or '',
            'status': p.status,
            'created_at': p.created_at.strftime('%Y-%m-%d %H:%M') if p.created_at else 'Unknown Date',
            'items': items,
        })
    except Exception as e:
        current_app.logger.error(f"Error fetching controlled prescription details: {str(e)}")
        return jsonify({'error': 'Failed to fetch controlled prescription details'}), 500


@app.route('/pharmacist/controlled/dispense', methods=['POST'])
@login_required
def pharmacist_controlled_dispense():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        data = request.get_json() or {}
        prescription_id = data.get('controlled_prescription_id')
        # Payment is handled by receptionist billing; pharmacists only dispense.
        # Keep accepting the field for backward-compatible frontend payloads.
        _ = data.get('payment_method', None)
        prescription_sheet_path = (data.get('prescription_sheet_path') or data.get('prescription_image_path') or '').strip() or None

        if not prescription_id:
            return jsonify({'error': 'Controlled prescription ID is required'}), 400

        p = db.session.query(ControlledPrescription).options(
            db.joinedload(ControlledPrescription.items).joinedload(ControlledPrescriptionItem.controlled_drug),
            db.joinedload(ControlledPrescription.patient),
        ).filter(ControlledPrescription.id == prescription_id).first()

        if not p:
            return jsonify({'error': 'Controlled prescription not found'}), 404
        if p.status != 'pending':
            return jsonify({'error': 'Controlled prescription has already been processed'}), 400

        # Verify stock
        for item in p.items:
            if not item.controlled_drug:
                return jsonify({'error': 'Controlled drug missing on prescription item'}), 400
            if item.controlled_drug.remaining_quantity < item.quantity:
                return jsonify({
                    'error': f'Insufficient stock for {item.controlled_drug.name}',
                    'details': f'Requested: {item.quantity}, Available: {item.controlled_drug.remaining_quantity}',
                    'controlled_drug_id': item.controlled_drug.id
                }), 400

        for item in p.items:
            cd = item.controlled_drug
            qty = int(item.quantity)
            cd.sold_quantity = (cd.sold_quantity or 0) + qty
            db.session.add(cd)
            item.status = 'dispensed'

        p.status = 'dispensed'
        p.dispensed_by = current_user.id
        p.dispensed_at = get_eat_now()

        db.session.commit()

        try:
            log_audit('dispense_controlled_prescription', 'ControlledPrescription', p.id, None, {
                'patient_id': p.patient_id,
                'items_count': len(p.items or []),
                'prescription_sheet_path': prescription_sheet_path,
                'note': 'Dispensed only; billing handled by receptionist'
            })
        except Exception:
            pass

        return jsonify({
            'success': True,
            'sale_id': None,
            'sale_number': None,
            'total_amount': 0,
            'receipt_url': None,
            'message': 'Controlled prescription dispensed successfully. Please proceed to reception for billing.'
        })

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error dispensing controlled prescription: {str(e)}", exc_info=True)
        return jsonify({'error': 'Failed to dispense controlled prescription', 'details': str(e)}), 500


@app.route('/pharmacist/controlled/external-sale', methods=['POST'])
@login_required
def pharmacist_controlled_external_sale():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    try:
        controlled_drug_id = request.form.get('controlled_drug_id', type=int)
        quantity = request.form.get('quantity', type=int)
        patient_id = request.form.get('patient_id', type=int)
        payment_method = request.form.get('payment_method', 'cash')
        # Legacy endpoint: now restricted to camera-captured images only.
        # The frontend no longer provides file upload input; it captures from camera.
        sheet = request.files.get('prescription_image') or request.files.get('prescription_sheet')

        if not controlled_drug_id or not quantity or quantity <= 0:
            flash('Please select a controlled drug and valid quantity.', 'danger')
            return redirect(url_for('pharmacist_controlled_inventory'))

        if not sheet or not getattr(sheet, 'filename', None):
            flash('Prescription photo is required for external/OTC controlled sales.', 'danger')
            return redirect(url_for('pharmacist_controlled_inventory'))

        cdrug = db.session.get(ControlledDrug, controlled_drug_id)
        if not cdrug:
            flash('Controlled drug not found.', 'danger')
            return redirect(url_for('pharmacist_controlled_inventory'))

        if cdrug.remaining_quantity < quantity:
            flash(f'Insufficient stock for {cdrug.name}. Available: {cdrug.remaining_quantity}', 'danger')
            return redirect(url_for('pharmacist_controlled_inventory'))

        if patient_id:
            patient = db.session.get(Patient, patient_id)
            if not patient:
                flash('Selected patient not found.', 'danger')
                return redirect(url_for('pharmacist_controlled_inventory'))

        sheet_path = _save_prescription_image(sheet)
        sale_number = generate_controlled_sale_number()
        unit_price = float(cdrug.selling_price)
        total_amount = unit_price * quantity

        sale = ControlledSale(
            sale_number=sale_number,
            patient_id=patient_id if patient_id else None,
            user_id=current_user.id,
            pharmacist_name=f"{current_user.username}",
            total_amount=total_amount,
            payment_method=payment_method,
            status='completed',
            notes='External controlled sale',
            prescription_image_path=sheet_path,
            created_at=get_eat_now(),
        )
        db.session.add(sale)
        db.session.flush()

        db.session.add(ControlledSaleItem(
            sale_id=sale.id,
            controlled_drug_id=cdrug.id,
            controlled_drug_name=cdrug.name,
            controlled_drug_specification=cdrug.specification,
            individual_sale_number=f"{sale_number}-01",
            description=f"External controlled sale: {cdrug.name}",
            prescription_source='external',
            prescription_sheet_path=sheet_path,
            quantity=quantity,
            unit_price=unit_price,
            total_price=total_amount,
            created_at=get_eat_now(),
        ))

        cdrug.sold_quantity = (cdrug.sold_quantity or 0) + quantity
        db.session.add(cdrug)

        # Post into ledger (golden rule) - required
        _ensure_controlled_sale_transaction(sale, receipt_html=None)

        try:
            log_audit('external_controlled_sale', 'ControlledSale', sale.id, None, {
                'sale_number': sale.sale_number,
                'patient_id': sale.patient_id,
                'controlled_drug_id': cdrug.id,
                'quantity': quantity,
                'total_amount': total_amount,
                'prescription_sheet_path': sheet_path,
            })
        except Exception:
            pass

        flash('External controlled sale recorded successfully.', 'success')
        return redirect(url_for('pharmacist_controlled_inventory'))

    except ValueError as ve:
        db.session.rollback()
        flash(str(ve), 'danger')
        return redirect(url_for('pharmacist_controlled_inventory'))
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error processing external controlled sale: {str(e)}", exc_info=True)
        flash('Failed to process external controlled sale.', 'danger')
        return redirect(url_for('pharmacist_controlled_inventory'))


@app.route('/pharmacist/controlled/cart-sale', methods=['POST'])
@login_required
def pharmacist_controlled_cart_sale():
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        cart_raw = request.form.get('cart')
        if not cart_raw:
            return jsonify({'success': False, 'error': 'Missing cart payload'}), 400

        try:
            payload = json.loads(cart_raw)
        except Exception:
            return jsonify({'success': False, 'error': 'Invalid cart JSON'}), 400

        items = payload.get('items') or []
        if not items:
            return jsonify({'success': False, 'error': 'Cart is empty'}), 400

        payment_method = payload.get('payment_method', 'cash')
        patient_id = payload.get('patient_id')

        # Required captured metadata
        customer_name = (payload.get('customer_name') or '').strip()
        customer_age = payload.get('customer_age')
        customer_gender = (payload.get('customer_gender') or '').strip()
        customer_phone = (payload.get('customer_phone') or '').strip()
        diagnosis = (payload.get('diagnosis') or '').strip()
        destination = (payload.get('destination') or '').strip()

        if not customer_name or not customer_gender or not customer_phone or not diagnosis or not destination:
            return jsonify({'success': False, 'error': 'Missing required customer details'}), 400

        image = request.files.get('prescription_image')
        if not image or not getattr(image, 'filename', None):
            return jsonify({'success': False, 'error': 'Prescription photo is required (camera capture)'}), 400

        prescription_path = _save_prescription_image(image)

        if patient_id:
            patient = db.session.get(Patient, int(patient_id))
            if not patient:
                return jsonify({'success': False, 'error': 'Selected patient not found'}), 400

        # Validate stock + compute totals
        resolved_items = []
        total_amount = 0.0
        for idx, it in enumerate(items):
            cd_id = it.get('controlled_drug_id')
            qty = int(it.get('quantity') or 0)
            if not cd_id or qty <= 0:
                return jsonify({'success': False, 'error': f'Invalid item at position {idx + 1}'}), 400

            cd = db.session.get(ControlledDrug, int(cd_id))
            if not cd:
                return jsonify({'success': False, 'error': f'Controlled drug not found: {cd_id}'}), 400

            if cd.remaining_quantity < qty:
                return jsonify({'success': False, 'error': f'Insufficient stock for {cd.name}', 'available': cd.remaining_quantity, 'requested': qty, 'controlled_drug_id': cd.id}), 400

            unit_price = float(cd.selling_price)
            line_total = unit_price * qty
            total_amount += line_total
            resolved_items.append((cd, qty, unit_price, it))

        sale_number = generate_controlled_sale_number()
        sale = ControlledSale(
            sale_number=sale_number,
            patient_id=int(patient_id) if patient_id else None,
            user_id=current_user.id,
            pharmacist_name=f"{current_user.username}",
            total_amount=float(total_amount),
            payment_method=payment_method,
            status='completed',
            notes='Controlled cart sale',
            customer_name=customer_name,
            customer_age=int(customer_age) if customer_age not in (None, '') else None,
            customer_gender=customer_gender,
            diagnosis=diagnosis,
            customer_phone=customer_phone,
            destination=destination,
            prescription_image_path=prescription_path,
            created_at=get_eat_now(),
        )
        db.session.add(sale)
        db.session.flush()

        for idx, (cd, qty, unit_price, it) in enumerate(resolved_items):
            db.session.add(ControlledSaleItem(
                sale_id=sale.id,
                controlled_drug_id=cd.id,
                controlled_drug_name=cd.name,
                controlled_drug_specification=cd.specification,
                individual_sale_number=f"{sale_number}-{idx + 1:02d}",
                description=f"Controlled cart sale: {cd.name}",
                prescription_source='external',
                prescription_sheet_path=prescription_path,
                dosage=(it.get('dosage') or '').strip() or None,
                frequency=(it.get('frequency') or '').strip() or None,
                duration=(it.get('duration') or '').strip() or None,
                notes=(it.get('notes') or '').strip() or None,
                quantity=int(qty),
                unit_price=float(unit_price),
                total_price=float(unit_price) * int(qty),
                created_at=get_eat_now(),
            ))

            cd.sold_quantity = (cd.sold_quantity or 0) + int(qty)
            db.session.add(cd)

        receipt_html = None
        try:
            db.session.flush()
            sale_for_receipt = db.session.query(ControlledSale).options(
                db.joinedload(ControlledSale.user),
                db.joinedload(ControlledSale.items),
                db.joinedload(ControlledSale.patient)
            ).filter(ControlledSale.id == sale.id).first()

            receipt_html = render_template('pharmacist/controlled_receipt.html', sale=sale_for_receipt)
            sale.receipt_html = receipt_html
            db.session.add(sale)
        except Exception as e:
            current_app.logger.error(f"Failed to generate controlled receipt HTML: {str(e)}", exc_info=True)

        # Post into ledger (golden rule) - required
        _ensure_controlled_sale_transaction(sale, receipt_html=receipt_html)

        try:
            log_audit('controlled_cart_sale', 'ControlledSale', sale.id, None, {
                'sale_number': sale.sale_number,
                'total_amount': sale.total_amount,
                'payment_method': sale.payment_method,
            })
        except Exception:
            pass

        return jsonify({
            'success': True,
            'sale_id': sale.id,
            'sale_number': sale.sale_number,
            'total_amount': sale.total_amount,
        })

    except ValueError as ve:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(ve)}), 400
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error processing controlled cart sale: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to process controlled sale'}), 500


@app.route('/pharmacist/controlled/sale/<int:sale_id>/receipt')
@login_required
def pharmacist_controlled_sale_receipt(sale_id):
    if current_user.role != 'pharmacist':
        abort(403)

    embedded_requested = request.args.get('embedded') == '1'

    sale = db.session.query(ControlledSale).options(
        db.joinedload(ControlledSale.user),
        db.joinedload(ControlledSale.items),
        db.joinedload(ControlledSale.patient)
    ).filter(ControlledSale.id == sale_id).first()

    if not sale:
        abort(404)

    # Optional cash metadata (when printing/reprinting)
    amount_given = request.args.get('amount_given', type=float)
    change = None
    if amount_given is not None:
        try:
            change = float(amount_given) - float(sale.total_amount or 0)
        except Exception:
            change = None

    if embedded_requested:
        return Response(render_template('pharmacist/controlled_receipt_simple.html', sale=sale, amount_given=amount_given, change=change), mimetype='text/html')

    return render_template('pharmacist/controlled_receipt.html', sale=sale, amount_given=amount_given, change=change)


@app.route('/pharmacist/api/controlled-sales/search')
@login_required
def pharmacist_search_controlled_sales():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    q = (request.args.get('q') or '').strip()

    query = db.session.query(ControlledSale).options(
        db.joinedload(ControlledSale.patient)
    ).order_by(ControlledSale.created_at.desc())

    if q:
        like = f"%{q}%"
        query = query.filter(or_(
            ControlledSale.sale_number.ilike(like),
            ControlledSale.customer_name.ilike(like),
            ControlledSale.customer_phone.ilike(like),
            ControlledSale.diagnosis.ilike(like)
        ))

    sales = query.limit(50).all()
    result = []
    for s in sales:
        patient_name = None
        try:
            if s.patient and hasattr(s.patient, 'get_decrypted_name'):
                patient_name = s.patient.get_decrypted_name
        except Exception:
            patient_name = None

        result.append({
            'id': s.id,
            'sale_number': s.sale_number,
            'created_at': s.created_at.strftime('%Y-%m-%d %H:%M') if s.created_at else '',
            'customer_name': s.customer_name,
            'customer_phone': s.customer_phone,
            'patient_name': patient_name,
            'total_amount': float(s.total_amount or 0),
        })

    return jsonify(result)


@app.route('/admin/controlled/sale/<int:sale_id>/receipt')
@login_required
def admin_controlled_sale_receipt(sale_id):
    if current_user.role != 'admin':
        abort(403)

    sale = db.session.query(ControlledSale).options(
        db.joinedload(ControlledSale.user),
        db.joinedload(ControlledSale.items),
        db.joinedload(ControlledSale.patient)
    ).filter(ControlledSale.id == sale_id).first()

    if not sale:
        abort(404)

    amount_given = request.args.get('amount_given', type=float)
    change = None
    if amount_given is not None:
        try:
            change = float(amount_given) - float(sale.total_amount or 0)
        except Exception:
            change = None

    return render_template('pharmacist/controlled_receipt.html', sale=sale, amount_given=amount_given, change=change)


@app.route('/admin/reports/controlled-sales/export', methods=['GET'])
@login_required
def admin_export_controlled_sales_report():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    start_date_str = request.args.get('start_date')
    end_date_str = request.args.get('end_date')
    if not start_date_str or not end_date_str:
        return jsonify({'error': 'Both start and end dates are required'}), 400

    try:
        start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date() + timedelta(days=1)
    except ValueError:
        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD'}), 400

    rows = db.session.query(ControlledSale, ControlledSaleItem).join(
        ControlledSaleItem, ControlledSale.id == ControlledSaleItem.sale_id
    ).filter(
        ControlledSale.created_at >= start_date,
        ControlledSale.created_at <= end_date,
        ControlledSale.status == 'completed'
    ).order_by(ControlledSale.created_at.desc(), ControlledSaleItem.id.asc()).all()

    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow([
        'Sale Number', 'Date', 'Pharmacist', 'Payment Method', 'Total Amount',
        'Patient Name',
        'Customer Name', 'Customer Age', 'Customer Gender', 'Customer Phone',
        'Diagnosis', 'Destination',
        'Controlled Drug', 'Specification', 'Qty', 'Unit Price', 'Line Total',
        'Dosage', 'Frequency', 'Duration', 'Notes',
        'Prescription Image Path', 'Receipt URL'
    ])

    for sale, item in rows:
        patient_name = ''
        try:
            if sale.patient and sale.patient.name:
                patient_name = str(sale.patient.name)
        except Exception:
            patient_name = ''

        receipt_url = url_for('admin_controlled_sale_receipt', sale_id=sale.id, _external=False)
        writer.writerow([
            sale.sale_number,
            sale.created_at.strftime('%Y-%m-%d %H:%M') if sale.created_at else '',
            sale.pharmacist_name or '',
            sale.payment_method or '',
            float(sale.total_amount or 0),
            patient_name,
            sale.customer_name or '',
            sale.customer_age if sale.customer_age is not None else '',
            sale.customer_gender or '',
            sale.customer_phone or '',
            sale.diagnosis or '',
            sale.destination or '',
            item.controlled_drug_name or '',
            item.controlled_drug_specification or '',
            int(item.quantity or 0),
            float(item.unit_price or 0),
            float(item.total_price or 0),
            getattr(item, 'dosage', None) or '',
            getattr(item, 'frequency', None) or '',
            getattr(item, 'duration', None) or '',
            getattr(item, 'notes', None) or '',
            sale.prescription_image_path or '',
            receipt_url,
        ])

    response = make_response(output.getvalue())
    response.headers['Content-Disposition'] = f'attachment; filename=controlled_drug_sales_{start_date_str}_to_{end_date_str}.csv'
    response.headers['Content-type'] = 'text/csv'

    return response

    
@app.route('/pharmacist/drugs/export')
@login_required
def export_drugs():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    filter_type = request.args.get('filter', 'all')
    search_query = request.args.get('search', '')
    sort_by = request.args.get('sort', 'name_asc')
    
    query = Drug.query
    
    if filter_type == 'low':
        query = query.filter(Drug.remaining_quantity < 10)
    elif filter_type == 'out':
        query = query.filter(Drug.remaining_quantity == 0)
    elif filter_type == 'expiring':
        query = query.filter(Drug.expiry_date <= date.today() + timedelta(days=30))
    
    if search_query:
        query = query.filter(
            or_(
                Drug.name.ilike(f'%{search_query}%'),
                Drug.drug_number.ilike(f'%{search_query}%'),
            )
        )
    
    if sort_by == 'name_asc':
        query = query.order_by(Drug.name.asc())
    elif sort_by == 'name_desc':
        query = query.order_by(Drug.name.desc())
    elif sort_by == 'stock_asc':
        query = query.order_by(Drug.remaining_quantity.asc())
    elif sort_by == 'stock_desc':
        query = query.order_by(Drug.remaining_quantity.desc())
    elif sort_by == 'expiry_asc':
        query = query.order_by(Drug.expiry_date.asc())
    elif sort_by == 'expiry_desc':
        query = query.order_by(Drug.expiry_date.desc())
    
    drugs = query.all()
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    writer.writerow([
        'Drug Number', 'Name', 'Expiry Date', 'Selling Price', 'Stock'
    ])
    
    for drug in drugs:
        if drug.remaining_quantity == 0:
            status = 'Out of Stock'
        elif drug.remaining_quantity < 10:
            status = 'Low Stock'
        else:
            status = 'In Stock'
        
        if drug.expiry_date and (drug.expiry_date <= date.today() + timedelta(days=30)):
            status += ' (Expiring Soon)'
        
        writer.writerow([
            drug.drug_number,
            drug.name,
            drug.expiry_date.strftime('%Y-%m-%d') if drug.expiry_date else '',
            f"Ksh {drug.selling_price:.2f}",
            drug.remaining_quantity,
        ])
    
    response = make_response(output.getvalue())
    response.headers['Content-Disposition'] = 'attachment; filename=drug_inventory.csv'
    response.headers['Content-type'] = 'text/csv'
    
    return response

@app.route('/pharmacist/sales')
@login_required
def pharmacist_sales():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    sales = (
        db.session.query(Sale)
        .options(
            db.joinedload(Sale.items),
            db.joinedload(Sale.patient),
        )
        .order_by(Sale.created_at.desc())
        .limit(50)
        .all()
    )

    wants_json = (
        request.headers.get('X-Requested-With') == 'XMLHttpRequest'
        or request.accept_mimetypes.best == 'application/json'
        or request.args.get('format') == 'json'
    )
    if wants_json:
        rows = []
        for s in sales:
            patient_name = None
            if s.patient:
                patient_name = getattr(s.patient, 'get_decrypted_name', None) or getattr(s.patient, 'name', None)

            created_at_str = None
            try:
                created_at_str = s.created_at.strftime('%Y-%m-%d %H:%M') if s.created_at else None
            except Exception:
                created_at_str = None

            try:
                items_count = len(list(s.items or []))
            except Exception:
                items_count = 0

            rows.append({
                'id': s.id,
                'sale_number': s.sale_number,
                'created_at': created_at_str,
                'patient_name': patient_name,
                'items_count': items_count,
                'total_amount': float(s.total_amount or 0),
            })

        return jsonify(rows)

    return render_template('pharmacist/sales.html', sales=sales)


@app.route('/pharmacist/sale', methods=['POST'])
@login_required
def pharmacist_sale_alias():
    """Compatibility alias for the pharmacist dashboard JS.

    Frontend posts to `/pharmacist/sale`; the canonical handler is `/pharmacist/cart_sale`.
    """
    return process__cart_sale()


@app.route('/api/sales/<string:sale_number>', methods=['GET'])
@login_required
def api_sale_lookup_by_number(sale_number: str):
    """Lookup a sale by sale_number for pharmacist refund UI."""
    if current_user.role not in ['pharmacist', 'admin']:
        return jsonify({'error': 'Unauthorized'}), 403

    sale = (
        db.session.query(Sale)
        .options(
            db.joinedload(Sale.items),
            db.joinedload(Sale.patient),
        )
        .filter((Sale.sale_number == sale_number) | (Sale.bulk_sale_number == sale_number))
        .first()
    )

    if not sale:
        return jsonify({'error': 'Sale not found'}), 404

    patient_name = None
    if sale.patient:
        patient_name = getattr(sale.patient, 'get_decrypted_name', None) or getattr(sale.patient, 'name', None)

    created_at_str = None
    try:
        created_at_str = sale.created_at.strftime('%Y-%m-%d %H:%M') if sale.created_at else None
    except Exception:
        created_at_str = None

    items = []
    for item in (sale.items or []):
        items.append({
            'id': item.id,
            'description': getattr(item, 'description', None) or getattr(item, 'drug_name', None) or 'Item',
            'unit_price': float(item.unit_price or 0),
            'quantity': int(item.quantity or 0),
            'total_price': float(item.total_price or 0),
        })

    return jsonify({
        'id': sale.id,
        'sale_number': sale.sale_number,
        'bulk_sale_number': sale.bulk_sale_number,
        'created_at': created_at_str,
        'patient_name': patient_name,
        'total_amount': float(sale.total_amount or 0),
        'items': items,
    })


@app.route('/pharmacist/api/walkin-sales', methods=['GET'])
@login_required
def pharmacist_walkin_sales_api():
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        limit = 500
        sales = (
            db.session.query(Sale)
            .options(
                db.joinedload(Sale.user),
                db.joinedload(Sale.items),
            )
            .filter(Sale.patient_id.is_(None))
            .order_by(Sale.created_at.desc())
            .limit(limit)
            .all()
        )

        rows = []
        for s in sales:
            items = list(s.items or [])
            total_qty = 0
            try:
                total_qty = sum(int(i.quantity or 0) for i in items)
            except Exception:
                total_qty = 0

            created_at_iso = None
            try:
                created_at_iso = (s.created_at.isoformat() if s.created_at else None)
            except Exception:
                created_at_iso = None

            rows.append({
                'sale_id': s.id,
                'sale_number': s.sale_number,
                'created_at': created_at_iso,
                'payment_method': s.payment_method,
                'total_amount': float(s.total_amount or 0),
                'total_qty': int(total_qty),
                'pharmacist': (s.pharmacist_name or (s.user.username if s.user else '')),
            })

        return jsonify({'success': True, 'rows': rows})
    except Exception as e:
        current_app.logger.error(f"Failed to load walk-in sales: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to load receipts'}), 500


@app.route('/pharmacist/cart_sale', methods=['POST'])
@login_required
def process__cart_sale():
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'No data received'}), 400
        
        # Validate required fields
        if 'items' not in data:
            return jsonify({'success': False, 'error': 'Missing items field'}), 400
        
        items = data.get('items', [])
        payment_method = data.get('payment_method', 'cash')
        amount_given = data.get('amount_given', None)  # Amount client gave (for cash payments)
        
        if not items:
            return jsonify({'success': False, 'error': 'No items in cart'}), 400
        
        # Validate each item
        for i, item in enumerate(items):
            if 'drug_id' not in item:
                return jsonify({'success': False, 'error': f'Missing drug_id in item {i+1}'}), 400
            if 'quantity' not in item:
                return jsonify({'success': False, 'error': f'Missing quantity in item {i+1}'}), 400
            if 'unit_price' not in item:
                return jsonify({'success': False, 'error': f'Missing unit_price in item {i+1}'}), 400
        
        # Generate sale numbers
        sale_number = f"SALE-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"
        
        # Calculate total amount
        total_amount = sum(float(item.get('unit_price', 0)) * int(item.get('quantity', 0)) for item in items)
        
        # Calculate change (for cash payments)
        change = 0
        if payment_method == 'cash' and amount_given is not None:
            amount_given = float(amount_given)
            change = amount_given - total_amount
        
        # Create sale record
        sale = Sale(
            sale_number=sale_number,
            patient_id=None,  # Walk-in sale
            user_id=current_user.id,
            pharmacist_name=f"{current_user.username}",
            total_amount=total_amount,
            payment_method=payment_method,
            status='completed',
            created_at=get_eat_now(),
        )
        db.session.add(sale)
        db.session.flush()
        
        # Process each item
        for item_index, item_data in enumerate(items):
            drug_id = item_data.get('drug_id')
            quantity = int(item_data.get('quantity', 1))
            unit_price = float(item_data.get('unit_price', 0))
            
            if not drug_id or quantity <= 0:
                continue
            
            # Get drug from database
            drug = db.session.get(Drug, drug_id)
            if not drug:
                db.session.rollback()
                return jsonify({
                    'success': False,
                    'error': f'Drug with ID {drug_id} not found'
                }), 400
            
            # Check stock availability
            if drug.remaining_quantity < quantity:
                db.session.rollback()
                return jsonify({
                    'success': False,
                    'error': f'Insufficient stock for {drug.name}',
                    'available': drug.remaining_quantity,
                    'requested': quantity,
                    'drug_id': drug.id
                }), 400
            
            # Create sale item
            sale_item = SaleItem(
                sale=sale,
                drug_id=drug_id,
                drug_name=drug.name,
                drug_specification=drug.specification,
                individual_sale_number=f"{sale_number}-{item_index+1:02d}",
                description=f"Sale of {drug.name}",
                quantity=quantity,
                unit_price=unit_price,
                total_price=unit_price * quantity,
                created_at=get_eat_now(),
            )
            db.session.add(sale_item)
            
            # Update drug stock
            drug.sold_quantity += quantity
            db.session.add(drug)
        
        # Create transaction record
        transaction = Transaction(
            transaction_number=f"TXN-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}",
            transaction_type='sale',
            amount=total_amount,
            user_id=current_user.id,
            reference_id=sale.id,
            notes=f"Sale #{sale.sale_number}",
            created_at=get_eat_now(),
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='sales',
            direction='IN',
            status='posted',
            department='pharmacy',
            category='drug_sale',
            payment_method=payment_method,
        )
        db.session.add(transaction)

        # Store sale receipt HTML for reprinting (best-effort)
        try:
            # Session autoflush is disabled; flush pending SaleItems so receipt queries can see them.
            db.session.flush()
            sale_for_receipt = db.session.query(Sale).options(
                db.joinedload(Sale.user),
                db.joinedload(Sale.items).joinedload(SaleItem.drug),
                db.joinedload(Sale.patient)
            ).filter(Sale.id == sale.id).first()

            related_sales = []
            if sale_for_receipt and sale_for_receipt.bulk_sale_number:
                related_sales = db.session.query(Sale).filter(
                    Sale.bulk_sale_number == sale_for_receipt.bulk_sale_number,
                    Sale.id != sale_for_receipt.id
                ).options(db.joinedload(Sale.items).joinedload(SaleItem.drug)).all()

            receipt_html = render_template(
                'pharmacist/receipt.html',
                sale=sale_for_receipt,
                related_sales=related_sales,
                now=datetime.now(),
                amount_given=amount_given,
                change=change,
            )
            _ensure_transaction_receipt(transaction, receipt_html, prefix='SALE')
        except Exception as e:
            current_app.logger.error(f"Failed to store sale receipt HTML: {str(e)}", exc_info=True)
        
        # Commit all changes
        db.session.commit()
        
        return jsonify({
            'success': True,
            'sale_id': sale.id,
            'sale_number': sale.sale_number,
            'total_amount': sale.total_amount,
            'message': 'Sale processed successfully'
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error processing sale: {str(e)}", exc_info=True)
        return jsonify({
            'success': False, 
            'error': 'Failed to process sale. Please try again later.'
        }), 500
        
@app.route('/pharmacist/sale/<int:sale_id>/receipt')
@login_required
def generate_receipt(sale_id):
    if current_user.role != 'pharmacist':
        abort(403)
    
    tx = _get_transaction_for_sale(sale_id)
    embedded_requested = request.args.get('embedded') == '1'

    reprint_requested = request.args.get('reprint') == '1'
    stored_invalid = False

    # If we already stored the receipt, serve it (and optionally mark as reprint)
    # For embedded modal views, render from DB to avoid nested full-page HTML.
    if (not embedded_requested) and tx and tx.receipt_html:
        stored_html = tx.receipt_html
        # Backward-compat: older sanitization escaped tags, causing receipts to display as text.
        if stored_html and ('&lt;' in stored_html or '&gt;' in stored_html):
            try:
                stored_html = _sanitize_receipt_html(html_lib.unescape(stored_html))
            except Exception:
                stored_html = tx.receipt_html

        # If the stored receipt was generated before items were flushed, it may have no rows.
        if stored_html and 'No items found for this sale.' in stored_html:
            stored_invalid = True
        else:
            if reprint_requested:
                try:
                    tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                    tx.receipt_reprinted_at = get_eat_now()
                    db.session.add(tx)
                    db.session.commit()
                except Exception:
                    db.session.rollback()
                return Response(_inject_reprint_banner(stored_html, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
            return Response(stored_html, mimetype='text/html')

    sale = db.session.query(Sale).options(
        db.joinedload(Sale.user),
        db.joinedload(Sale.items).joinedload(SaleItem.drug),
        db.joinedload(Sale.patient)
    ).where(Sale.id == sale_id).first()
    
    if not sale:
        abort(404)
    
    related_sales = []
    if sale.bulk_sale_number:
        related_sales = db.session.query(Sale).filter(
            Sale.bulk_sale_number == sale.bulk_sale_number,
            Sale.id != sale.id
        ).options(
            db.joinedload(Sale.items).joinedload(SaleItem.drug)
        ).all()
    
    rendered = render_template(
        'pharmacist/receipt.html',
        sale=sale,
        related_sales=related_sales,
        now=datetime.now(),
        amount_given=None,
        change=None,
    )

    # Persist for future reprints if transaction exists
    try:
        if not tx:
            tx = _get_transaction_for_sale(sale_id)
        if tx:
            _ensure_transaction_receipt(tx, rendered, prefix='SALE', force=stored_invalid)

            if reprint_requested:
                tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                tx.receipt_reprinted_at = get_eat_now()
                db.session.add(tx)
            db.session.commit()
    except Exception:
        db.session.rollback()

    if embedded_requested:
        return Response(rendered, mimetype='text/html')

    if reprint_requested and tx:
        return Response(_inject_reprint_banner(tx.receipt_html or rendered, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
    return Response(rendered, mimetype='text/html')

@app.route('/pharmacist/refunds')
@login_required
def pharmacist_refunds():
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    return render_template('pharmacist/refunds.html')

@app.route('/pharmacist/sales/search', methods=['GET'])
@login_required
def search_sale():
    sale_number = request.args.get('sale_number')
    
    sale = Sale.query.filter((Sale.sale_number == sale_number) | 
                           (Sale.bulk_sale_number == sale_number)).first()
    
    if not sale:
        return jsonify({'error': 'Sale not found'}), 404
    
    items = []
    for item in sale.items:
        items.append({
            'id': item.id,
            'individual_sale_number': item.individual_sale_number,
            'drug_id': item.drug_id,
            'drug_name': item.drug.name,
            'quantity_sold': item.quantity,
            'quantity_remaining': item.quantity - sum(
                ri.quantity for ri in item.refunds
            ) if item.refunds else item.quantity,
            'unit_price': item.unit_price,
            'total_price': item.total_price
        })
    
    return jsonify({
        'sale_number': sale.sale_number,
        'bulk_sale_number': sale.bulk_sale_number,
        'is_bulk': bool(sale.bulk_sale_number),
        'created_at': sale.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': sale.patient.name if sale.patient else 'Walk-in',
        'total_amount': sale.total_amount,
        'items': items
    })

@app.route('/pharmacist/refund/search', methods=['GET'])
@login_required
def search_sale_for_refund():
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    sale_number = request.args.get('sale_number')
    if not sale_number:
        return jsonify({'error': 'Sale number is required'}), 400
    
    sale = db.session.query(Sale).filter(
        (Sale.sale_number == sale_number) | 
        (Sale.bulk_sale_number == sale_number)
    ).first()
    
    if not sale:
        return jsonify({'error': 'Sale not found'}), 404
    
    items = []
    for item in sale.items:
        if item.drug_id:
            refunded_qty = sum(ri.quantity for ri in item.refund_items) if item.refund_items else 0
            remaining_qty = item.quantity - refunded_qty
            
            if remaining_qty > 0:
                items.append({
                    'id': item.id,
                    'sale_item_id': item.id,
                    'drug_id': item.drug_id,
                    'drug_name': item.drug_name,
                    'unit_price': item.unit_price,
                    'quantity_sold': item.quantity,
                    'quantity_refunded': refunded_qty,
                    'quantity_remaining': remaining_qty,
                    'total_price': item.total_price
                })
    
    return jsonify({
        'sale_id': sale.id,
        'sale_number': sale.sale_number,
        'bulk_sale_number': sale.bulk_sale_number,
        'is_bulk': bool(sale.bulk_sale_number),
        'created_at': sale.created_at.strftime('%Y-%m-%d %H:%M'),
        'patient_name': sale.patient.get_decrypted_name if sale.patient else 'Walk-in Customer',
        'total_amount': sale.total_amount,
        'items': items
    })


@app.route('/pharmacist/process-refund', methods=['POST'])
@login_required
def process_refund():
    if current_user.role not in ['pharmacist', 'admin']:
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        data = request.get_json() or {}
        sale_id = data.get('sale_id')
        sale_number = data.get('sale_number')
        items_to_refund = data.get('items', [])
        reason = data.get('reason', 'No reason provided')

        # Compatibility: dashboard.js sends {sale_number, items:[sale_item_id,...]}
        raw_item_ids = None
        if items_to_refund and isinstance(items_to_refund, list) and not isinstance(items_to_refund[0], dict):
            raw_item_ids = [int(x) for x in items_to_refund]
            items_to_refund = []

        if not sale_id and sale_number:
            sale = db.session.query(Sale).filter(
                (Sale.sale_number == sale_number) | (Sale.bulk_sale_number == sale_number)
            ).first()
            sale_id = sale.id if sale else None

        if not sale_id:
            return jsonify({'success': False, 'error': 'Sale ID (or sale number) is required.'}), 400

        if (not items_to_refund) and (not raw_item_ids):
            return jsonify({'success': False, 'error': 'Items to refund are required.'}), 400

        original_sale = db.session.get(Sale, sale_id)
        if not original_sale:
            return jsonify({'success': False, 'error': 'Original sale not found.'}), 404

        # If we received only item IDs, refund the remaining refundable quantity for each.
        if raw_item_ids:
            converted = []
            for sale_item_id in raw_item_ids:
                sale_item = db.session.get(SaleItem, sale_item_id)
                if not sale_item or sale_item.sale_id != original_sale.id:
                    continue

                already_refunded_qty = sum(ri.quantity for ri in sale_item.refund_items)
                remaining_qty = int(sale_item.quantity or 0) - int(already_refunded_qty or 0)
                if remaining_qty <= 0:
                    continue

                converted.append({'sale_item_id': sale_item.id, 'quantity': remaining_qty})

            if not converted:
                return jsonify({'success': False, 'error': 'No valid items to refund.'}), 400
            items_to_refund = converted

        total_refund_amount = 0
        refund_items_to_create = []
        
        for item_data in items_to_refund:
            sale_item_id = item_data.get('sale_item_id')
            quantity_to_refund = int(item_data.get('quantity', 0))

            if quantity_to_refund <= 0:
                continue

            sale_item = db.session.get(SaleItem, sale_item_id)
            if not sale_item or sale_item.sale_id != original_sale.id:
                return jsonify({'success': False, 'error': f'Sale item {sale_item_id} not found or does not belong to this sale.'}), 400
            
            # Check if this item has been refunded before
            already_refunded_qty = sum(ri.quantity for ri in sale_item.refund_items)
            
            if quantity_to_refund > (sale_item.quantity - already_refunded_qty):
                return jsonify({'success': False, 'error': f'Cannot refund more than purchased quantity for item {sale_item.drug_name}.'}), 400

            refund_amount = quantity_to_refund * sale_item.unit_price
            total_refund_amount += refund_amount

            refund_items_to_create.append({
                'sale_item': sale_item,
                'quantity': quantity_to_refund,
                'unit_price': sale_item.unit_price,
                'total_price': refund_amount
            })

            # Restore stock
            if sale_item.drug:
                drug = sale_item.drug
                drug.sold_quantity -= quantity_to_refund
                db.session.add(drug)

        if not refund_items_to_create:
            return jsonify({'success': False, 'error': 'No valid items to refund.'}), 400

        # Budget enforcement (warn-only by default)
        try:
            budget_check = _budget_check_outflow('pharmacy', float(total_refund_amount or 0), when_dt=get_eat_now())
            if budget_check and budget_check.get('block'):
                return jsonify({'success': False, 'error': budget_check.get('message') or 'Budget exceeded for this month.'}), 400
        except Exception:
            pass

        # Create Refund record
        refund = Refund(
            refund_number=f"REF-{original_sale.sale_number}-{random.randint(100, 999)}",
            sale_id=original_sale.id,
            user_id=current_user.id,
            total_amount=total_refund_amount,
            reason=reason,
            status='completed'
        )
        db.session.add(refund)
        db.session.flush()

        # Create RefundItem records
        for item_to_create in refund_items_to_create:
            refund_item = RefundItem(
                refund_id=refund.id,
                sale_item_id=item_to_create['sale_item'].id,
                quantity=item_to_create['quantity'],
                unit_price=item_to_create['unit_price'],
                total_price=item_to_create['total_price']
            )
            db.session.add(refund_item)

        # Create Transaction record for the refund
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='refund',
            amount=total_refund_amount,
            user_id=current_user.id,
            reference_id=refund.id,
            notes=f"Refund for sale {original_sale.sale_number}. Reason: {reason}"
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='refunds',
            direction='OUT',
            status='posted',
            department='pharmacy',
            category='refund',
            payer=original_sale.patient.name if original_sale.patient else 'Walk-in Customer',
            payment_method=None,
        )
        db.session.add(transaction)

        # Log audit event
        log_audit_event(
            action='process_refund',
            table_name='refunds',
            record_id=refund.id,
            description=f"Processed refund {refund.refund_number} for sale {original_sale.sale_number}",
            new_values={
                'refund_id': refund.id,
                'sale_id': original_sale.id,
                'total_amount': total_refund_amount,
                'reason': reason,
                'items': [
                    {'sale_item_id': item['sale_item'].id, 'quantity': item['quantity']}
                    for item in refund_items_to_create
                ]
            }
        )

        db.session.commit()

        return jsonify({'success': True, 'message': 'Refund processed successfully.', 'refund_id': refund.id})

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error processing refund: {e}", exc_info=True)
        return jsonify({'success': False, 'error': 'An unexpected error occurred.'}), 500


@app.route('/pharmacist/refund', methods=['POST'])
@login_required
def pharmacist_refund_alias():
    """Compatibility alias for frontend posting to `/pharmacist/refund`."""
    return process_refund()


def generate_refund_number():
    return f"REF-{datetime.now().strftime('%Y%m%d')}-{random.randint(1000, 9999)}"

@app.route('/pharmacist/refund/<int:refund_id>/receipt')
@login_required
def refund_receipt(refund_id):
    if current_user.role != 'pharmacist':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    embedded_requested = request.args.get('embedded') == '1'
    
    tx = _get_transaction_for_refund(refund_id)
    if (not embedded_requested) and tx and tx.receipt_html:
        if request.args.get('reprint') == '1':
            try:
                tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                tx.receipt_reprinted_at = get_eat_now()
                db.session.add(tx)
                db.session.commit()
            except Exception:
                db.session.rollback()
            return Response(_inject_reprint_banner(tx.receipt_html, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
        return Response(tx.receipt_html, mimetype='text/html')

    refund = db.session.query(Refund).options(
        db.joinedload(Refund.sale).joinedload(Sale.patient),
        db.joinedload(Refund.user),
        db.joinedload(Refund.items).joinedload(RefundItem.sale_item)
    ).get(refund_id)
    
    if not refund:
        flash('Refund not found', 'danger')
        return redirect(url_for('pharmacist_refunds'))
    
    rendered = render_template('pharmacist/refund_receipt.html', refund=refund)
    try:
        if not tx:
            tx = _get_transaction_for_refund(refund_id)
        if tx:
            _ensure_transaction_receipt(tx, rendered, prefix='REF')
            db.session.commit()
    except Exception:
        db.session.rollback()
    return Response(rendered, mimetype='text/html')


@app.route('/admin/transaction/<int:transaction_id>/receipt')
@login_required
def admin_transaction_receipt(transaction_id):
    if current_user.role != 'admin':
        abort(403)

    tx = Transaction.query.options(db.joinedload(Transaction.user)).get(transaction_id)
    if not tx:
        abort(404)

    # Serve stored receipt if exists
    if tx.receipt_html:
        if request.args.get('reprint') == '1':
            try:
                tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                tx.receipt_reprinted_at = get_eat_now()
                db.session.add(tx)
                db.session.commit()
            except Exception:
                db.session.rollback()
            return Response(_inject_reprint_banner(tx.receipt_html, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
        return Response(tx.receipt_html, mimetype='text/html')

    # Generate receipt based on transaction type
    sale = None
    refund = None
    expense = None
    purchase = None
    try:
        if tx.transaction_type == 'sale' and tx.reference_id:
            sale = Sale.query.options(
                db.joinedload(Sale.user),
                db.joinedload(Sale.items).joinedload(SaleItem.drug),
                db.joinedload(Sale.patient)
            ).get(tx.reference_id)
        elif tx.transaction_type == 'refund' and tx.reference_id:
            refund = Refund.query.options(
                db.joinedload(Refund.sale).joinedload(Sale.patient),
                db.joinedload(Refund.user),
                db.joinedload(Refund.items).joinedload(RefundItem.sale_item)
            ).get(tx.reference_id)
        elif tx.transaction_type == 'expense' and tx.reference_id:
            expense = _db_get(Expense, tx.reference_id)
        elif tx.transaction_type == 'purchase' and tx.reference_id:
            purchase = _db_get(Purchase, tx.reference_id)
    except Exception:
        pass

    amount_given = request.args.get('amount_given', type=float)
    change = None
    if amount_given is not None:
        base_amount = None
        try:
            base_amount = float((sale.total_amount if sale else tx.amount) or 0)
        except Exception:
            base_amount = None
        if base_amount is not None:
            try:
                change = float(amount_given) - float(base_amount)
            except Exception:
                change = None

    rendered = render_template(
        'admin/transaction_receipt.html',
        transaction=tx,
        sale=sale,
        refund=refund,
        expense=expense,
        purchase=purchase,
        amount_given=amount_given,
        change=change,
    )
    try:
        _ensure_transaction_receipt(tx, rendered, prefix='TX')
        db.session.commit()
    except Exception:
        db.session.rollback()

    return Response(rendered, mimetype='text/html')

    
# Pharmacist Prescription Routes
@app.route('/pharmacist/prescriptions')
@login_required
def patient_prescriptions():
    """Get all pending prescriptions for pharmacist"""
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # Get pending prescriptions with related data
        prescriptions = Prescription.query.filter_by(status='pending').options(
            db.joinedload(Prescription.patient),
            db.joinedload(Prescription.doctor),
            db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug)
        ).order_by(Prescription.created_at.asc()).all()
        
        prescription_data = []
        for prescription in prescriptions:
            # Safely get patient name - handle the method properly
            patient_name = ""
            try:
                if hasattr(prescription.patient, 'get_decrypted_name'):
                    # Call the method to get the actual value
                    patient_name = prescription.patient.get_decrypted_name
                else:
                    patient_name = str(prescription.patient) if prescription.patient else "Unknown Patient"
            except Exception as e:
                current_app.logger.error(f"Error getting patient name: {str(e)}")
                patient_name = "Error loading patient"
            
            prescription_data.append({
                'id': prescription.id,
                'patient_name': patient_name,
                'patient_number': prescription.patient.op_number or prescription.patient.ip_number if prescription.patient else "N/A",
                'doctor_name': prescription.doctor.username if prescription.doctor else "Unknown Doctor",
                'created_at': prescription.created_at.strftime('%Y-%m-%d %H:%M') if prescription.created_at else "Unknown Date",
                'items_count': len(prescription.items) if prescription.items else 0,
                'status': prescription.status
            })
        
        return jsonify(prescription_data)
    
    except Exception as e:
        current_app.logger.error(f"Error fetching prescriptions: {str(e)}")
        return jsonify({'error': 'Failed to fetch prescriptions'}), 500
    
    
@app.route('/pharmacist/prescriptions/check-new')
@login_required
def check_new_prescriptions():
    """Check if there are new pending prescriptions"""
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # Get the count of pending prescriptions
        pending_count = db.session.query(Prescription).filter_by(status='pending').count()
        
        # You could also track the last checked time for each pharmacist
        # For simplicity, we'll just return if there are any pending prescriptions
        
        return jsonify({
            'success': True,
            'has_new_prescriptions': pending_count > 0,
            'pending_count': pending_count
        })
    
    except Exception as e:
        current_app.logger.error(f"Error checking new prescriptions: {str(e)}")
        return jsonify({'error': 'Failed to check prescriptions'}), 500


@app.route('/pharmacist/prescription/<int:id>/delete', methods=['POST'])
@login_required
def delete_prescription(id):
    """Allow pharmacist or admin to delete a prescription (only if not dispensed)."""
    if current_user.role not in ('pharmacist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    prescription = _db_get_or_404(Prescription, id)
    try:
        if prescription.status == 'dispensed':
            return jsonify({'success': False, 'error': 'Cannot remove a dispensed prescription'}), 400

        # Delete associated items first
        PrescriptionItem.query.filter_by(prescription_id=prescription.id).delete()

        # Then delete the prescription
        db.session.delete(prescription)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Prescription removed'})
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error deleting prescription {id}: {str(e)}")
        return jsonify({'success': False, 'error': 'Failed to remove prescription'}), 500

@app.route('/doctor/complete_prescription', methods=['POST'])
@login_required
def doctor_complete_prescription():
    """Doctor completes a prescription - this should trigger pharmacist notification"""
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        data = request.get_json()
        patient_id = data.get('patient_id')
        prescription_data = data.get('prescription_data')
        
        if not patient_id or not prescription_data:
            return jsonify({'success': False, 'error': 'Missing required data'}), 400
        
        # Create prescription record
        prescription = Prescription(
            patient_id=patient_id,
            doctor_id=current_user.id,
            notes=prescription_data.get('notes', ''),
            status='pending'  # Set to pending for pharmacist to dispense
        )
        db.session.add(prescription)
        db.session.flush()  # Get prescription ID
        
        # Add prescription items
        for item in prescription_data.get('items', []):
            prescription_item = PrescriptionItem(
                prescription_id=prescription.id,
                drug_id=item['drug_id'],
                quantity=item['quantity'],
                dosage=item.get('dosage', ''),
                frequency=item.get('frequency', ''),
                duration=item.get('duration', ''),
                notes=item.get('notes', ''),
                status='pending'
            )
            db.session.add(prescription_item)
        
        db.session.commit()
        
        # Log the prescription creation
        log_audit(
            'create_prescription',
            'Prescription',
            prescription.id,
            None,
            {
                'patient_id': patient_id,
                'doctor_id': current_user.id,
                'items_count': len(prescription_data.get('items', []))
            }
        )
        
        return jsonify({
            'success': True,
            'prescription_id': prescription.id,
            'message': 'Prescription completed successfully and sent to pharmacy'
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error completing prescription: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/doctor/complete_services', methods=['POST'])
@login_required
def doctor_complete_services():
    """Doctor completes selected services (records them as done for billing)."""
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        data = request.get_json(silent=True) or {}
        patient_id = data.get('patient_id')
        service_ids = data.get('service_ids') or []
        notes = (data.get('notes') or data.get('service_notes') or '').strip() or None

        try:
            patient_id_int = int(patient_id)
        except Exception:
            patient_id_int = None

        if not patient_id_int or not isinstance(service_ids, list) or len(service_ids) == 0:
            return jsonify({'success': False, 'error': 'Missing required data'}), 400

        patient = db.session.get(Patient, patient_id_int)
        if not patient:
            return jsonify({'success': False, 'error': 'Patient not found'}), 404

        now = get_eat_now()
        created = []
        for sid in service_ids:
            try:
                sid_int = int(sid)
            except Exception:
                continue

            service = db.session.get(Service, sid_int)
            if not service:
                continue

            patient_service = PatientService(
                patient_id=patient.id,
                service_id=service.id,
                status='done',
                requested_by=current_user.id,
                performed_by=current_user.id,
                completed_by=current_user.id,
                completed_at=now,
                notes=notes,
            )
            db.session.add(patient_service)
            created.append(patient_service)

        if not created:
            return jsonify({'success': False, 'error': 'No valid services selected'}), 400

        db.session.commit()

        try:
            log_audit(
                'complete_services',
                'PatientService',
                created[0].id if created else None,
                None,
                {
                    'patient_id': patient.id,
                    'doctor_id': current_user.id,
                    'services_count': len(created),
                },
            )
        except Exception:
            pass

        return jsonify({
            'success': True,
            'count': len(created),
            'message': f"Completed {len(created)} service(s)"
        })
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error completing services: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/pharmacist/prescription/<int:prescription_id>')
@login_required
def get_prescription_details(prescription_id):
    """Get detailed information about a specific prescription"""
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        # FIXED: Use db.session.get() instead of Query.get()
        prescription = db.session.get(Prescription, prescription_id)
        
        if not prescription:
            return jsonify({'error': 'Prescription not found'}), 404
        
        items_data = []
        for item in prescription.items:
            unit_price = 0
            try:
                unit_price = float(item.drug.selling_price or 0) if item.drug else 0
            except Exception:
                unit_price = 0
            items_data.append({
                'id': item.id,
                'drug_id': item.drug_id,
                'drug_name': item.drug.name if item.drug else "Unknown Drug",
                'drug_number': item.drug.drug_number if item.drug else "N/A",
                'dosage': item.dosage or "",
                'frequency': item.frequency or "",
                'duration': item.duration or "",
                'quantity': item.quantity,
                'unit_price': unit_price,
                'notes': item.notes or "",
                'drug': {
                    'id': item.drug.id if item.drug else None,
                    'name': item.drug.name if item.drug else "Unknown Drug",
                    'remaining_quantity': item.drug.remaining_quantity if item.drug else 0
                } if item.drug else None
            })
        
        # Safely get patient name
        patient_name = ""
        try:
            if hasattr(prescription.patient, 'get_decrypted_name'):
                patient_name = prescription.patient.get_decrypted_name
            else:
                patient_name = str(prescription.patient) if prescription.patient else "Unknown Patient"
        except Exception as e:
            current_app.logger.error(f"Error getting patient name: {str(e)}")
            patient_name = "Error loading patient"
        
        return jsonify({
            'id': prescription.id,
            'patient_id': prescription.patient_id,
            'patient_name': patient_name,
            'patient_number': prescription.patient.op_number or prescription.patient.ip_number if prescription.patient else "N/A",
            'doctor_id': prescription.doctor_id,
            'doctor_name': prescription.doctor.username if prescription.doctor else "Unknown Doctor",
            'notes': prescription.notes or "",
            'status': prescription.status,
            'created_at': prescription.created_at.strftime('%Y-%m-%d %H:%M') if prescription.created_at else "Unknown Date",
            'items': items_data
        })
    
    except Exception as e:
        current_app.logger.error(f"Error fetching prescription details: {str(e)}")
        return jsonify({'error': 'Failed to fetch prescription details'}), 500


@app.route('/pharmacist/dispense', methods=['POST'])
@login_required
def pharmacist_dispense():
    """Dispense a prescription and update inventory"""
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No data provided'}), 400
        
        prescription_id = data.get('prescription_id')
        # Payment is handled by receptionist billing; pharmacists only dispense.
        # Keep accepting the field for backward-compatible frontend payloads.
        _ = data.get('payment_method', None)
        
        if not prescription_id:
            return jsonify({'error': 'Prescription ID is required'}), 400
        
        # Get prescription with related data
        prescription = db.session.query(Prescription).options(
            db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug),
            db.joinedload(Prescription.patient)
        ).get(prescription_id)
        
        if not prescription:
            return jsonify({'error': 'Prescription not found'}), 404
        
        if prescription.status != 'pending':
            return jsonify({'error': 'Prescription has already been processed'}), 400
        
        # Verify all items are available
        for item in prescription.items:
            if item.drug.remaining_quantity < item.quantity:
                return jsonify({
                    'error': f'Insufficient stock for {item.drug.name}',
                    'details': f'Requested: {item.quantity}, Available: {item.drug.remaining_quantity}',
                    'drug_id': item.drug.id
                }), 400
        
        # Update drug inventory and mark each prescription item dispensed
        for item in prescription.items:
            try:
                item.status = 'dispensed'
            except Exception:
                pass
            # Update drug inventory (remaining_quantity is derived from sold_quantity)
            if item.drug:
                item.drug.sold_quantity += item.quantity
        
        # Update prescription status
        prescription.status = 'dispensed'
        prescription.dispensed_by = current_user.id
        prescription.dispensed_at = get_eat_now()
        
        db.session.commit()
        
        # Log the action
        log_audit(
            'dispense_prescription',
            'Prescription',
            prescription.id,
            None,
            {
                'patient_id': prescription.patient_id,
                'items_count': len(prescription.items or []),
                'note': 'Dispensed only; billing handled by receptionist'
            }
        )
        
        return jsonify({
            'success': True,
            'sale_id': None,
            'sale_number': None,
            'total_amount': 0,
            'message': 'Prescription dispensed successfully. Please proceed to reception for billing.'
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Error dispensing prescription: {str(e)}", exc_info=True)
        return jsonify({
            'error': 'Failed to process prescription',
            'details': str(e)
        }), 500
@app.route('/pharmacist/sale/<int:sale_id>/receipt-json')
@login_required
def get_sale_receipt_json(sale_id):
    """JSON receipt data for a completed sale (kept for API consumers)."""
    if current_user.role != 'pharmacist':
        return jsonify({'error': 'Unauthorized'}), 403

    try:
        sale = Sale.query.options(
            db.joinedload(Sale.patient),
            db.joinedload(Sale.items),
            db.joinedload(Sale.user)
        ).get(sale_id)

        if not sale:
            return jsonify({'error': 'Sale not found'}), 404

        receipt_data = {
            'sale_id': sale.id,
            'sale_number': sale.sale_number,
            'date': sale.created_at.strftime('%Y-%m-%d %H:%M'),
            'patient_name': sale.patient.get_decrypted_name if sale.patient else 'Walk-in Customer',
            'patient_number': sale.patient.op_number or sale.patient.ip_number if sale.patient else 'N/A',
            'pharmacist_name': sale.user.username,
            'payment_method': sale.payment_method,
            'total_amount': sale.total_amount,
            'items': []
        }

        for item in sale.items:
            receipt_data['items'].append({
                'name': item.drug_name,
                'specification': item.drug_specification,
                'quantity': item.quantity,
                'unit_price': item.unit_price,
                'total_price': item.total_price
            })

        return jsonify(receipt_data)

    except Exception as e:
        current_app.logger.error(f"Error generating receipt JSON: {str(e)}")
        return jsonify({'error': 'Failed to generate receipt'}), 500

   
# Doctor Routes
@app.route('/doctor/restore')
@login_required
def doctor_restore_last():
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    return render_template('doctor/restore_last.html', fallback_url=url_for('doctor_dashboard'))

@app.route('/doctor')
@login_required
def doctor_dashboard():
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Get counts for the stats cards with access control filtering
    base_active_query = Patient.query.filter_by(status='active')
    active_patients_count = filter_accessible_patients(base_active_query, current_user).count()
    
    # Count distinct patients who have a sale today (avoid cartesian product with Sales).
    today_patients = (
        db.session.query(func.count(func.distinct(Sale.patient_id)))
        .filter(func.date(Sale.created_at) == get_eat_today())
        .scalar()
    ) or 0
    
    base_completed_query = Patient.query.filter_by(status='completed')
    completed_patients_count = filter_accessible_patients(base_completed_query, current_user).count()
    
    # Get actual patient lists for the tables with access control filtering
    active_query = Patient.query.filter_by(status='active')
    active_patients = filter_accessible_patients(active_query, current_user).order_by(Patient.updated_at.desc()).limit(50).all()
    
    completed_query = Patient.query.filter_by(status='completed')
    completed_patients = filter_accessible_patients(completed_query, current_user).order_by(Patient.updated_at.desc()).limit(50).all()

    # Diagnosis analytics (safe, additive; never blocks dashboard rendering).
    diagnosis_stats = None
    try:
        import re
        from collections import Counter

        def _norm_gender(val: str | None) -> str:
            s = (val or '').strip().lower()
            if s.startswith('m'):
                return 'Male'
            if s.startswith('f'):
                return 'Female'
            return 'Other/Unknown'

        def _age_bucket(age_val) -> str:
            try:
                age_int = int(age_val)
            except Exception:
                return 'Unknown'
            if age_int < 18:
                return 'Children'
            if age_int >= 60:
                return 'Geriatrics'
            return 'Adults'

        def _split_dx(text: str | None) -> list[str]:
            if not text:
                return []
            s = str(text).replace('\r', '\n')
            parts: list[str] = []
            for raw in re.split(r"[\n,;|/]+", s):
                t = raw.strip()
                if not t:
                    continue
                # Strip common bullet prefixes
                t = re.sub(r"^[-•\*\u2022\s]+", "", t).strip()
                if not t:
                    continue
                if t.lower() in {'n/a', 'na', 'none', 'nil'}:
                    continue
                parts.append(t)
            return parts

        def _canon(label: str) -> str:
            s = (label or '').strip().lower()
            s = re.sub(r"\s+", " ", s)
            s = re.sub(r"\s*\([^\)]*\)\s*", " ", s)  # drop parenthetical notes
            s = re.sub(r"\s+", " ", s).strip()
            return s

        # Minimal endemic keyword list (Western Kenya) - configurable later if needed.
        endemic_keywords = {
            'malaria': 'Malaria',
            'typhoid': 'Typhoid',
            'cholera': 'Cholera',
            'tuberculosis': 'Tuberculosis',
            'tb': 'Tuberculosis',
            'hiv': 'HIV',
            'aids': 'HIV/AIDS',
            'pneumonia': 'Pneumonia',
            'diarrh': 'Diarrhoeal disease',
            'dysentery': 'Dysentery',
            'meningitis': 'Meningitis',
            'measles': 'Measles',
        }

        def _endemic_label(canonical: str) -> str | None:
            if not canonical:
                return None
            for key, label in endemic_keywords.items():
                if key in canonical:
                    return label
            return None

        stats_window_days = 90
        cutoff = get_eat_now() - timedelta(days=stats_window_days)

        rows = (
            db.session.query(
                PatientDiagnosis.working_diagnosis,
                PatientDiagnosis.differential_diagnosis,
                PatientDiagnosis.created_at,
                Patient.gender,
                Patient.age,
            )
            .join(Patient, Patient.id == PatientDiagnosis.patient_id)
            .filter(PatientDiagnosis.created_at >= cutoff)
            .order_by(PatientDiagnosis.created_at.desc())
            .limit(5000)
            .all()
        )

        display_name: dict[str, str] = {}
        overall = Counter()
        by_gender: dict[str, Counter] = {
            'Male': Counter(),
            'Female': Counter(),
            'Other/Unknown': Counter(),
        }
        by_age: dict[str, Counter] = {
            'Children': Counter(),
            'Adults': Counter(),
            'Geriatrics': Counter(),
            'Unknown': Counter(),
        }

        # Outbreak heuristic: compare last 7 days vs baseline (days 8-35 ago).
        now_dt = get_eat_now()
        last7_cutoff = now_dt - timedelta(days=7)
        base_start = now_dt - timedelta(days=35)
        base_end = now_dt - timedelta(days=7)
        endemic_last7 = Counter()
        endemic_baseline = Counter()

        for working_dx, _differential_dx, dx_created_at, gender, age in rows:
            g = _norm_gender(gender)
            a = _age_bucket(age)

            tokens: list[str] = []
            tokens.extend(_split_dx(working_dx))
            if not tokens:
                continue

            for t in tokens:
                c = _canon(t)
                if not c:
                    continue
                if c not in display_name:
                    display_name[c] = t.strip()
                overall[c] += 1
                by_gender.setdefault(g, Counter())[c] += 1
                by_age.setdefault(a, Counter())[c] += 1

                endemic_tag = _endemic_label(c)
                if endemic_tag and dx_created_at:
                    # Make dx_created_at timezone-aware if it's naive
                    dx_aware = dx_created_at
                    if dx_created_at.tzinfo is None:
                        dx_aware = dx_created_at.replace(tzinfo=EAT)
                    
                    if dx_aware >= last7_cutoff:
                        endemic_last7[endemic_tag] += 1
                    elif base_start <= dx_aware < base_end:
                        endemic_baseline[endemic_tag] += 1

        def _top(counter: Counter, n: int = 10):
            out = []
            for key, count in counter.most_common(n):
                out.append({
                    'key': key,
                    'name': display_name.get(key, key.title()),
                    'count': int(count),
                    'endemic': _endemic_label(key),
                })
            return out

        def _dates_last_n(n_days: int) -> list[str]:
            labels = []
            for i in range(n_days - 1, -1, -1):
                d = (now_dt - timedelta(days=i)).date()
                labels.append(d.strftime('%Y-%m-%d'))
            return labels

        outbreak_alerts = []
        for disease_label, cnt7 in endemic_last7.items():
            base_cnt = float(endemic_baseline.get(disease_label, 0))
            expected_7d = (base_cnt / 28.0) * 7.0 if base_cnt > 0 else 0.0
            # Alert if >= 5 cases in last 7d and either baseline is zero or spike >3x expected.
            if cnt7 >= 5 and (expected_7d == 0.0 or cnt7 >= (expected_7d * 3.0)):
                outbreak_alerts.append({
                    'disease': disease_label,
                    'count_7d': int(cnt7),
                    'expected_7d': round(expected_7d, 1),
                })

        # Sort alerts by severity (count)
        outbreak_alerts.sort(key=lambda x: x.get('count_7d', 0), reverse=True)

        # Build chart-friendly datasets (safe defaults; keeps tables intact).
        overall_top10 = _top(overall, 10)
        overall_top5_keys = [row['key'] for row in _top(overall, 5)]

        gender_bar = {
            'labels': [display_name.get(k, k.title()) for k in overall_top5_keys],
            'male': [int(by_gender.get('Male', Counter()).get(k, 0)) for k in overall_top5_keys],
            'female': [int(by_gender.get('Female', Counter()).get(k, 0)) for k in overall_top5_keys],
        }

        trend_days = 30
        trend_labels = _dates_last_n(trend_days)
        trend_index = {label: idx for idx, label in enumerate(trend_labels)}
        top_trend_keys = [k for k, _ in overall.most_common(3)]
        trend_series = {
            k: [0 for _ in range(trend_days)]
            for k in top_trend_keys
        }

        # Re-scan rows to populate per-day series for the top diseases.
        for working_dx, _differential_dx, dx_created_at, _gender, _age in rows:
            if not dx_created_at:
                continue
            day_label = dx_created_at.date().strftime('%Y-%m-%d')
            idx = trend_index.get(day_label)
            if idx is None:
                continue
            tokens: list[str] = []
            tokens.extend(_split_dx(working_dx))
            if not tokens:
                continue
            for t in tokens:
                c = _canon(t)
                if c in trend_series:
                    trend_series[c][idx] += 1

        diagnosis_stats = {
            'window_days': stats_window_days,
            'generated_at': now_dt.strftime('%Y-%m-%d %H:%M'),
            'gender_top': {
                'Male': _top(by_gender.get('Male', Counter())),
                'Female': _top(by_gender.get('Female', Counter())),
            },
            'age_top': {
                'Children': _top(by_age.get('Children', Counter())),
                'Adults': _top(by_age.get('Adults', Counter())),
                'Geriatrics': _top(by_age.get('Geriatrics', Counter())),
            },
            'overall_top': overall_top10,
            'outbreak_alerts': outbreak_alerts[:10],
            'charts': {
                'pie': {
                    'labels': [r['name'] for r in overall_top10],
                    'values': [r['count'] for r in overall_top10],
                },
                'bar_gender': gender_bar,
                'line_trend': {
                    'labels': trend_labels,
                    'series': [
                        {
                            'name': display_name.get(k, k.title()),
                            'values': trend_series.get(k, []),
                        }
                        for k in top_trend_keys
                    ],
                },
            },
        }
    except Exception as e:
        current_app.logger.error(f"Doctor dashboard diagnosis stats error: {str(e)}", exc_info=True)
        diagnosis_stats = {
            'error': 'Failed to load diagnosis analytics',
        }
    
    return render_template('doctor/dashboard.html',
        active_patients_count=active_patients_count,
        today_patients=today_patients,
        completed_patients_count=completed_patients_count,
        active_patients=active_patients,
        completed_patients=completed_patients,
        diagnosis_stats=diagnosis_stats,
        recent_activities=[]  # Empty list until audit is properly set up
    )


@app.route('/doctor/patient/<int:patient_id>/ward-bill', methods=['GET'])
@login_required
def patient_ward_bill(patient_id):
    """View ward-stay billing summary for a patient."""
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    patient = _db_get_or_404(Patient, patient_id)
    ctx = _get_patient_bed_stay_context(patient_id)

    if not ctx:
        flash('Patient has no ward stay assignment on record.', 'info')
        return redirect(url_for('doctor_patient_details', patient_id=patient_id))

    try:
        ctx['patient_name'] = Config.decrypt_data_static(patient.name)
    except Exception:
        ctx['patient_name'] = 'Patient'

    bill_summary, unbilled_summary = get_ward_stay_bill(patient_id, ctx)

    return render_template(
        'doctor/patient_ward_bill.html',
        patient_id=patient_id,
        bill_summary=bill_summary,
        unbilled_summary=unbilled_summary
    )


@app.route('/doctor/patient/<int:patient_id>/ward-bill/update', methods=['POST'])
@login_required
def update_patient_ward_bill(patient_id):
    """Post unbilled ward-stay charges for a patient."""
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    patient = _db_get_or_404(Patient, patient_id)
    ctx = _get_patient_bed_stay_context(patient_id)

    if not ctx:
        flash('No ward stay assignment found for this patient.', 'warning')
        return redirect(url_for('doctor_patient_details', patient_id=patient_id))

    charge, unbilled_days = update_ward_stay_bill_for_patient(patient_id, ctx)

    if charge and unbilled_days > 0:
        flash(f'Ward stay charge added: {unbilled_days} days billed successfully.', 'success')
    else:
        flash('No unbilled days to add (already up to date).', 'info')

    return redirect(url_for('patient_ward_bill', patient_id=patient_id))

        
@app.route('/generate_patient_number')
@login_required
def get_patient_number():
    patient_type = request.args.get('type')
    if patient_type not in ['OP', 'IP']:
        return jsonify({'error': 'Invalid patient type'}), 400

    # Display-only preview: do not reserve/consume a number here.
    number = peek_patient_number(patient_type)
    return jsonify({'number': number})


@app.route('/admin/api/dashboard-stats', methods=['GET'])
@login_required
def dashboard_stats():
    """Lightweight JSON stats for the admin dashboard card widgets."""
    if getattr(current_user, 'role', None) != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    total_patients = db.session.query(func.count(Patient.id)).scalar() or 0
    total_appointments = db.session.query(func.count(Appointment.id)).scalar() or 0
    total_sales = db.session.query(func.sum(Sale.total_amount)).scalar() or 0
    total_expenses = db.session.query(func.sum(Expense.amount)).scalar() or 0

    return jsonify({
        'total_patients': int(total_patients),
        'total_appointments': int(total_appointments),
        'total_sales': float(total_sales or 0),
        'total_expenses': float(total_expenses or 0),
    })

def generate_patient_number(patient_type):
    """Reserve and return a unique patient number (collision-safe).

    Note: The non-reserving preview is `peek_patient_number()`.
    """
    # Delegate to the robust, row-locked counter implementation defined earlier.
    # This function exists because this file historically had multiple definitions.
    return _generate_patient_number_impl(patient_type)

@app.route('/doctor/patients', methods=['GET'])
@login_required
def doctor_patients():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    # Check for search query parameter to help find specific patients
    search_query = request.args.get('search', '').strip()
    
    if search_query:
        # Direct search for debugging with access control
        base_search_query = Patient.query.filter(
            or_(
                Patient.op_number.ilike(f'%{search_query}%'),
                Patient.ip_number.ilike(f'%{search_query}%')
            )
        )
        matching_patients = filter_accessible_patients(base_search_query, current_user).all()
        
        if matching_patients:
            current_app.logger.info(f"Found {len(matching_patients)} patients matching '{search_query}'")
            for p in matching_patients:
                current_app.logger.info(f"  - ID: {p.id}, OP: {p.op_number}, IP: {p.ip_number}, Status: {p.status}, Name: {p.decrypted_name}")
        else:
            current_app.logger.info(f"No patients found matching '{search_query}'")

    # Apply access control filtering
    base_active_query = Patient.query.filter(Patient.status == 'active').filter(
        or_(Patient.discharge_state.is_(None), Patient.discharge_state != 'pending')
    )
    active_patients = filter_accessible_patients(base_active_query, current_user).order_by(Patient.created_at.desc()).all()
    
    base_completed_query = Patient.query.filter_by(status='completed')
    completed_patients = filter_accessible_patients(base_completed_query, current_user).order_by(Patient.updated_at.desc()).all()

    # Filter outpatients and inpatients
    # FIXED: Check for op_number/ip_number truthiness (not empty string)
    active_outpatients = [p for p in active_patients if p.op_number and not p.ip_number]
    active_inpatients = [p for p in active_patients if p.ip_number]
    completed_outpatients = [p for p in completed_patients if p.op_number and not p.ip_number]
    completed_inpatients = [p for p in completed_patients if p.ip_number]

    # Debug logging
    current_app.logger.info(f"Active patients count: {len(active_patients)}")
    current_app.logger.info(f"Active outpatients: {len(active_outpatients)}, Active inpatients: {len(active_inpatients)}")
    if active_outpatients:
        current_app.logger.info(f"Sample OP numbers: {[p.op_number for p in active_outpatients[:3]]}")

    return render_template(
        'doctor/patients.html',
        active_patients=active_patients,
        completed_patients=completed_patients,
        active_outpatients=active_outpatients,
        active_inpatients=active_inpatients,
        completed_outpatients=completed_outpatients,
        completed_inpatients=completed_inpatients,
    )


def _doctor_patient_category_query(category: str):
    """Shared filtering for doctor patient categories."""
    q = Patient.query
    category = (category or '').strip().lower()

    if category == 'outpatients':
        return q.filter(
            Patient.status == 'active',
            Patient.op_number.isnot(None),
            Patient.ip_number.is_(None),
        ).order_by(Patient.updated_at.desc(), Patient.id.desc())

    if category == 'inpatients':
        return q.filter(
            Patient.status == 'active',
            Patient.ip_number.isnot(None),
        ).order_by(Patient.updated_at.desc(), Patient.id.desc())

    if category == 'discharged':
        # Pending discharge requests (inpatients).
        return q.filter(
            Patient.status == 'active',
            Patient.ip_number.isnot(None),
            Patient.discharge_state == 'pending',
        ).order_by(Patient.discharge_requested_at.desc().nullslast(), Patient.updated_at.desc())

    if category == 'old_inpatients':
        return q.filter(
            Patient.status == 'completed',
            Patient.ip_number.isnot(None),
        ).order_by(Patient.updated_at.desc(), Patient.id.desc())

    if category == 'old_outpatients':
        return q.filter(
            Patient.status == 'completed',
            Patient.op_number.isnot(None),
            Patient.ip_number.is_(None),
        ).order_by(Patient.updated_at.desc(), Patient.id.desc())

    return q.order_by(Patient.updated_at.desc(), Patient.id.desc())


@app.route('/doctor/outpatients', methods=['GET'])
@login_required
def doctor_outpatients():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patients = filter_accessible_patients(_doctor_patient_category_query('outpatients'), current_user).all()
    return render_template('doctor/patient_category.html',
        title='Outpatients',
        category='outpatients',
        patients=patients,
    )


@app.route('/doctor/inpatients', methods=['GET'])
@login_required
def doctor_inpatients():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patients = filter_accessible_patients(_doctor_patient_category_query('inpatients'), current_user).all()
    return render_template('doctor/patient_category.html',
        title='Inpatients',
        category='inpatients',
        patients=patients,
    )


@app.route('/doctor/discharged', methods=['GET'])
@login_required
def doctor_discharged_queue():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patients = filter_accessible_patients(_doctor_patient_category_query('discharged'), current_user).all()
    return render_template('doctor/patient_category.html',
        title='Discharged (Pending Confirmation)',
        category='discharged',
        patients=patients,
    )


@app.route('/doctor/old-inpatients', methods=['GET'])
@login_required
def doctor_old_inpatients():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patients = filter_accessible_patients(_doctor_patient_category_query('old_inpatients'), current_user).all()
    return render_template('doctor/patient_category.html',
        title='Old Inpatients',
        category='old_inpatients',
        patients=patients,
    )


@app.route('/doctor/old-outpatients', methods=['GET'])
@login_required
def doctor_old_outpatients():
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patients = filter_accessible_patients(_doctor_patient_category_query('old_outpatients'), current_user).all()
    return render_template('doctor/patient_category.html',
        title='Old Outpatients',
        category='old_outpatients',
        patients=patients,
    )


@app.route('/doctor/patient/<int:patient_id>/request-discharge', methods=['POST'])
@login_required
def doctor_request_discharge(patient_id: int):
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patient = db.session.get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_inpatients'))

    if not patient.ip_number or patient.status != 'active':
        flash('Only active inpatients can be marked for discharge.', 'warning')
        return redirect(url_for('doctor_inpatients'))

    try:
        patient.discharge_state = 'pending'
        patient.discharge_requested_at = get_eat_now()
        patient.discharge_requested_by = current_user.id
        patient.updated_at = get_eat_now()
        db.session.commit()
        flash('Patient added to discharge queue.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Failed to request discharge: {str(e)}', 'danger')

    return redirect(url_for('doctor_discharged_queue'))


@app.route('/doctor/patient/<int:patient_id>/confirm-discharge', methods=['POST'])
@login_required
def doctor_confirm_discharge(patient_id: int):
    if current_user.role != 'doctor':
        flash('Unauthorized', 'danger')
        return redirect(url_for('home'))

    patient = db.session.get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_discharged_queue'))

    if not patient.ip_number or patient.status != 'active':
        flash('Only active inpatients can be discharged.', 'warning')
        return redirect(url_for('doctor_discharged_queue'))

    # Enforce pay-before-discharge for ward stays (same logic as /complete).
    try:
        ctx = _get_patient_bed_stay_context(patient.id)
        if ctx:
            daily_rate = float(ctx.get('daily_rate') or 0)
            if daily_rate > 0:
                bed_id = int(ctx['bed_id'])
                start_date = ctx['start_date']
                end_date = ctx['end_date']

                last = (
                    BedStayCharge.query
                    .filter_by(bed_id=bed_id, patient_id=patient.id)
                    .order_by(BedStayCharge.charge_end_date.desc())
                    .first()
                )
                last_end = last.charge_end_date if last else None
                bill_start = start_date
                if last_end:
                    bill_start = max(bill_start, last_end + timedelta(days=1))

                if bill_start <= end_date:
                    days_due = (end_date - bill_start).days + 1
                else:
                    days_due = 0

                if days_due > 0 and not _ward_stay_is_paid_through(patient.id, bed_id, end_date):
                    amount_due = float(days_due) * daily_rate
                    flash(
                        'Cannot discharge: ward stay charges are unpaid. '
                        f"Ward: {ctx.get('ward_name') or '-'}, Bed: {ctx.get('bed_number') or '-'}, "
                        f"Days due: {int(days_due)}, Amount: {amount_due:.2f}. "
                        'Please bill/pay ward stay then retry.',
                        'warning'
                    )
                    return redirect(url_for('patient_ward_bill', patient_id=patient.id))
    except Exception:
        pass

    try:
        patient.status = 'completed'
        patient.discharge_state = 'discharged'
        patient.discharged_at = get_eat_now()
        patient.discharged_by = current_user.id
        patient.updated_at = get_eat_now()
        db.session.commit()
        flash('Patient discharged successfully.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Failed to discharge patient: {str(e)}', 'danger')

    return redirect(url_for('doctor_old_inpatients'))


@app.route('/doctor/notifications/tca_today', methods=['GET'])
@login_required
def doctor_notifications_tca_today():
    """Return a count + list of patients whose TCA date is today."""
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    today = get_eat_today()
    patients = Patient.query.filter(Patient.tca == today).order_by(Patient.updated_at.desc(), Patient.id.desc()).all()

    payload = []
    for p in patients:
        payload.append({
            'id': p.id,
            'name': p.decrypted_name,
            'phone': p.decrypted_phone,
            'op_number': p.op_number,
            'ip_number': p.ip_number,
            'destination': p.destination,
            'status': p.status,
        })

    return jsonify({'success': True, 'count': len(payload), 'patients': payload})


@app.route('/doctor/patient/<int:patient_id>/view_sections', methods=['GET'])
@login_required
def doctor_patient_view_sections(patient_id: int):
    """Return a quick status snapshot of key sections for the Patients list."""
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    review = PatientReviewSystem.query.filter_by(patient_id=patient.id).order_by(PatientReviewSystem.created_at.desc(), PatientReviewSystem.id.desc()).first()
    history = PatientHistory.query.filter_by(patient_id=patient.id).order_by(PatientHistory.created_at.desc(), PatientHistory.id.desc()).first()
    exam = PatientExamination.query.filter_by(patient_id=patient.id).order_by(PatientExamination.created_at.desc(), PatientExamination.id.desc()).first()
    diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).order_by(PatientDiagnosis.created_at.desc(), PatientDiagnosis.id.desc()).first()
    management = PatientManagement.query.filter_by(patient_id=patient.id).order_by(PatientManagement.created_at.desc(), PatientManagement.id.desc()).first()

    prescriptions_count = Prescription.query.filter_by(patient_id=patient.id).count()
    lab_count = LabRequest.query.filter_by(patient_id=patient.id).count()
    imaging_count = ImagingRequest.query.filter_by(patient_id=patient.id).count()
    summaries_count = PatientSummary.query.filter_by(patient_id=patient.id).count()

    progression_parts = []
    progression_parts.append('Chief complaint: ✓' if (patient.chief_complaint or '').strip() else 'Chief complaint: —')
    progression_parts.append('HPI: ✓' if (patient.history_present_illness or '').strip() else 'HPI: —')
    progression_parts.append(f"Status: {patient.status or 'N/A'}")

    findings_parts = []
    findings_parts.append('ROS: ✓' if review else 'ROS: —')
    findings_parts.append('History: ✓' if history else 'History: —')
    findings_parts.append('Exam: ✓' if exam else 'Exam: —')
    findings_parts.append('Dx: ✓' if diagnosis else 'Dx: —')
    findings_parts.append('Mgmt: ✓' if management else 'Mgmt: —')
    findings_parts.append(f"Summaries: {summaries_count}")

    prescriptions_parts = []
    prescriptions_parts.append(f"Prescriptions: {prescriptions_count}")
    prescriptions_parts.append(f"Lab requests: {lab_count}")
    prescriptions_parts.append(f"Imaging requests: {imaging_count}")

    return jsonify(
        {
            'success': True,
            'sections': {
                'progression': ' | '.join(progression_parts),
                'findings': ' | '.join(findings_parts),
                'prescriptions': ' | '.join(prescriptions_parts),
            },
        }
    )

@app.route('/doctor/patient/<int:patient_id>/summary', methods=['GET', 'POST'])
@login_required
def patient_summary(patient_id):
    if current_user.role not in ['doctor', 'admin']:
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'add_manual':
            try:
                summary_text = request.form.get('summary_text')
                if not summary_text:
                    return jsonify({'success': False, 'error': 'Summary text is required'}), 400
                
                summary = PatientSummary(
                    patient_id=patient.id,
                    summary_text=summary_text,
                    summary_type='manual'
                )
                db.session.add(summary)
                db.session.commit()
                
                return jsonify({'success': True, 'message': 'Summary saved successfully'})
                
            except Exception as e:
                db.session.rollback()
                return jsonify({'success': False, 'error': str(e)}), 500
        
        elif action == 'generate_ai':
            try:
                # Collect all patient data for summary generation
                review_systems = db.session.execute(
                    db.select(PatientReviewSystem).filter_by(patient_id=patient.id)
                ).scalar()
                
                history = db.session.execute(
                    db.select(PatientHistory).filter_by(patient_id=patient.id)
                ).scalar()
                
                examination = db.session.execute(
                    db.select(PatientExamination).filter_by(patient_id=patient.id)
                ).scalar()
                
                diagnosis = db.session.execute(
                    db.select(PatientDiagnosis).filter_by(patient_id=patient.id)
                ).scalar()

                patient_data = {
                    'name': patient.get_decrypted_name,
                    'age': patient.age,
                    'gender': patient.gender,
                    'address': patient.get_decrypted_address or '',
                    'occupation': patient.get_decrypted_occupation or '',
                    'religion': patient.religion or '',
                    'chief_complaint': patient.chief_complaint or '',
                    'history_present_illness': patient.history_present_illness or '',
                    'review_systems': {
                        'cns': review_systems.cns if review_systems else '',
                        'cvs': review_systems.cvs if review_systems else '',
                        'rs': review_systems.rs if review_systems else '',
                        'git': review_systems.git if review_systems else '',
                        'gut': review_systems.gut if review_systems else '',
                        'skin': review_systems.skin if review_systems else '',
                        'msk': review_systems.msk if review_systems else ''
                    } if review_systems else {},
                    'social_history': history.social_history if history else '',
                    'medical_history': history.medical_history if history else '',
                    'surgical_history': history.surgical_history if history else '',
                    'family_history': history.family_history if history else '',
                    'allergies': history.allergies if history else '',
                    'medications': history.medications if history else '',
                    'examination': {
                        'general_appearance': examination.general_appearance if examination else '',
                        'vitals': {
                            'temperature': examination.temperature if examination else None,
                            'pulse': examination.pulse if examination else None,
                            'bp': f"{examination.bp_systolic}/{examination.bp_diastolic}" if examination and examination.bp_systolic and examination.bp_diastolic else None,
                            'resp_rate': examination.resp_rate if examination else None,
                            'spo2': examination.spo2 if examination else None
                        },
                        'systems': {
                            'cvs': examination.cvs_exam if examination else '',
                            'respiratory': examination.resp_exam if examination else '',
                            'abdominal': examination.abdo_exam if examination else '',
                            'cns': examination.cns_exam if examination else ''
                        }
                    } if examination else {},
                    'working_diagnosis': diagnosis.working_diagnosis if diagnosis else ''
                }
                
                summary_text = AIService.generate_patient_summary(patient_data)
                if not summary_text:
                    return jsonify({'success': False, 'error': 'AI service unavailable. Check AI key/config and try again.'}), 503
                
                # Save AI-generated summary
                summary = PatientSummary(
                    patient_id=patient.id,
                    summary_text=summary_text,
                    summary_type='ai_generated',
                    generated_by=current_user.id
                )
                db.session.add(summary)
                db.session.commit()
                
                return jsonify({
                    'success': True, 
                    'summary_text': summary_text,
                    'message': 'AI summary generated successfully'
                })

            except (APITimeoutError, httpx.TimeoutException, TimeoutError):
                db.session.rollback()
                current_app.logger.error('AI Summary Generation Error: Request timed out.', exc_info=True)
                return jsonify({
                    'success': False,
                    'error': 'AI service timeout. Please try again in a moment.'
                }), 504

            except (APIConnectionError, APIError) as e:
                db.session.rollback()
                current_app.logger.error(f"AI Summary Generation Error: {str(e)}", exc_info=True)
                return jsonify({
                    'success': False,
                    'error': 'AI service error. Please try again later.'
                }), 502

            except Exception as e:
                db.session.rollback()
                current_app.logger.error(f"AI Summary Generation Error: {str(e)}", exc_info=True)
                return jsonify({'success': False, 'error': 'Internal server error'}), 500
        
        elif action == 'generate_diagnosis':
            try:
                # Get the latest summary
                latest_summary = db.session.execute(
                    db.select(PatientSummary)
                    .filter_by(patient_id=patient.id)
                    .order_by(PatientSummary.created_at.desc())
                ).scalar()
                
                if not latest_summary:
                    return jsonify({'success': False, 'error': 'No summary available for diagnosis generation'}), 400
                
                diagnosis_text = AIService.generate_diagnosis_from_summary(latest_summary.summary_text)
                if not diagnosis_text:
                    return jsonify({'success': False, 'error': 'Failed to generate diagnosis from summary'}), 500
                
                # Update patient's AI diagnosis
                patient.ai_diagnosis = diagnosis_text
                patient.ai_last_updated = get_eat_now()
                patient.ai_assistance_enabled = True
                
                # Also update the diagnosis record if exists
                diagnosis_record = db.session.execute(
                    db.select(PatientDiagnosis).filter_by(patient_id=patient.id)
                ).scalar()
                
                if not diagnosis_record:
                    diagnosis_record = PatientDiagnosis(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(diagnosis_record)
                elif not getattr(diagnosis_record, 'created_by', None):
                    diagnosis_record.created_by = current_user.id
                
                diagnosis_record.ai_supported_diagnosis = True
                diagnosis_record.ai_alternative_diagnoses = diagnosis_text
                
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'diagnosis': diagnosis_text,
                    'message': 'Diagnosis generated from summary successfully'
                })
                
            except Exception as e:
                db.session.rollback()
                return jsonify({'success': False, 'error': str(e)}), 500
    
    # GET request - return summary data
    summaries = db.session.execute(
        db.select(PatientSummary)
        .filter_by(patient_id=patient.id)
        .order_by(PatientSummary.created_at.desc())
    ).scalars().all()
    
    summaries_data = []
    for summary in summaries:
        # Get generator username safely
        generator_name = 'Manual'
        if summary.generated_by:
            generator = db.session.get(User, summary.generated_by)
            generator_name = generator.username if generator else 'System'
        
        summaries_data.append({
            'id': summary.id,
            'summary_text': summary.summary_text,
            'summary_type': summary.summary_type,
            'created_at': summary.created_at.strftime('%Y-%m-%d %H:%M'),
            'generated_by': generator_name
        })
    
    return jsonify({
        'success': True,
        'summaries': summaries_data,
        'patient_name': patient.get_decrypted_name,
        'patient_number': patient.op_number or patient.ip_number
    })

@app.route('/doctor/patient/<int:patient_id>/summary/<int:summary_id>', methods=['DELETE'])
@login_required
def delete_patient_summary(patient_id, summary_id):
    if current_user.role not in ['doctor', 'admin']:
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    summary = db.session.get(PatientSummary, summary_id)
    if not summary or summary.patient_id != patient_id:
        return jsonify({'success': False, 'error': 'Summary not found'}), 404
    
    try:
        db.session.delete(summary)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Summary deleted successfully'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/doctor/patient/<int:patient_id>/summary/generate-diagnosis', methods=['POST'])
@login_required
def doctor_generate_diagnosis_from_specific_summary(patient_id):
    """Generate diagnosis from a specific summary (called from frontend)"""
    if current_user.role not in ['doctor', 'admin']:
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        # Get summary_id from request
        data = request.get_json(silent=True) or {}
        summary_id = data.get('summary_id')
        
        if not summary_id:
            # Use latest summary if no specific ID provided
            summary = PatientSummary.query.filter_by(patient_id=patient_id).order_by(PatientSummary.created_at.desc()).first()
        else:
            summary = db.session.get(PatientSummary, summary_id)
            if not summary or summary.patient_id != patient_id:
                return jsonify({'success': False, 'error': 'Summary not found'}), 404
        
        if not summary:
            return jsonify({'success': False, 'error': 'No summary found for this patient'}), 404
        
        # Get basic patient info for context
        patient_basic_info = {
            'age': patient.age,
            'gender': patient.gender,
            'name': patient.get_decrypted_name
        }
        
        # Use AI to generate diagnosis from summary
        try:
            diagnosis_text = AIService.generate_diagnosis_from_summary(
                summary.summary_text or '',
                patient_basic_info
            )
            if not diagnosis_text:
                return jsonify({'success': False, 'error': 'AI service unavailable. Please try again later.'}), 503
        except Exception as ai_error:
            return jsonify({'success': False, 'error': f'AI generation failed: {str(ai_error)}'}), 500
        
        # Create new diagnosis entry
        diagnosis = PatientDiagnosis(
            patient_id=patient_id,
            working_diagnosis=diagnosis_text,
            created_by=current_user.id,
        )
        db.session.add(diagnosis)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Diagnosis generated from summary successfully',
            'diagnosis': diagnosis_text
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

# Doctor Routes - Complete with all sections
@app.route('/doctor/patient', methods=['POST'])
@login_required
def doctor_create_patient():
    """Create a patient from JSON payload.

    This endpoint exists to support newer UI flows that submit JSON to
    `/doctor/patient` (as opposed to the multi-step form at `/doctor/patient/new`).
    """
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    payload = request.get_json(silent=True) or {}
    biodata = payload.get('bioData') or payload.get('biodata') or {}

    def _parse_date(value):
        try:
            s = str(value).strip()
            return datetime.strptime(s, '%Y-%m-%d').date() if s else None
        except Exception:
            return None

    patient_type = (biodata.get('patient_type') or biodata.get('patientType') or 'OP').strip().upper()
    if patient_type not in ('OP', 'IP'):
        patient_type = 'OP'

    name = (biodata.get('name') or '').strip()
    if not name:
        return jsonify({'success': False, 'error': 'Patient name is required'}), 400

    # Optional insurance capture at registration (provider must exist in system)
    def _parse_bool(value, default=False):
        try:
            if value is None:
                return default
            if isinstance(value, bool):
                return value
            s = str(value).strip().lower()
            if s in ('1', 'true', 'yes', 'on'):
                return True
            if s in ('0', 'false', 'no', 'off'):
                return False
        except Exception:
            pass
        return default

    insurance_provider_id = payload.get('insurance_provider_id') or biodata.get('insurance_provider_id') or biodata.get('insuranceProviderId')
    insurance_policy_number = (payload.get('insurance_policy_number') or biodata.get('insurance_policy_number') or biodata.get('policy_number') or '').strip()
    insurance_member_number = (payload.get('insurance_member_number') or biodata.get('insurance_member_number') or biodata.get('member_number') or '').strip()
    insurance_covers_inpatient = _parse_bool(payload.get('insurance_covers_inpatient') or biodata.get('insurance_covers_inpatient'), default=True)

    try:
        patient_number = generate_patient_number(patient_type)

        patient = Patient(
            op_number=patient_number if patient_type == 'OP' else None,
            ip_number=patient_number if patient_type == 'IP' else None,
            name=Config.encrypt_data_static(name),
            age=_parse_age_years(biodata.get('age')),
            gender=(biodata.get('gender') or None),
            address=Config.encrypt_data_static(biodata.get('address')) if biodata.get('address') else None,
            phone=Config.encrypt_data_static(biodata.get('phone')) if biodata.get('phone') else None,
            destination=biodata.get('destination') or None,
            occupation=Config.encrypt_data_static(biodata.get('occupation')) if biodata.get('occupation') else None,
            religion=biodata.get('religion') or None,
            nok_name=Config.encrypt_data_static(biodata.get('nok_name') or biodata.get('nokName'))
            if (biodata.get('nok_name') or biodata.get('nokName'))
            else None,
            nok_contact=Config.encrypt_data_static(biodata.get('nok_contact') or biodata.get('nokContact'))
            if (biodata.get('nok_contact') or biodata.get('nokContact'))
            else None,
            tca=_parse_date(biodata.get('tca')),
            date_of_admission=_parse_date(biodata.get('date_of_admission') or biodata.get('dateOfAdmission'))
            or date.today(),
            status='active',
        )

        # Optional fields if present in payload
        if biodata.get('chief_complaint'):
            patient.chief_complaint = biodata.get('chief_complaint')
        if biodata.get('history_present_illness'):
            patient.history_present_illness = biodata.get('history_present_illness')

        db.session.add(patient)
        db.session.flush()  # Get patient.id without final commit yet

        # Capture insurance at registration (best-effort). Provider must be from admin list.
        try:
            if insurance_provider_id and (insurance_policy_number or insurance_member_number):
                try:
                    pid = int(insurance_provider_id)
                except Exception:
                    pid = None
                provider = db.session.get(InsuranceProvider, pid) if pid else None
                if provider:
                    policy = InsurancePolicy(
                        patient_id=patient.id,
                        provider_id=provider.id,
                        policy_number=insurance_policy_number or None,
                        member_number=insurance_member_number or None,
                        active=True,
                        start_date=date.today(),
                        notes=f"Captured at registration by Dr. {getattr(current_user, 'full_name', '')}".strip() or None,
                        created_at=get_eat_now(),
                    )
                    _insurance_policy_set_covers_inpatient(policy, bool(insurance_covers_inpatient))

                    # If patient is being created as IP and insurance doesn't cover inpatient, keep it inactive.
                    if patient_type == 'IP' and not bool(insurance_covers_inpatient):
                        policy.active = False

                    # Deactivate other active policies if this one is active
                    if policy.active:
                        try:
                            InsurancePolicy.query.filter_by(patient_id=patient.id, active=True).update({'active': False})
                        except Exception:
                            pass

                    db.session.add(policy)
        except Exception:
            pass

        # Optional: create lab requests if provided
        lab_tests = payload.get('labTests') or []
        if isinstance(lab_tests, list) and lab_tests:
            for item in lab_tests:
                if not isinstance(item, dict):
                    continue
                test_id = item.get('test_id') or item.get('testId') or item.get('id')
                try:
                    test_id = int(test_id)
                except Exception:
                    continue
                notes = item.get('notes') or None

                # Ensure test exists to avoid FK errors
                test = db.session.get(LabTest, test_id)
                if not test:
                    continue
                
                lab_request = LabRequest(
                    patient_id=patient.id,
                    test_id=test_id,
                    requested_by=current_user.id,
                    status='pending',
                    notes=notes,
                )
                db.session.add(lab_request)

                # Create financial records
                try:
                    create_service_sale_and_transaction(
                        patient_id=patient.id,
                        service_item=test,
                        service_type='lab',
                        requested_by_id=current_user.id,
                        notes=notes
                    )
                except Exception as e:
                    # The helper function rolls back, so we just need to bubble up the error
                    current_app.logger.error(f"Could not create transaction for lab request during patient creation: {str(e)}")
                    raise


        # Optional: create prescription if provided
        prescriptions = payload.get('prescriptions') or []
        if isinstance(prescriptions, list) and prescriptions:
            prescription = Prescription(
                patient_id=patient.id,
                doctor_id=current_user.id,
                notes=payload.get('prescriptionNotes') or None,
                status='pending',
            )
            db.session.add(prescription)
            db.session.flush()

            for item in prescriptions:
                if not isinstance(item, dict):
                    continue
                drug_id = item.get('drug_id') or item.get('drugId')
                try:
                    drug_id = int(drug_id) if drug_id is not None else None
                except Exception:
                    drug_id = None
                if drug_id is None:
                    continue

                drug = db.session.get(Drug, drug_id)
                if not drug:
                    continue

                quantity = _parse_int(item.get('quantity')) or 1
                db.session.add(
                    PrescriptionItem(
                        prescription_id=prescription.id,
                        drug_id=drug_id,
                        quantity=quantity,
                        dosage=item.get('dosage') or None,
                        frequency=item.get('frequency') or None,
                        duration=item.get('duration') or None,
                        notes=item.get('notes') or None,
                        status='pending',
                    )
                )

        db.session.commit()

        return jsonify(
            {
                'success': True,
                'patient_id': patient.id,
                'patient_number': patient.op_number or patient.ip_number,
            }
        )
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/doctor/patient/new', methods=['GET', 'POST'])
@login_required
def doctor_new_patient():
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    if request.method == 'POST':
        section = request.form.get('section')
        patient_id = request.form.get('patient_id')
        
        try:
            if section == 'biodata':
                raw_patient_type = request.form.get('patient_type')
                patient_type = (raw_patient_type or '').strip().upper()
                if patient_type not in {'OP', 'IP'}:
                    # Fallback to query param (e.g., /doctor/outpatients -> ?patient_type=OP)
                    arg_type = (request.args.get('patient_type') or '').strip().upper()
                    patient_type = arg_type if arg_type in {'OP', 'IP'} else 'OP'

                patient_number = generate_patient_number(patient_type)

                insurance_provider_id = request.form.get('insurance_provider_id', type=int)
                insurance_policy_number = (request.form.get('insurance_policy_number') or '').strip()
                insurance_member_number = (request.form.get('insurance_member_number') or '').strip()
                insurance_covers_inpatient = request.form.get('insurance_covers_inpatient') in ('1', 'true', 'True', 'on', 'yes')
                
                patient = Patient(
                    op_number=patient_number if patient_type == 'OP' else None,
                    ip_number=patient_number if patient_type == 'IP' else None,
                    name=Config.encrypt_data_static(request.form.get('name')),
                    age=_parse_age_years(request.form.get('age')),
                    gender=request.form.get('gender'),
                    address=Config.encrypt_data_static(request.form.get('address')) if request.form.get('address') else None,
                    phone=Config.encrypt_data_static(request.form.get('phone')) if request.form.get('phone') else None,
                    destination=request.form.get('destination'),
                    occupation=Config.encrypt_data_static(request.form.get('occupation')) if request.form.get('occupation') else None,
                    religion=request.form.get('religion'),
                    nok_name=Config.encrypt_data_static(request.form.get('nok_name')) if request.form.get('nok_name') else None,
                    nok_contact=Config.encrypt_data_static(request.form.get('nok_contact')) if request.form.get('nok_contact') else None,
                    tca=datetime.strptime(request.form.get('tca'), '%Y-%m-%d').date() if request.form.get('tca') else None,
                    date_of_admission=datetime.strptime(request.form.get('date_of_admission'), '%Y-%m-%d').date() if request.form.get('date_of_admission') else date.today(),
                    status='active'
                )
                db.session.add(patient)
                db.session.flush()

                # Insurance capture at patient registration (best-effort)
                try:
                    if insurance_provider_id and (insurance_policy_number or insurance_member_number):
                        provider = db.session.get(InsuranceProvider, int(insurance_provider_id))
                        if provider:
                            policy = InsurancePolicy(
                                patient_id=patient.id,
                                provider_id=provider.id,
                                policy_number=insurance_policy_number or None,
                                member_number=insurance_member_number or None,
                                active=True,
                                start_date=date.today(),
                                notes=f"Captured at registration by Dr. {getattr(current_user, 'full_name', '')}".strip() or None,
                                created_at=get_eat_now(),
                            )
                            _insurance_policy_set_covers_inpatient(policy, bool(insurance_covers_inpatient))

                            # If created as IP and doesn't cover inpatient, keep inactive so reception won't use it.
                            if (patient_type or '').strip().upper() == 'IP' and not bool(insurance_covers_inpatient):
                                policy.active = False

                            if policy.active:
                                try:
                                    InsurancePolicy.query.filter_by(patient_id=patient.id, active=True).update({'active': False})
                                except Exception:
                                    pass
                            db.session.add(policy)
                except Exception:
                    pass

                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'patient_id': patient.id,
                    'patient_number': patient.op_number or patient.ip_number,
                    'next_section': 'chief_complaint'
                })

            elif section == 'chief_complaint':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                chief_complaint = (request.form.get('chief_complaint') or '').strip()
                hpi_text = (request.form.get('history_present_illness') or '').strip()

                patient.chief_complaint = chief_complaint or None
                patient.history_present_illness = hpi_text or None

                # Capture attribution for the initial wizard-entered values.
                if chief_complaint:
                    db.session.add(PatientChiefComplaintEntry(
                        patient_id=patient.id,
                        complaint_text=chief_complaint,
                        created_by=current_user.id,
                    ))
                if hpi_text:
                    db.session.add(PatientHPIEntry(
                        patient_id=patient.id,
                        hpi_text=hpi_text,
                        created_by=current_user.id,
                    ))
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'review_systems'
                })
                
            elif section == 'review_systems':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                review = PatientReviewSystem.query.filter_by(patient_id=patient.id).first()
                if not review:
                    review = PatientReviewSystem(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(review)

                if not getattr(review, 'created_by', None):
                    review.created_by = current_user.id
                
                review.cns = request.form.get('cns')
                review.cvs = request.form.get('cvs')
                review.rs = request.form.get('rs')
                review.git = request.form.get('git')
                review.gut = request.form.get('gut')
                review.skin = request.form.get('skin')
                review.msk = request.form.get('msk')
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'hpi'
                })

            elif section == 'hpi':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                patient.history_present_illness = request.form.get('hpi_details')
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'smhx'
                })

            elif section == 'smhx':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                smhx = PatientHistory.query.filter_by(patient_id=patient.id).first()
                if not smhx:
                    smhx = PatientHistory(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(smhx)

                if not getattr(smhx, 'created_by', None):
                    smhx.created_by = current_user.id
                
                smhx.social_history = request.form.get('social_history')
                smhx.medical_history = request.form.get('medical_history')
                smhx.surgical_history = request.form.get('surgical_history')
                smhx.family_history = request.form.get('family_history')
                smhx.allergies = request.form.get('allergies')
                smhx.medications = request.form.get('medications')
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'examination'
                })

            elif section == 'examination':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                exam = PatientExamination.query.filter_by(patient_id=patient.id).first()
                if not exam:
                    exam = PatientExamination(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(exam)

                if not getattr(exam, 'created_by', None):
                    exam.created_by = current_user.id
                
                exam.general_appearance = request.form.get('general_appearance')
                exam.jaundice = request.form.get('jaundice') == 'yes'
                exam.pallor = request.form.get('pallor') == 'yes'
                exam.cyanosis = request.form.get('cyanosis') == 'yes'
                exam.lymphadenopathy = request.form.get('lymphadenopathy') == 'yes'
                exam.edema = request.form.get('edema') == 'yes'
                exam.dehydration = request.form.get('dehydration') == 'yes'
                exam.dehydration_parameters = request.form.get('dehydration_parameters')
                exam.temperature = float(request.form.get('temperature')) if request.form.get('temperature') else None
                exam.pulse = int(request.form.get('pulse')) if request.form.get('pulse') else None
                exam.resp_rate = int(request.form.get('resp_rate')) if request.form.get('resp_rate') else None
                exam.bp_systolic = int(request.form.get('bp_systolic')) if request.form.get('bp_systolic') else None
                exam.bp_diastolic = int(request.form.get('bp_diastolic')) if request.form.get('bp_diastolic') else None
                exam.spo2 = int(request.form.get('spo2')) if request.form.get('spo2') else None
                exam.weight = float(request.form.get('weight')) if request.form.get('weight') else None
                exam.height = float(request.form.get('height')) if request.form.get('height') else None
                exam.bmi = float(request.form.get('bmi')) if request.form.get('bmi') else None
                exam.cvs_exam = request.form.get('cvs_exam')
                exam.resp_exam = request.form.get('resp_exam')
                exam.abdo_exam = request.form.get('abdo_exam')
                exam.cns_exam = request.form.get('cns_exam')
                exam.msk_exam = request.form.get('msk_exam')
                exam.skin_exam = request.form.get('skin_exam')
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'summary'  # Now goes to summary after examination
                })

            elif section == 'diagnosis':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})

                diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).first()
                if not diagnosis:
                    diagnosis = PatientDiagnosis(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(diagnosis)

                if not getattr(diagnosis, 'created_by', None):
                    diagnosis.created_by = current_user.id

                diagnosis.working_diagnosis = request.form.get('working_diagnosis')
                diagnosis.differential_diagnosis = request.form.get('differential_diagnosis')
                diagnosis.working_diagnosis_supporting_argument = request.form.get(
                    'working_diagnosis_supporting_argument'
                )
                diagnosis.differential_diagnosis_supporting_argument = request.form.get(
                    'differential_diagnosis_supporting_argument'
                )
                db.session.commit()

                return jsonify({
                    'success': True,
                    'next_section': 'management'
                })

            elif section == 'management':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})

                management = PatientManagement.query.filter_by(patient_id=patient.id).first()
                if not management:
                    management = PatientManagement(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(management)

                if not getattr(management, 'created_by', None):
                    management.created_by = current_user.id

                management.treatment_plan = request.form.get('treatment_plan')
                management.follow_up = request.form.get('follow_up')
                management.notes = request.form.get('management_notes')
                db.session.commit()

                return jsonify({
                    'success': True,
                    'redirect': url_for('doctor_patient_details', patient_id=patient.id)
                })

            elif section == 'summary':  # MOVED TO AFTER EXAMINATION
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                # Get the clinical summary (optional - can be empty)
                clinical_summary = request.form.get('patient_summary', '').strip()
                
                # Only save if summary is provided
                if clinical_summary:
                    summary = PatientSummary(
                        patient_id=patient.id,
                        summary_text=clinical_summary,
                        summary_type='manual',
                        generated_by=current_user.id
                    )
                    db.session.add(summary)
                    db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'diagnosis'  # Now goes to diagnosis after summary
                })

            elif section == 'diagnosis':  # NOW AFTER SUMMARY
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).first()
                if not diagnosis:
                    diagnosis = PatientDiagnosis(patient_id=patient.id, created_by=current_user.id)
                    db.session.add(diagnosis)

                if not getattr(diagnosis, 'created_by', None):
                    diagnosis.created_by = current_user.id
                
                diagnosis.working_diagnosis = request.form.get('working_diagnosis')
                diagnosis.differential_diagnosis = request.form.get('differential_diagnosis')
                diagnosis.working_diagnosis_supporting_argument = request.form.get(
                    'working_diagnosis_supporting_argument'
                )
                diagnosis.differential_diagnosis_supporting_argument = request.form.get(
                    'differential_diagnosis_supporting_argument'
                )
                
                # Lab requests
                if request.form.getlist('lab_tests'):
                    for test_id in request.form.getlist('lab_tests'):
                        test = db.session.get(LabTest, int(test_id))
                        if not test:
                            continue

                        lab_request = LabRequest(
                            patient_id=patient.id,
                            test_id=test.id,
                            requested_by=current_user.id,
                            status='pending',
                            notes=request.form.get('lab_notes')
                        )
                        db.session.add(lab_request)

                        # Create financial records
                        try:
                            create_service_sale_and_transaction(
                                patient_id=patient.id,
                                service_item=test,
                                service_type='lab',
                                requested_by_id=current_user.id,
                                notes=request.form.get('lab_notes')
                            )
                        except Exception as e:
                            db.session.rollback()
                            current_app.logger.error(f"Could not create transaction for lab request in new patient flow: {str(e)}")
                            return jsonify({'success': False, 'error': 'Failed to create financial record for lab test.'}), 500

                
                # Imaging requests
                if request.form.getlist('imaging_tests'):
                    for test_id in request.form.getlist('imaging_tests'):
                        test = db.session.get(ImagingTest, int(test_id))
                        if not test:
                            continue

                        imaging_request = ImagingRequest(
                            patient_id=patient.id,
                            test_id=test.id,
                            requested_by=current_user.id,
                            status='pending',
                            notes=request.form.get('imaging_notes')
                        )
                        db.session.add(imaging_request)

                        # Create financial records
                        try:
                            create_service_sale_and_transaction(
                                patient_id=patient.id,
                                service_item=test,
                                service_type='imaging',
                                requested_by_id=current_user.id,
                                notes=request.form.get('imaging_notes')
                            )
                        except Exception as e:
                            db.session.rollback()
                            current_app.logger.error(f"Could not create transaction for imaging request in new patient flow: {str(e)}")
                            return jsonify({'success': False, 'error': 'Failed to create financial record for imaging test.'}), 500

                
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'next_section': 'management'
                })

            elif section == 'management':
                patient = db.session.get(Patient, patient_id)
                if not patient:
                    return jsonify({'success': False, 'error': 'Patient not found'})
                
                management = PatientManagement.query.filter_by(patient_id=patient.id).first()
                if not management:
                    management = PatientManagement(patient_id=patient.id)
                    db.session.add(management)
                
                management.treatment_plan = request.form.get('treatment_plan')
                management.follow_up = request.form.get('follow_up')
                management.notes = request.form.get('management_notes')
                
                # Prescriptions
                if request.form.getlist('drug_id'):
                    for i, drug_id in enumerate(request.form.getlist('drug_id')):
                        prescription = Prescription(
                            patient_id=patient.id,
                            drug_id=drug_id,
                            doctor_id=current_user.id,
                            dosage=request.form.getlist('dosage')[i],
                            frequency=request.form.getlist('frequency')[i],
                            duration=request.form.getlist('duration')[i],
                            quantity=request.form.getlist('quantity')[i],
                            notes=request.form.getlist('prescription_notes')[i]
                        )
                        db.session.add(prescription)
                
                # Services
                if request.form.getlist('service_id'):
                    for service_id in request.form.getlist('service_id'):
                        service_record = PatientService(
                            patient_id=patient.id,
                            service_id=service_id,
                            status='requested',
                            requested_by=current_user.id,
                            performed_by=current_user.id,
                            notes=request.form.get('service_notes')
                        )
                        db.session.add(service_record)
                
                db.session.commit()
                
                return jsonify({
                    'success': True,
                    'redirect': url_for('doctor_patient_details', patient_id=patient.id)
                })

        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Patient form error: {str(e)}")
            return jsonify({
                'success': False,
                'error': str(e)
            })

    # For GET request - render the form
    lab_tests = LabTest.query.all()
    imaging_tests = ImagingTest.query.all()
    drugs = Drug.query.filter(Drug.remaining_quantity > 0).all()
    try:
        controlled_drugs = ControlledDrug.query.filter(ControlledDrug.remaining_quantity > 0).all()
    except Exception:
        controlled_drugs = []
    services = Service.query.all()

    preset_patient_type_raw = request.args.get('patient_type')
    preset_patient_type = (preset_patient_type_raw or '').strip().upper()

    # Default to outpatient for doctors so they don't have to select every time.
    # If a caller needs IP they can pass ?patient_type=IP.
    if not preset_patient_type:
        preset_patient_type = 'OP'

    raw_is_valid = (preset_patient_type_raw or '').strip().upper() in {'OP', 'IP'}
    if not raw_is_valid and (preset_patient_type_raw or '').strip():
        # Invalid explicit type: fall back to OP but don't lock.
        preset_patient_type = 'OP'

    lock_patient_type_requested = str(request.args.get('lock_patient_type') or '').strip() in {'1', 'true', 'True', 'yes', 'on'}
    lock_patient_type = bool(lock_patient_type_requested and raw_is_valid)
    
    try:
        insurance_providers = InsuranceProvider.query.order_by(InsuranceProvider.name).all()
    except Exception:
        insurance_providers = []

    return render_template('doctor/new_patient.html',
        lab_tests=lab_tests,
        imaging_tests=imaging_tests,
        drugs=drugs,
        controlled_drugs=controlled_drugs,
        services=services,
        insurance_providers=insurance_providers,
        current_date=date.today().strftime('%Y-%m-%d'),
        preset_patient_type=preset_patient_type,
        lock_patient_type=lock_patient_type,
    )

# Assistant Assistant for diagnosis and treatment suggestions
# NOTE: This legacy class previously overwrote the primary AIService defined earlier in this file.
# It is kept only to avoid merge-loss, but it must NOT shadow the main AIService.

class DoctorAIServiceLegacy:
    @staticmethod
    def generate_review_systems_questions(patient_data):
        """Generate review of systems questions based on patient data"""
        try:
            # Use a default model if none is specified
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Based on the following patient information, generate relevant review of systems questions:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            - Occupation: {patient_data.get('occupation', 'Not specified')}
            
            Generate 5-8 specific, targeted questions that would help in the review of systems for this patient.
            Format the response as a bulleted list.
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI Review Systems Error: {str(e)}")
            return None

    @staticmethod
    def generate_hpi_questions(patient_data):
        """Generate HPI questions based on patient data"""
        try:
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Based on the following patient information, generate relevant History of Present Illness (HPI) questions:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            
            Generate 5-8 specific questions that would help elaborate the history of present illness.
            Focus on the chronology, quality, severity, and associated symptoms.
            Format the response as a bulleted list.
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=500,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI HPI Questions Error: {str(e)}")
            return None

    @staticmethod
    def generate_hpi_content(patient_data):
        """Generate HPI content based on patient data"""
        try:
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Based on the following patient information, generate a comprehensive History of Present Illness (HPI):
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            - Review of Systems: {patient_data.get('review_systems', 'Not documented')}
            
            Create a well-structured HPI that includes:
            1. Onset and chronology
            2. Quality and character
            3. Severity and progression
            4. Associated symptoms
            5. Alleviating and aggravating factors
            
            Write in professional medical narrative format.
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=800,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI HPI Generation Error: {str(e)}")
            return None

    @staticmethod
    def generate_diagnosis(patient_data):
        """Generate differential diagnosis based on patient data"""
        try:
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Based on the following patient information, generate a differential diagnosis:
            
            Patient Demographics:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            
            Clinical Presentation:
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            - History of Present Illness: {patient_data.get('history_present_illness', 'Not documented')}
            
            Review of Systems:
            {json.dumps(patient_data.get('review_systems', {}), indent=2)}
            
            Medical History:
            - Social: {patient_data.get('social_history', 'Not documented')}
            - Medical: {patient_data.get('medical_history', 'Not documented')}
            - Surgical: {patient_data.get('surgical_history', 'Not documented')}
            - Family: {patient_data.get('family_history', 'Not documented')}
            - Allergies: {patient_data.get('allergies', 'None known')}
            - Medications: {patient_data.get('medications', 'None')}
            
            Physical Examination:
            {json.dumps(patient_data.get('examination', {}), indent=2)}
            
            Please provide:
            1. Most likely diagnosis (working diagnosis)
            2. 3-5 differential diagnoses in order of likelihood
            3. Brief rationale for each
            4. Suggested diagnostic tests to confirm
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1000,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI Diagnosis Error: {str(e)}")
            return None

    @staticmethod
    def analyze_lab_results(patient_data, lab_text):
        """Analyze lab results in context of patient data"""
        try:
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            prompt = f"""
            Analyze these lab results in the context of this patient:
            
            Patient Information:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            - Chief Complaint: {patient_data.get('chief_complaint', 'Not specified')}
            - Working Diagnosis: {patient_data.get('diagnosis', 'Not specified')}
            
            Lab Results:
            {lab_text}
            
            Please provide:
            1. Interpretation of abnormal values
            2. Clinical significance in context of patient
            3. Any additional tests recommended
            4. Potential treatment implications
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=800,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI Lab Analysis Error: {str(e)}")
            return None

    @staticmethod
    def generate_treatment_plan(patient_data, available_drugs):
        """Generate treatment plan based on patient data and available drugs"""
        try:
            model = os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
            
            # Format available drugs for the prompt
            drugs_list = "\n".join([f"- {drug.name}" for drug in available_drugs])
            
            prompt = f"""
            Create a comprehensive treatment plan for this patient:
            
            Patient Information:
            - Age: {patient_data.get('age', 'Not specified')}
            - Gender: {patient_data.get('gender', 'Not specified')}
            - Diagnosis: {patient_data.get('diagnosis', 'Not specified')}
            - Allergies: {patient_data.get('allergies', 'None known')}
            - Current Medications: {patient_data.get('medications', 'None')}
            
            Available Medications:
            {drugs_list}
            
            Please provide:
            1. First-line treatment recommendations
            2. Alternative options
            3. Dosage guidelines appropriate for patient demographics
            4. Monitoring parameters
            5. Patient education points
            6. Follow-up schedule
            
            Consider drug interactions and contraindications based on patient information.
            """
            
            response = deepseek_client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": prompt}],
                max_tokens=1200,
                temperature=0.7
            )
            
            return response.choices[0].message.content
        except Exception as e:
            current_app.logger.error(f"AI Treatment Plan Error: {str(e)}")
            return None

from flask import current_app
# Initialize DeepSeek client with proper error handling inside app context
with app.app_context():
    try:
        deepseek_client = OpenAI(
            api_key=os.getenv("DEEPSEEK_API_KEY"),
            base_url="https://api.deepseek.com/v1",
            timeout=30.0
        )
        # Test the connection
        if os.getenv("DEEPSEEK_API_KEY"):
            models = deepseek_client.models.list()
            current_app.logger.info(f"Connected to DeepSeek API. Available models: {[m.id for m in models.data]}")
        else:
            current_app.logger.warning("DEEPSEEK_API_KEY not set - AI features will be disabled")
            deepseek_client = None
    except Exception as e:
        current_app.logger.error(f"Failed to initialize DeepSeek client: {str(e)}")
        deepseek_client = None

    
@app.route('/api/verify-models', methods=['GET'])
@login_required
def verify_models():
    """Endpoint to check available models"""
    try:
        models_list = []
        
        # Test DeepSeek if configured
        if deepseek_client and os.getenv("DEEPSEEK_API_KEY"):
            deepseek_models = deepseek_client.models.list()
            models_list.extend([m.id for m in deepseek_models.data])
            current_app.logger.info(f"DeepSeek available models: {models_list}")
        
        return jsonify({
            'available_models': models_list,
            'default_model': os.getenv("DEEPSEEK_MODEL", "deepseek-chat")
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/doctor/patient/assistant/review_systems', methods=['POST'])
@login_required
def ai_review_systems():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        patient_data = {
            'age': patient.age,
            'gender': patient.gender,
            'address': patient.get_decrypted_address or '',
            'chief_complaint': patient.chief_complaint or '',
            'occupation': patient.get_decrypted_occupation or '',
            'religion': patient.religion or '',
        }
        
        questions = AIService.generate_review_systems_questions(patient_data)
        if not questions:
            return jsonify({
                'success': False,
                'error': 'Failed to generate questions'
            }), 500
            
        # Save to the latest review systems record (append-only history in UI)
        review = (
            PatientReviewSystem.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientReviewSystem.created_at.desc(), PatientReviewSystem.id.desc())
            .first()
        )
        if not review:
            review = PatientReviewSystem(patient_id=patient.id, created_by=current_user.id)
            db.session.add(review)
        elif not getattr(review, 'created_by', None):
            review.created_by = current_user.id
        
        review.ai_suggested_questions = questions
        review.ai_last_updated = get_eat_now()
        db.session.commit()
        
        return jsonify({
            'success': True,
            'questions': questions
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Review systems AI error: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Internal server error',
            'details': str(e)
        }), 500
        
@app.route('/doctor/patient/assistant/hpi_questions', methods=['POST'])
@login_required
def ai_hpi_questions():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400
    
    # Updated to use SQLAlchemy 2.0 style query
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        patient_data = {
            'age': patient.age,
            'gender': patient.gender,
            'address': patient.get_decrypted_address or '',
            'chief_complaint': patient.chief_complaint or '',
            'occupation': patient.get_decrypted_occupation or '',
            'religion': patient.religion or '',
        }
        
        questions = AIService.generate_hpi_questions(patient_data)
        if not questions:
            return jsonify({
                'success': False,
                'error': 'Failed to generate questions'
            }), 500
            
        return jsonify({
            'success': True,
            'questions': questions
        })
        
    except Exception as e:
        current_app.logger.error(f"HPI questions AI error: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'error': 'Internal server error'
        }), 500

@app.route('/doctor/patient/assistant/generate_hpi', methods=['POST'])
@login_required
def ai_generate_hpi():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400
    
    # Updated to SQLAlchemy 2.0 style query
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        # Get patient history if exists
        history = db.session.scalar(
            db.select(PatientHistory)
            .filter_by(patient_id=patient.id)
            .limit(1)
        )
        
        # Get review systems if exists
        review = db.session.scalar(
            db.select(PatientReviewSystem)
            .filter_by(patient_id=patient.id)
            .limit(1)
        )
        
        # Build patient data safely
        patient_data = {
            'age': patient.age,
            'gender': patient.gender,
            'address': patient.get_decrypted_address or '',
            'chief_complaint': patient.chief_complaint or '',
            'occupation': patient.get_decrypted_occupation or '',
            'religion': patient.religion or '',
            'review_systems': (
                f"CNS: {review.cns or 'Not documented'}\n"
                f"CVS: {review.cvs or 'Not documented'}\n"
                f"GIT: {review.git or 'Not documented'}\n"
                f"GUT: {review.gut or 'Not documented'}\n"
                f"Skin: {review.skin or 'Not documented'}\n"
                f"MSK: {review.msk or 'Not documented'}\n"
                f"RS: {review.rs or 'Not documented'}"
            ) if review else 'Review of systems not documented'
        }
        
        hpi_content = AIService.generate_hpi_content(patient_data)
        if not hpi_content:
            return jsonify({
                'success': False,
                'error': 'Failed to generate HPI content'
            }), 500
            
        return jsonify({
            'success': True,
            'hpi_content': hpi_content
        })
        
    except Exception as e:
        current_app.logger.error(f"HPI generation AI error: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'error': 'Internal server error'
        }), 500
        
@app.route('/doctor/patient/assistant/diagnosis', methods=['POST'])
@login_required
def ai_diagnosis():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    try:
        patient_id = request.form.get('patient_id')
        if not patient_id:
            return jsonify({'success': False, 'error': 'Patient ID required'}), 400
        
        patient = db.session.get(Patient, patient_id)
        if not patient:
            return jsonify({'success': False, 'error': 'Patient not found'}), 404
        
        # Get the clinical summary from the form data
        clinical_summary = request.form.get('patient_summary', '').strip()
        
        # If no clinical summary in form, check if patient has existing summary
        if not clinical_summary:
            existing_summary = db.session.scalar(
                db.select(PatientSummary)
                .filter_by(patient_id=patient.id)
                .order_by(PatientSummary.created_at.desc())
                .limit(1)
            )
            if existing_summary:
                clinical_summary = existing_summary.summary_text
        
        if not clinical_summary:
            return jsonify({
                'success': False, 
                'error': 'Please enter a clinical summary in the summary section first'
            }), 400
        
        # Get basic patient info for context
        patient_basic_info = {
            'age': patient.age,
            'gender': patient.gender,
            'name': patient.get_decrypted_name
        }
        
        # Generate diagnosis based on clinical summary - FIXED LINE
        diagnosis = AIService.generate_diagnosis_from_summary(clinical_summary, patient_basic_info)
        if not diagnosis:
            return jsonify({
                'success': False,
                'error': 'AI service unavailable. Please try again later.'
            }), 503
            
        return jsonify({
            'success': True,
            'diagnosis': diagnosis,
            'source': 'clinical_summary'
        })
        
    except Exception as e:
        current_app.logger.error(f"Diagnosis route error: {str(e)}", exc_info=True)
        return jsonify({
            'success': False,
            'error': 'Internal server error'
        }), 500
        
@app.route('/doctor/patient/assistant/analyze_lab', methods=['POST'])
@login_required
def ai_analyze_lab():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    lab_text = request.form.get('lab_text')
    
    if not patient_id or not lab_text:
        return jsonify({'success': False, 'error': 'Patient ID and lab text required'}), 400
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).first()
        
        patient_data = {
            'age': patient.age,
            'gender': patient.gender,
            'chief_complaint': patient.chief_complaint or '',
            'diagnosis': diagnosis.working_diagnosis if diagnosis else ''
        }
        
        analysis = AIService.analyze_lab_results(patient_data, lab_text)
        if not analysis:
            return jsonify({
                'success': False,
                'error': 'Failed to analyze lab results'
            }), 500
            
        return jsonify({
            'success': True,
            'analysis': analysis
        })
        
    except Exception as e:
        current_app.logger.error(f"Lab analysis AI error: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Internal server error',
            'details': str(e)
        }), 500

@app.route('/doctor/patient/assistant/treatment', methods=['POST'])
@login_required
def ai_treatment():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404
    
    try:
        diagnosis = (
            PatientDiagnosis.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientDiagnosis.created_at.desc(), PatientDiagnosis.id.desc())
            .first()
        )
        history = (
            PatientHistory.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientHistory.created_at.desc(), PatientHistory.id.desc())
            .first()
        )

        diagnosis_text = (diagnosis.working_diagnosis or '').strip() if diagnosis else ''
        if not diagnosis_text:
            # Fallback context (still useful if Diagnosis tab wasn't saved yet)
            diagnosis_text = (
                f"Not documented. Chief complaint: {(patient.chief_complaint or '').strip()} | "
                f"HPI: {(patient.history_present_illness or '').strip()}"
            ).strip()
        
        available_drugs = Drug.query.filter(Drug.remaining_quantity > 0).all()
        
        patient_data = {
            'age': patient.age,
            'gender': patient.gender,
            'diagnosis': diagnosis_text,
            'allergies': history.allergies if history else 'None known',
            'medications': history.medications if history else 'None'
        }
        
        treatment_plan = AIService.generate_treatment_plan(patient_data, available_drugs)
        if not treatment_plan:
            return jsonify({
                'success': False,
                'error': 'Failed to generate treatment plan'
            }), 500
            
        # Save to the latest management record (append-only history in UI)
        management = (
            PatientManagement.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientManagement.created_at.desc(), PatientManagement.id.desc())
            .first()
        )
        if not management:
            management = PatientManagement(patient_id=patient.id, created_by=current_user.id)
            db.session.add(management)
        elif not getattr(management, 'created_by', None):
            management.created_by = current_user.id
        
        management.ai_generated_plan = True
        management.ai_alternative_treatments = treatment_plan
        db.session.commit()
        
        return jsonify({
            'success': True,
            'treatment_plan': treatment_plan
        })
        
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Treatment plan AI error: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Internal server error',
            'details': str(e)
        }), 500


@app.route('/doctor/patient/assistant/management_progress', methods=['POST'])
@login_required
def ai_management_progress():
    """Advanced management assistant: compare baseline vs latest management and advise on progress."""
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400

    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    try:
        mgmt_versions = (
            PatientManagement.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientManagement.created_at.asc(), PatientManagement.id.asc())
            .options(db.joinedload(PatientManagement.creator))
            .all()
        )
        baseline = mgmt_versions[0] if mgmt_versions else None
        latest = mgmt_versions[-1] if mgmt_versions else None

        diagnosis = (
            PatientDiagnosis.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientDiagnosis.created_at.desc(), PatientDiagnosis.id.desc())
            .first()
        )
        latest_summary = (
            PatientSummary.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientSummary.created_at.desc(), PatientSummary.id.desc())
            .first()
        )
        history = (
            PatientHistory.query
            .filter_by(patient_id=patient.id)
            .order_by(PatientHistory.created_at.desc(), PatientHistory.id.desc())
            .first()
        )

        def _fmt_dt(dt):
            try:
                return dt.strftime('%Y-%m-%d %H:%M') if dt else ''
            except Exception:
                return ''

        def _u(user):
            return getattr(user, 'username', None) or ''

        done_services = (
            PatientService.query
            .filter_by(patient_id=patient.id)
            .filter(PatientService.status.in_(['done', 'completed']))
            .order_by(PatientService.completed_at.desc().nullslast(), PatientService.id.desc())
            .options(
                db.joinedload(PatientService.service),
                db.joinedload(PatientService.performer),
                db.joinedload(PatientService.completer),
            )
            .limit(20)
            .all()
        )

        recent_rx = (
            Prescription.query
            .filter_by(patient_id=patient.id)
            .order_by(Prescription.created_at.desc(), Prescription.id.desc())
            .options(
                db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug),
                db.joinedload(Prescription.doctor),
                db.joinedload(Prescription.dispenser),
            )
            .limit(10)
            .all()
        )
        recent_crx = (
            ControlledPrescription.query
            .filter_by(patient_id=patient.id)
            .order_by(ControlledPrescription.created_at.desc(), ControlledPrescription.id.desc())
            .options(
                db.joinedload(ControlledPrescription.items).joinedload(ControlledPrescriptionItem.controlled_drug),
                db.joinedload(ControlledPrescription.doctor),
                db.joinedload(ControlledPrescription.dispenser),
            )
            .limit(10)
            .all()
        )

        context = {
            'patient': {
                'age': patient.age,
                'gender': patient.gender,
                'patient_number': patient.op_number or patient.ip_number or '',
                'chief_complaint': patient.chief_complaint or '',
                'hpi': patient.history_present_illness or '',
            },
            'summary': {
                'created_at': _fmt_dt(getattr(latest_summary, 'created_at', None)),
                'text': (latest_summary.summary_text or '') if latest_summary else '',
            },
            'diagnosis': {
                'working': (diagnosis.working_diagnosis or '') if diagnosis else '',
                'differential': (diagnosis.differential_diagnosis or '') if diagnosis else '',
            },
            'history': {
                'allergies': (history.allergies or '') if history else '',
                'medications': (history.medications or '') if history else '',
                'medical': (history.medical_history or '') if history else '',
            },
            'management': {
                'baseline': {
                    'created_at': _fmt_dt(getattr(baseline, 'created_at', None)),
                    'by': _u(getattr(baseline, 'creator', None)),
                    'treatment_plan': (baseline.treatment_plan or '') if baseline else '',
                    'follow_up': (baseline.follow_up or '') if baseline else '',
                    'notes': (baseline.notes or '') if baseline else '',
                },
                'latest': {
                    'created_at': _fmt_dt(getattr(latest, 'created_at', None)),
                    'by': _u(getattr(latest, 'creator', None)),
                    'treatment_plan': (latest.treatment_plan or '') if latest else '',
                    'follow_up': (latest.follow_up or '') if latest else '',
                    'notes': (latest.notes or '') if latest else '',
                },
                'updates_count': len(mgmt_versions),
            },
            'services_done': [
                {
                    'service': (ps.service.name if ps.service else ''),
                    'done_by': _u(ps.performer) or _u(ps.completer),
                    'done_at': _fmt_dt(ps.completed_at) or _fmt_dt(getattr(ps, 'updated_at', None)),
                }
                for ps in done_services
            ],
            'prescriptions_recent': [
                {
                    'type': 'regular',
                    'created_at': _fmt_dt(rx.created_at),
                    'status': rx.status or '',
                    'prescribed_by': _u(rx.doctor),
                    'dispensed_at': _fmt_dt(rx.dispensed_at),
                    'dispensed_by': _u(rx.dispenser),
                    'items': [
                        {
                            'name': (it.drug.name if it.drug else ''),
                            'quantity': it.quantity,
                            'status': it.status or '',
                        }
                        for it in (rx.items or [])
                    ],
                }
                for rx in recent_rx
            ] + [
                {
                    'type': 'controlled',
                    'created_at': _fmt_dt(rx.created_at),
                    'status': rx.status or '',
                    'prescribed_by': _u(rx.doctor),
                    'dispensed_at': _fmt_dt(rx.dispensed_at),
                    'dispensed_by': _u(rx.dispenser),
                    'items': [
                        {
                            'name': (it.controlled_drug.name if it.controlled_drug else ''),
                            'quantity': it.quantity,
                            'status': it.status or '',
                        }
                        for it in (rx.items or [])
                    ],
                }
                for rx in recent_crx
            ],
        }

        prompt = f"""
You are an experienced clinician assisting another clinician.

Task: Review patient progress by comparing the ORIGINAL (baseline) management entry vs the LATEST management entry. If the latest treatment plan is missing or too thin, propose a complete updated treatment plan and follow-up.

Rules:
- Do not invent new patient facts.
- If information is missing, say what is missing and what to ask/check.
- Be concise and practical for clinical workflow.

Return format (use these headings exactly):
Progress Since Baseline:
Comparison (What changed):
Gaps / Missing Info:
Updated Treatment Plan:
Follow-up & Monitoring:
Red Flags / Escalation:

Patient context JSON:
{json.dumps(context, ensure_ascii=False)}
"""

        ai_timeout = current_app.config.get('AI_SUMMARY_TIMEOUT_SECONDS', 20)
        response = AIService._chat_completion(
            model=AIService.MODELS.get('primary') or 'deepseek-chat',
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=1200,
            timeout=ai_timeout,
        )
        text = (response.choices[0].message.content or '').strip()
        if not text:
            return jsonify({'success': False, 'error': 'Failed to generate progress review'}), 500

        return jsonify({'success': True, 'progress_review': text})

    except Exception as e:
        current_app.logger.error(f"Management progress AI error: {str(e)}")
        return jsonify({'success': False, 'error': 'Internal server error', 'details': str(e)}), 500


def _build_doctor_patient_ai_context(patient: 'Patient') -> dict:
    """Collect a unified view of the patient's entered data for AI prompts."""
    review = db.session.scalar(
        db.select(PatientReviewSystem).filter_by(patient_id=patient.id).limit(1)
    )
    history = db.session.scalar(
        db.select(PatientHistory).filter_by(patient_id=patient.id).limit(1)
    )
    exam = db.session.scalar(
        db.select(PatientExamination).filter_by(patient_id=patient.id).limit(1)
    )
    dx = db.session.scalar(
        db.select(PatientDiagnosis).filter_by(patient_id=patient.id).limit(1)
    )
    mgmt = db.session.scalar(
        db.select(PatientManagement).filter_by(patient_id=patient.id).limit(1)
    )

    # Latest investigation notes (these are optional free-text fields in the new-patient wizard)
    latest_lab = db.session.scalar(
        db.select(LabRequest)
        .filter_by(patient_id=patient.id)
        .order_by(LabRequest.created_at.desc())
        .limit(1)
    )
    latest_imaging = db.session.scalar(
        db.select(ImagingRequest)
        .filter_by(patient_id=patient.id)
        .order_by(ImagingRequest.created_at.desc())
        .limit(1)
    )

    vitals = {}
    if exam:
        if exam.temperature is not None:
            vitals['temperature_c'] = exam.temperature
        if exam.pulse is not None:
            vitals['pulse_bpm'] = exam.pulse
        if exam.resp_rate is not None:
            vitals['resp_rate'] = exam.resp_rate
        if exam.spo2 is not None:
            vitals['spo2'] = exam.spo2
        if exam.bp_systolic is not None or exam.bp_diastolic is not None:
            vitals['bp'] = f"{exam.bp_systolic or ''}/{exam.bp_diastolic or ''}".strip('/')

    return {
        'biodata': {
            'name': patient.get_decrypted_name,
            'age': patient.age,
            'gender': patient.gender,
            'address': patient.get_decrypted_address,
            'phone': patient.get_decrypted_phone,
            'occupation': patient.get_decrypted_occupation,
            'religion': patient.religion or '',
            'patient_number': patient.op_number or patient.ip_number or '',
            'date_of_admission': str(patient.date_of_admission) if patient.date_of_admission else '',
        },
        'chief_complaint': patient.chief_complaint or '',
        'hpi': patient.history_present_illness or '',
        'ros': {
            'cns': review.cns if review else '',
            'cvs': review.cvs if review else '',
            'rs': review.rs if review else '',
            'git': review.git if review else '',
            'gut': review.gut if review else '',
            'skin': review.skin if review else '',
            'msk': review.msk if review else '',
        },
        'history': {
            'social_history': history.social_history if history else '',
            'medical_history': history.medical_history if history else '',
            'surgical_history': history.surgical_history if history else '',
            'family_history': history.family_history if history else '',
            'allergies': history.allergies if history else '',
            'medications': history.medications if history else '',
        },
        'examination': {
            'general_appearance': exam.general_appearance if exam else '',
            'vitals': vitals,
            'systemic': {
                'cvs_exam': exam.cvs_exam if exam else '',
                'resp_exam': exam.resp_exam if exam else '',
                'abdo_exam': exam.abdo_exam if exam else '',
                'cns_exam': exam.cns_exam if exam else '',
                'msk_exam': exam.msk_exam if exam else '',
                'skin_exam': exam.skin_exam if exam else '',
            },
            'flags': {
                'jaundice': bool(exam.jaundice) if exam else False,
                'pallor': bool(exam.pallor) if exam else False,
                'cyanosis': bool(exam.cyanosis) if exam else False,
                'lymphadenopathy': bool(exam.lymphadenopathy) if exam else False,
                'edema': bool(exam.edema) if exam else False,
                'dehydration': bool(exam.dehydration) if exam else False,
            },
        },
        'diagnosis': {
            'working_diagnosis': dx.working_diagnosis if dx else '',
            'differentials': dx.differential_diagnosis if dx else '',
        },
        'management': {
            'treatment_plan': mgmt.treatment_plan if mgmt else '',
            'follow_up': mgmt.follow_up if mgmt else '',
            'notes': mgmt.notes if mgmt else '',
        },
        'investigations': {
            'lab_notes': (latest_lab.notes if latest_lab else '') or '',
            'imaging_notes': (latest_imaging.notes if latest_imaging else '') or '',
        },
    }


@app.route('/doctor/patient/assistant/generate_summary', methods=['POST'])
@login_required
def ai_generate_summary():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    patient_id = request.form.get('patient_id')
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400

    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    try:
        ctx = _build_doctor_patient_ai_context(patient)

        # Flatten into the structure expected by AIService.generate_patient_summary
        patient_data = {
            'name': ctx['biodata']['name'],
            'age': ctx['biodata']['age'],
            'gender': ctx['biodata']['gender'],
            'address': ctx['biodata']['address'],
            'occupation': ctx['biodata']['occupation'],
            'religion': ctx['biodata']['religion'],
            'chief_complaint': ctx['chief_complaint'],
            'history_present_illness': ctx['hpi'],
            'review_systems': ctx['ros'],
            'social_history': ctx['history']['social_history'],
            'medical_history': ctx['history']['medical_history'],
            'surgical_history': ctx['history']['surgical_history'],
            'family_history': ctx['history']['family_history'],
            'allergies': ctx['history']['allergies'] or 'None known',
            'medications': ctx['history']['medications'] or 'None',
            'examination': ctx['examination'],
            'working_diagnosis': ctx['diagnosis']['working_diagnosis'],
        }

        summary_text = AIService.generate_patient_summary(patient_data)

        # If AI returns empty/None, fall back to deterministic summary instead of 5xx.
        source = 'ai'
        warning = None
        summary_type = 'ai_generated'
        if not summary_text:
            summary_text = AIService.generate_patient_summary_fallback(patient_data)
            source = 'fallback'
            warning = 'AI service unavailable; generated a basic summary instead.'
            summary_type = 'ai_fallback'

        # Persist summary for audit/history (both AI and fallback) to keep existing UI flows working.
        summary = PatientSummary(
            patient_id=patient.id,
            summary_text=summary_text,
            summary_type=summary_type,
            generated_by=current_user.id,
        )
        db.session.add(summary)
        db.session.commit()

        payload = {'success': True, 'summary_text': summary_text, 'source': source}
        if warning:
            payload['warning'] = warning
        return jsonify(payload)

    except (APITimeoutError, httpx.TimeoutException, TimeoutError):
        db.session.rollback()
        current_app.logger.error('AI summary generation timeout.', exc_info=True)
        # Avoid 504s (which trip global AJAX error handling). Provide a basic summary instead.
        try:
            ctx = _build_doctor_patient_ai_context(patient)
            patient_data = {
                'name': ctx['biodata']['name'],
                'age': ctx['biodata']['age'],
                'gender': ctx['biodata']['gender'],
                'address': ctx['biodata']['address'],
                'occupation': ctx['biodata']['occupation'],
                'religion': ctx['biodata']['religion'],
                'chief_complaint': ctx['chief_complaint'],
                'history_present_illness': ctx['hpi'],
                'review_systems': ctx['ros'],
                'social_history': ctx['history']['social_history'],
                'medical_history': ctx['history']['medical_history'],
                'surgical_history': ctx['history']['surgical_history'],
                'family_history': ctx['history']['family_history'],
                'allergies': ctx['history']['allergies'] or 'None known',
                'medications': ctx['history']['medications'] or 'None',
                'examination': ctx['examination'],
                'working_diagnosis': ctx['diagnosis']['working_diagnosis'],
            }
            summary_text = AIService.generate_patient_summary_fallback(patient_data)

            summary = PatientSummary(
                patient_id=patient.id,
                summary_text=summary_text,
                summary_type='ai_fallback',
                generated_by=current_user.id,
            )
            db.session.add(summary)
            db.session.commit()

            return jsonify({
                'success': True,
                'summary_text': summary_text,
                'source': 'fallback',
                'warning': 'AI timed out; generated a basic summary instead. You can retry for an AI-written narrative.'
            }), 200
        except Exception:
            db.session.rollback()
            return jsonify({
                'success': False,
                'error': 'AI service timeout. Please try again in a moment.'
            }), 200

    except (APIConnectionError, APIError) as e:
        db.session.rollback()
        current_app.logger.error(f"AI summary generation upstream error: {str(e)}", exc_info=True)
        try:
            ctx = _build_doctor_patient_ai_context(patient)
            patient_data = {
                'name': ctx['biodata']['name'],
                'age': ctx['biodata']['age'],
                'gender': ctx['biodata']['gender'],
                'address': ctx['biodata']['address'],
                'occupation': ctx['biodata']['occupation'],
                'religion': ctx['biodata']['religion'],
                'chief_complaint': ctx['chief_complaint'],
                'history_present_illness': ctx['hpi'],
                'review_systems': ctx['ros'],
                'social_history': ctx['history']['social_history'],
                'medical_history': ctx['history']['medical_history'],
                'surgical_history': ctx['history']['surgical_history'],
                'family_history': ctx['history']['family_history'],
                'allergies': ctx['history']['allergies'] or 'None known',
                'medications': ctx['history']['medications'] or 'None',
                'examination': ctx['examination'],
                'working_diagnosis': ctx['diagnosis']['working_diagnosis'],
            }
            summary_text = AIService.generate_patient_summary_fallback(patient_data)
            summary = PatientSummary(
                patient_id=patient.id,
                summary_text=summary_text,
                summary_type='ai_fallback',
                generated_by=current_user.id,
            )
            db.session.add(summary)
            db.session.commit()

            return jsonify({
                'success': True,
                'summary_text': summary_text,
                'source': 'fallback',
                'warning': 'AI service error; generated a basic summary instead. You can retry later.'
            }), 200
        except Exception:
            db.session.rollback()
            return jsonify({
                'success': False,
                'error': 'AI service error. Please try again later.'
            }), 200

    except ValueError as e:
        # Typically configuration issues like missing DEEPSEEK_API_KEY
        db.session.rollback()
        current_app.logger.error(f"AI summary generation configuration error: {str(e)}")
        try:
            ctx = _build_doctor_patient_ai_context(patient)
            patient_data = {
                'name': ctx['biodata']['name'],
                'age': ctx['biodata']['age'],
                'gender': ctx['biodata']['gender'],
                'address': ctx['biodata']['address'],
                'occupation': ctx['biodata']['occupation'],
                'religion': ctx['biodata']['religion'],
                'chief_complaint': ctx['chief_complaint'],
                'history_present_illness': ctx['hpi'],
                'review_systems': ctx['ros'],
                'social_history': ctx['history']['social_history'],
                'medical_history': ctx['history']['medical_history'],
                'surgical_history': ctx['history']['surgical_history'],
                'family_history': ctx['history']['family_history'],
                'allergies': ctx['history']['allergies'] or 'None known',
                'medications': ctx['history']['medications'] or 'None',
                'examination': ctx['examination'],
                'working_diagnosis': ctx['diagnosis']['working_diagnosis'],
            }
            summary_text = AIService.generate_patient_summary_fallback(patient_data)
            summary = PatientSummary(
                patient_id=patient.id,
                summary_text=summary_text,
                summary_type='ai_fallback',
                generated_by=current_user.id,
            )
            db.session.add(summary)
            db.session.commit()

            return jsonify({
                'success': True,
                'summary_text': summary_text,
                'source': 'fallback',
                'warning': 'AI is not configured; generated a basic summary instead.'
            }), 200
        except Exception:
            db.session.rollback()
            return jsonify({
                'success': False,
                'error': 'AI service is not configured. Contact administrator.'
            }), 200

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"AI summary generation error: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Internal server error'}), 500
 
@app.errorhandler(APITimeoutError)
def handle_ai_timeout(e):
    return jsonify({
        "error": "AI service timeout",
        "message": "The AI service is taking longer than expected to respond"
    }), 504

@app.errorhandler(APIError)
def handle_ai_error(e):
    return jsonify({
        "error": "AI service error",
        "message": str(e)
    }), 502
        
@app.route('/doctor/patients/active')
@login_required
def active_patients():
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403
    
    patients = Patient.query.filter_by(status='active').order_by(Patient.created_at.desc()).all()
    patients_data = [{
        'id': p.id,
        'number': p.op_number or p.ip_number,
        'name': p.name,
        'age': p.age,
        'gender': p.gender,
        'date_of_admission': p.date_of_admission.strftime('%Y-%m-%d')
    } for p in patients]
    
    return jsonify(patients_data)

@app.route('/doctor/patients/old', methods=['GET', 'POST'])
@login_required
def old_patients():
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    # Handle search and filtering
    search_query = request.args.get('search', '')
    page = request.args.get('page', 1, type=int)
    per_page = 20  # Patients per page

    # Base query for completed patients
    query = Patient.query.filter_by(status='completed')

    # Apply search filter if provided
    if search_query:
        query = query.filter(
            or_(
                Patient.name.ilike(f'%{search_query}%'),
                Patient.op_number.ilike(f'%{search_query}%'),
                Patient.ip_number.ilike(f'%{search_query}%')
            )
        )

    # Get paginated results ordered by completion date (newest first)
    completed_patients = query.order_by(
        Patient.updated_at.desc()
    ).paginate(page=page, per_page=per_page, error_out=False)

    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'readmit':
            patient_id = request.form.get('patient_id')
            patient = db.session.get(Patient, patient_id)
            if patient:
                try:
                    patient.status = 'active'
                    patient.updated_at = get_eat_now()
                    db.session.commit()
                    
                    log_audit('readmit_patient', 'Patient', patient.id, None, None)
                    flash(f'Patient {patient.name} readmitted successfully!', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'Error readmitting patient: {str(e)}', 'danger')
            else:
                flash('Patient not found', 'danger')
        
        return redirect(url_for('old_patients'))

    return render_template('doctor/old_patients.html',
        patients=completed_patients,
        search_query=search_query,
        current_time=get_eat_now()
    )

@app.route('/doctor/patient/<int:patient_id>/record')
@login_required
def patient_medical_record(patient_id):
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    patient = db.session.get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_patients'))
    
    # Check if user can access this patient
    if not can_user_access_patient(current_user, patient):
        flash('You do not have access to this patient', 'danger')
        return redirect(url_for('doctor_patients'))
    
    # Get all medical record components
    review_systems = PatientReviewSystem.query.filter_by(patient_id=patient.id).first()
    history = PatientHistory.query.filter_by(patient_id=patient.id).first()
    examination = PatientExamination.query.filter_by(patient_id=patient.id).first()
    diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).first()
    management = PatientManagement.query.filter_by(patient_id=patient.id).first()
    
    # Get all related records
    lab_requests = LabRequest.query.filter_by(patient_id=patient.id).order_by(LabRequest.created_at.desc()).all()
    imaging_requests = ImagingRequest.query.filter_by(patient_id=patient.id).order_by(ImagingRequest.created_at.desc()).all()
    prescriptions = Prescription.query.filter_by(patient_id=patient.id).options(db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug)).order_by(Prescription.created_at.desc()).all()
    services = PatientService.query.filter_by(patient_id=patient.id).order_by(PatientService.created_at.desc()).all()
    
    return render_template('doctor/medical_record.html',
        patient=patient,
        review_systems=review_systems,
        history=history,
        examination=examination,
        diagnosis=diagnosis,
        management=management,
        lab_requests=lab_requests,
        imaging_requests=imaging_requests,
        prescriptions=prescriptions,
        services=services
    )

@app.route('/doctor/patient/<int:patient_id>/complete', methods=['POST'])
@login_required
def complete_patient_treatment(patient_id):
    if current_user.role not in ('doctor', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    try:
        # Inpatients: move to discharge queue (pending). Billing enforcement is applied
        # when confirming discharge, not when requesting it.
        if patient.ip_number:
            patient.discharge_state = 'pending'
            patient.discharge_requested_at = get_eat_now()
            patient.discharge_requested_by = current_user.id
            patient.updated_at = get_eat_now()
            db.session.commit()
            return jsonify({'success': True, 'mode': 'discharge_requested'})

        # Outpatients: complete treatment immediately.
        patient.status = 'completed'
        patient.updated_at = get_eat_now()
        db.session.commit()
        return jsonify({'success': True, 'mode': 'completed'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

def _release_patient_bed_if_any(patient: 'Patient'):
    """Release the currently assigned bed (if any) for a patient.

    This is intentionally best-effort and safe to call multiple times.
    """
    if not patient or not getattr(patient, 'id', None):
        return

    bed = Bed.query.filter_by(patient_id=patient.id).first()
    if not bed:
        return

    now = get_eat_now()

    # Update bed state
    bed.status = 'available'
    bed.released_at = now
    bed.patient_id = None

    # Close the latest open BedAssignment (if present)
    try:
        last_assign = (
            BedAssignment.query
            .filter_by(bed_id=bed.id, patient_id=patient.id)
            .filter(BedAssignment.released_at.is_(None))
            .order_by(BedAssignment.assigned_at.desc())
            .first()
        )
        if last_assign:
            last_assign.released_at = now
            db.session.add(last_assign)
    except Exception:
        pass


@app.route('/doctor/patient/<int:patient_id>/delete', methods=['DELETE'])
@app.route('/doctor/patient/<int:patient_id>', methods=['DELETE'])
@login_required
def delete_patient(patient_id):
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    # Enforce ward/department access rules (prevents deleting patients outside assignment scope)
    if not can_user_access_patient(current_user, patient):
        return jsonify({'success': False, 'error': 'You do not have access to this patient'}), 403
        
    try:
        # Detach bed first so deletes don't fail just due to bed occupancy.
        _release_patient_bed_if_any(patient)
        db.session.delete(patient)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Patient deleted successfully.'})
    except IntegrityError:
        # FK constraints are expected in a medical system; fall back to a safe soft-delete.
        db.session.rollback()
        try:
            _release_patient_bed_if_any(patient)
            patient.status = 'deleted'
            patient.updated_at = get_eat_now()
            db.session.commit()
            return jsonify({
                'success': True,
                'soft_deleted': True,
                'message': 'Patient removed from the list (archived).',
            })
        except Exception as e:
            db.session.rollback()
            return jsonify({'success': False, 'error': str(e)}), 500
    except DBAPIError as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/doctor/patient/<int:patient_id>/admit', methods=['GET', 'POST'])
@login_required
def admit_patient(patient_id):
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'error')
        return redirect(url_for('doctor_patients'))
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'error')
        return redirect(url_for('doctor_patients'))
    
    if request.method == 'GET':
        # Get all wards
        wards = Ward.query.order_by(Ward.name).all()
        # Insurance capture (optional)
        try:
            insurance_providers = InsuranceProvider.query.order_by(InsuranceProvider.name).all()
        except Exception:
            insurance_providers = []

        try:
            active_insurance = (
                InsurancePolicy.query
                .filter_by(patient_id=patient.id, active=True)
                .order_by(InsurancePolicy.created_at.desc())
                .first()
            )
        except Exception:
            active_insurance = None

        return render_template(
            'doctor/admit_patient.html',
            patient=patient,
            wards=wards,
            insurance_providers=insurance_providers,
            active_insurance=active_insurance,
        )
    
    # POST request - process admission
    try:
        ward_id = request.form.get('ward_id', type=int)
        bed_id = request.form.get('bed_id', type=int)

        # Optional insurance capture at admission
        insurance_provider_id = request.form.get('insurance_provider_id', type=int)
        insurance_policy_number = (request.form.get('insurance_policy_number') or '').strip()
        insurance_member_number = (request.form.get('insurance_member_number') or '').strip()
        insurance_covers_inpatient = request.form.get('insurance_covers_inpatient') in ('1', 'true', 'True', 'on', 'yes')
        
        if not ward_id or not bed_id:
            flash('Please select both ward and bed', 'error')
            return redirect(url_for('admit_patient', patient_id=patient_id))
        
        # Verify ward and bed exist
        ward = db.session.get(Ward, ward_id)
        bed = db.session.get(Bed, bed_id)
        
        if not ward or not bed or bed.ward_id != ward_id:
            flash('Invalid ward or bed selection', 'error')
            return redirect(url_for('admit_patient', patient_id=patient_id))
        
        # Check if bed is available
        if bed.status != 'available':
            flash('Selected bed is not available', 'error')
            return redirect(url_for('admit_patient', patient_id=patient_id))
        
        # Generate IP number if patient doesn't have one
        if not patient.ip_number:
            # Use existing generate_patient_number logic
            # Get the latest IP number
            latest_ip = Patient.query.filter(
                Patient.ip_number.isnot(None)
            ).order_by(Patient.ip_number.desc()).first()
            
            if latest_ip and latest_ip.ip_number:
                # Extract number from format IP-XXXXX
                try:
                    last_num = int(latest_ip.ip_number.split('-')[1])
                    new_num = last_num + 1
                except (IndexError, ValueError):
                    new_num = 1
            else:
                new_num = 1
            
            patient.ip_number = f'IP-{new_num:05d}'
        
        # Update patient to inpatient
        patient.patient_type = 'IP'
        patient.status = 'active'

        # Identify current active insurance (if any)
        try:
            current_active_policy = (
                InsurancePolicy.query
                .filter_by(patient_id=patient.id, active=True)
                .order_by(InsurancePolicy.created_at.desc())
                .first()
            )
        except Exception:
            current_active_policy = None

        # Save insurance if provided (best-effort; never block admission)
        created_new_policy = False
        try:
            if insurance_provider_id and (insurance_policy_number or insurance_member_number):
                provider = db.session.get(InsuranceProvider, int(insurance_provider_id))
                if provider:
                    existing_active = (
                        InsurancePolicy.query
                        .filter_by(patient_id=patient.id, active=True, provider_id=provider.id)
                        .order_by(InsurancePolicy.created_at.desc())
                        .first()
                    )

                    same_as_existing = False
                    if existing_active:
                        same_as_existing = (
                            (existing_active.policy_number or '').strip() == insurance_policy_number
                            and (existing_active.member_number or '').strip() == insurance_member_number
                        )

                    if not same_as_existing:
                        # Deactivate other active policies so billing finds one clear active policy
                        try:
                            InsurancePolicy.query.filter_by(patient_id=patient.id, active=True).update({'active': False})
                        except Exception:
                            pass

                        new_policy = InsurancePolicy(
                            patient_id=patient.id,
                            provider_id=provider.id,
                            policy_number=insurance_policy_number or None,
                            member_number=insurance_member_number or None,
                            active=True,
                            start_date=date.today(),
                            notes=(
                                f"Captured at admission by Dr. {getattr(current_user, 'full_name', '')}".strip()
                                or None
                            ),
                            created_at=get_eat_now(),
                        )
                        _insurance_policy_set_covers_inpatient(new_policy, bool(insurance_covers_inpatient))
                        if not bool(insurance_covers_inpatient):
                            # If doctor marks it as not covering inpatient, keep it inactive for IP billing.
                            new_policy.active = False
                        db.session.add(new_policy)
                        created_new_policy = bool(new_policy.active)
        except Exception:
            # Admission must proceed even if insurance save fails
            pass

        # If active policy exists but does NOT cover inpatient, disable it on admission unless replaced.
        try:
            if current_active_policy and (not _insurance_policy_covers_inpatient(current_active_policy)) and (not created_new_policy):
                current_active_policy.active = False
                db.session.add(current_active_policy)
        except Exception:
            pass
        
        # Create bed assignment
        bed_assignment = BedAssignment(
            patient_id=patient.id,
            bed_id=bed.id,
            ward_id=ward.id,
            assigned_at=get_eat_now(),
            start_date=get_eat_now(),
            notes=f'Admitted by Dr. {current_user.full_name}'
        )
        db.session.add(bed_assignment)
        
        # Update bed status
        bed.status = 'occupied'
        bed.patient_id = patient.id
        bed.assigned_at = get_eat_now()
        
        # Create nurse notification
        notification = NurseNotification(
            patient_id=patient.id,
            ward_id=ward.id,
            bed_id=bed.id,
            doctor_id=current_user.id,
            notified_at=get_eat_now(),
            status='pending'
        )
        db.session.add(notification)
        
        db.session.commit()
        
        flash(f'Patient admitted successfully with IP Number: {patient.ip_number}', 'success')
        return redirect(url_for('nurse_notification_page', patient_id=patient.id, notification_id=notification.id))
        
    except Exception as e:
        db.session.rollback()
        flash(f'Error during admission: {str(e)}', 'error')
        return redirect(url_for('admit_patient', patient_id=patient_id))


@app.route('/api/wards/<int:ward_id>/beds/available', methods=['GET'])
@login_required
def api_get_available_beds_for_ward(ward_id):
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    # Get all available beds for the ward
    beds = Bed.query.filter_by(
        ward_id=ward_id,
        status='available'
    ).order_by(Bed.bed_number).all()
    
    beds_data = [{
        'id': bed.id,
        'bed_number': bed.bed_number,
        'bed_type': bed.bed_type
    } for bed in beds]
    
    return jsonify({
        'success': True,
        'beds': beds_data
    })


@app.route('/api/patient/<int:patient_id>/insurance', methods=['GET'])
@login_required
def api_get_patient_insurance(patient_id):
    """Return active insurance policy for a patient (best-effort)."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('doctor', 'receptionist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    # Enforce ward/department access rules where applicable
    try:
        if user_role == 'doctor' and (not can_user_access_patient(current_user, patient)):
            return jsonify({'success': False, 'error': 'You do not have access to this patient'}), 403
    except Exception:
        pass

    try:
        policy = (
            InsurancePolicy.query
            .filter_by(patient_id=patient.id, active=True)
            .order_by(InsurancePolicy.created_at.desc())
            .first()
        )
    except Exception:
        policy = None

    if not policy:
        return jsonify({'success': True, 'policy': None})

    provider = None
    try:
        provider = db.session.get(InsuranceProvider, policy.provider_id)
    except Exception:
        provider = None

    meta = _insurance_policy_meta(policy)
    return jsonify({
        'success': True,
        'policy': {
            'id': policy.id,
            'provider_id': policy.provider_id,
            'provider_name': (provider.name if provider else None),
            'policy_number': policy.policy_number,
            'member_number': policy.member_number,
            'active': bool(policy.active),
            'covers_inpatient': bool(meta.get('covers_inpatient', True)),
            'verification_status': meta.get('verification_status'),
            'verified_by': meta.get('verified_by'),
            'verified_at': meta.get('verified_at'),
        }
    })


@app.route('/api/patient/<int:patient_id>/insurance/verify', methods=['POST'])
@login_required
def api_verify_patient_insurance(patient_id):
    """Receptionist/admin verifies the active insurance policy (best-effort)."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'success': False, 'error': 'Patient not found'}), 404

    try:
        policy = (
            InsurancePolicy.query
            .filter_by(patient_id=patient.id, active=True)
            .order_by(InsurancePolicy.created_at.desc())
            .first()
        )
    except Exception:
        policy = None

    if not policy:
        return jsonify({'success': False, 'error': 'No active insurance policy for this patient'}), 400

    try:
        _insurance_policy_mark_verified(policy, current_user.id)
        db.session.add(policy)
        db.session.commit()
        return jsonify({'success': True, 'message': 'Insurance verified'})
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/doctor/patient/<int:patient_id>/notify-nurse/<int:notification_id>')
@login_required
def nurse_notification_page(patient_id, notification_id):
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'error')
        return redirect(url_for('doctor_patients'))
    
    patient = db.session.get(Patient, patient_id)
    notification = db.session.get(NurseNotification, notification_id)
    
    if not patient or not notification:
        flash('Patient or notification not found', 'error')
        return redirect(url_for('doctor_patients'))
    
    return render_template('doctor/nurse_notification.html', 
                         patient=patient, 
                         notification=notification)


@app.route('/doctor/patient/<int:patient_id>/complete-admission/<int:notification_id>', methods=['POST'])
@login_required
def complete_admission(patient_id, notification_id):
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    patient = db.session.get(Patient, patient_id)
    notification = db.session.get(NurseNotification, notification_id)
    
    if not patient or not notification:
        return jsonify({'success': False, 'error': 'Patient or notification not found'}), 404
    
    try:
        # Update notification status
        notification.status = 'completed'
        notification.completed_at = get_eat_now()
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': 'Admission completed successfully',
            'redirect': url_for('doctor_patient_details', patient_id=patient.id)
        })
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/doctor/patient/readmit', methods=['POST'])
@login_required
def readmit_patient():
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403
    
    patient_id = request.form.get('patient_id')
    patient = db.session.get(Patient, patient_id)
    
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404
    
    try:
        patient.status = 'active'
        # Reset discharge workflow fields on readmit.
        patient.discharge_state = 'none'
        patient.discharge_requested_at = None
        patient.discharge_requested_by = None
        patient.discharged_at = None
        patient.discharged_by = None
        db.session.commit()
        return jsonify({'success': True})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@app.route('/doctor/patient/new', methods=['POST'])
@login_required
def handle_patient_sections():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    section = request.form.get('section')
    patient_id = request.form.get('patient_id')

    try:
        if section == 'biodata':
            patient_type = request.form.get('patient_type')
            patient_number = generate_patient_number(patient_type)
            
            patient = Patient(
                op_number=patient_number if patient_type == 'OP' else None,
                ip_number=patient_number if patient_type == 'IP' else None,
                name=request.form.get('name'),
                age=_parse_age_years(request.form.get('age')),
                gender=request.form.get('gender'),
                address=request.form.get('address') if request.form.get('address') else None,
                phone=request.form.get('phone') if request.form.get('phone') else None,
                destination=request.form.get('destination'),
                occupation=request.form.get('occupation') if request.form.get('occupation') else None,
                religion=request.form.get('religion'),
                nok_name=request.form.get('nok_name') if request.form.get('nok_name') else None,
                nok_contact=request.form.get('nok_contact') if request.form.get('nok_contact') else None,
                tca=datetime.strptime(request.form.get('tca'), '%Y-%m-%d').date() if request.form.get('tca') else None,
                date_of_admission=datetime.strptime(request.form.get('date_of_admission'), '%Y-%m-%d').date() if request.form.get('date_of_admission') else date.today(),
                status='active'
            )
            db.session.add(patient)
            db.session.commit()
            
            return jsonify({
                'success': True,
                'patient_id': patient.id,
                'next_section': 'chief_complaint'
            })

        elif section == 'chief_complaint':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404

            chief_complaint = (request.form.get('chief_complaint') or '').strip()
            hpi_text = (request.form.get('history_present_illness') or '').strip()

            patient.chief_complaint = chief_complaint or None
            patient.history_present_illness = hpi_text or None

            # Capture attribution for wizard-entered values.
            if chief_complaint:
                db.session.add(PatientChiefComplaintEntry(
                    patient_id=patient.id,
                    complaint_text=chief_complaint,
                    created_by=current_user.id,
                ))
            if hpi_text:
                db.session.add(PatientHPIEntry(
                    patient_id=patient.id,
                    hpi_text=hpi_text,
                    created_by=current_user.id,
                ))
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'review_systems'
            })

        elif section == 'review_systems':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            review = PatientReviewSystem.query.filter_by(patient_id=patient.id).first()
            if not review:
                review = PatientReviewSystem(patient_id=patient.id, created_by=current_user.id)
                db.session.add(review)
            elif not review.created_by:
                review.created_by = current_user.id
            
            review.cns = request.form.get('cns')
            review.cvs = request.form.get('cvs')
            review.rs = request.form.get('rs')
            review.git = request.form.get('git')
            review.gut = request.form.get('gut')
            review.skin = request.form.get('skin')
            review.msk = request.form.get('msk')
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'hpi'
            })

        elif section == 'hpi':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            patient.history_present_illness = request.form.get('hpi_details')
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'smhx'
            })

        elif section == 'smhx':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            smhx = PatientHistory.query.filter_by(patient_id=patient.id).first()
            if not smhx:
                smhx = PatientHistory(patient_id=patient.id, created_by=current_user.id)
                db.session.add(smhx)
            elif not smhx.created_by:
                smhx.created_by = current_user.id
            
            smhx.social_history = request.form.get('social_history')
            smhx.medical_history = request.form.get('medical_history')
            smhx.surgical_history = request.form.get('surgical_history')
            smhx.family_history = request.form.get('family_history')
            smhx.allergies = request.form.get('allergies')
            smhx.medications = request.form.get('medications')
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'examination'
            })

        elif section == 'examination':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            exam = PatientExamination.query.filter_by(patient_id=patient.id).first()
            if not exam:
                exam = PatientExamination(patient_id=patient.id, created_by=current_user.id)
                db.session.add(exam)
            elif not exam.created_by:
                exam.created_by = current_user.id
            
            exam.general_appearance = request.form.get('general_appearance')
            exam.jaundice = request.form.get('jaundice') == 'yes'
            exam.pallor = request.form.get('pallor') == 'yes'
            exam.cyanosis = request.form.get('cyanosis') == 'yes'
            exam.lymphadenopathy = request.form.get('lymphadenopathy') == 'yes'
            exam.edema = request.form.get('edema') == 'yes'
            exam.dehydration = request.form.get('dehydration') == 'yes'
            exam.dehydration_parameters = request.form.get('dehydration_parameters')
            exam.temperature = float(request.form.get('temperature')) if request.form.get('temperature') else None
            exam.pulse = int(request.form.get('pulse')) if request.form.get('pulse') else None
            exam.resp_rate = int(request.form.get('resp_rate')) if request.form.get('resp_rate') else None
            exam.bp_systolic = int(request.form.get('bp_systolic')) if request.form.get('bp_systolic') else None
            exam.bp_diastolic = int(request.form.get('bp_diastolic')) if request.form.get('bp_diastolic') else None
            exam.spo2 = int(request.form.get('spo2')) if request.form.get('spo2') else None
            exam.weight = float(request.form.get('weight')) if request.form.get('weight') else None
            exam.height = float(request.form.get('height')) if request.form.get('height') else None
            exam.bmi = float(request.form.get('bmi')) if request.form.get('bmi') else None
            exam.cvs_exam = request.form.get('cvs_exam')
            exam.resp_exam = request.form.get('resp_exam')
            exam.abdo_exam = request.form.get('abdo_exam')
            exam.cns_exam = request.form.get('cns_exam')
            exam.msk_exam = request.form.get('msk_exam')
            exam.skin_exam = request.form.get('skin_exam')
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'diagnosis'
            })

        elif section == 'diagnosis':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            diagnosis = PatientDiagnosis.query.filter_by(patient_id=patient.id).first()
            if not diagnosis:
                diagnosis = PatientDiagnosis(patient_id=patient.id, created_by=current_user.id)
                db.session.add(diagnosis)
            elif not diagnosis.created_by:
                diagnosis.created_by = current_user.id
            
            diagnosis.working_diagnosis = request.form.get('working_diagnosis')
            diagnosis.differential_diagnosis = request.form.get('differential_diagnosis')
            
            # Lab requests
            if request.form.getlist('lab_tests'):
                for test_id in request.form.getlist('lab_tests'):
                    test = db.session.get(LabTest, int(test_id))
                    if not test:
                        continue
                    lab_request = LabRequest(
                        patient_id=patient.id,
                        test_id=test_id,
                        requested_by=current_user.id,
                        status='pending',
                        notes=request.form.get('lab_notes')
                    )
                    db.session.add(lab_request)
                    # Create financial records
                    try:
                        create_service_sale_and_transaction(
                            patient_id=patient.id,
                            service_item=test,
                            service_type='lab',
                            requested_by_id=current_user.id,
                            notes=request.form.get('lab_notes')
                        )
                    except Exception as e:
                        db.session.rollback()
                        current_app.logger.error(f"Could not create transaction for lab request in handle_patient_sections: {str(e)}")
                        return jsonify({'success': False, 'error': 'Failed to create financial record for lab test.'}), 500
            
            # Imaging requests
            if request.form.getlist('imaging_tests'):
                for test_id in request.form.getlist('imaging_tests'):
                    test = db.session.get(ImagingTest, int(test_id))
                    if not test:
                        continue
                    imaging_request = ImagingRequest(
                        patient_id=patient.id,
                        test_id=test_id,
                        requested_by=current_user.id,
                        status='pending',
                        notes=request.form.get('imaging_notes')
                    )
                    db.session.add(imaging_request)
                    # Create financial records
                    try:
                        create_service_sale_and_transaction(
                            patient_id=patient.id,
                            service_item=test,
                            service_type='imaging',
                            requested_by_id=current_user.id,
                            notes=request.form.get('imaging_notes')
                        )
                    except Exception as e:
                        db.session.rollback()
                        current_app.logger.error(f"Could not create transaction for imaging request in handle_patient_sections: {str(e)}")
                        return jsonify({'success': False, 'error': 'Failed to create financial record for imaging test.'}), 500
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'next_section': 'management'
            })

        elif section == 'management':
            patient = db.session.get(Patient, patient_id)
            if not patient:
                return jsonify({'success': False, 'error': 'Patient not found'}), 404
            
            management = PatientManagement.query.filter_by(patient_id=patient.id).first()
            if not management:
                management = PatientManagement(patient_id=patient.id, created_by=current_user.id)
                db.session.add(management)
            elif not management.created_by:
                management.created_by = current_user.id
            
            management.treatment_plan = request.form.get('treatment_plan')
            management.follow_up = request.form.get('follow_up')
            management.notes = request.form.get('management_notes')
            
            # Prescriptions
            if request.form.getlist('drug_id'):
                for i, drug_id in enumerate(request.form.getlist('drug_id')):
                    prescription = Prescription(
                        patient_id=patient.id,
                        drug_id=drug_id,
                        doctor_id=current_user.id,
                        dosage=request.form.getlist('dosage')[i],
                        frequency=request.form.getlist('frequency')[i],
                        duration=request.form.getlist('duration')[i],
                        quantity=request.form.getlist('quantity')[i],
                        notes=request.form.getlist('prescription_notes')[i]
                    )
                    db.session.add(prescription)
            
            # Services
            if request.form.getlist('service_id'):
                for service_id in request.form.getlist('service_id'):
                    try:
                        service_id_int = int(service_id)
                    except Exception:
                        continue
                    service_record = PatientService(
                        patient_id=patient.id,
                        service_id=service_id_int,
                        status='requested',
                        requested_by=current_user.id,
                        performed_by=current_user.id,
                        notes=request.form.get('service_notes')
                    )
                    db.session.add(service_record)
            
            db.session.commit()
            
            return jsonify({
                'success': True,
                'redirect': url_for('doctor_patient_details', patient_id=patient.id)
            })

        return jsonify({'success': True})

    except Exception as e:
        db.session.rollback()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/doctor/patient/<int:patient_id>', methods=['GET', 'POST'])
@login_required
def doctor_patient_details(patient_id):
    if current_user.role != 'doctor':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = db.session.get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_patients'))
    
    drugs = Drug.query.filter(Drug.remaining_quantity > 0).all()
    controlled_drugs = ControlledDrug.query.filter(ControlledDrug.remaining_quantity > 0).all()
    services = Service.query.all()
    
    if request.method == 'POST':
        section = request.form.get('section')
        active_tab = (request.form.get('active_tab') or '').strip() or None

        def _redirect_back(default_tab: str = 'biodata'):
            return redirect(url_for(
                'doctor_patient_details',
                patient_id=patient_id,
                tab=(active_tab or default_tab),
            ))

        if section == 'biodata':
            try:
                name = (request.form.get('name') or '').strip()
                if not name:
                    flash('Patient name cannot be empty', 'warning')
                    return _redirect_back('biodata')

                # Track only these fields for append-only history.
                old_phone = (patient.get_decrypted_phone or '').strip()
                old_nok_name = (patient.get_decrypted_nok_name or '').strip()
                old_nok_contact = (patient.get_decrypted_nok_contact or '').strip()
                old_religion = (patient.religion or '').strip()
                old_tca = patient.tca

                new_phone = (request.form.get('phone') or '').strip()
                new_nok_name = (request.form.get('nok_name') or '').strip()
                new_nok_contact = (request.form.get('nok_contact') or '').strip()
                new_religion = (request.form.get('religion') or '').strip()
                new_tca = (
                    datetime.strptime(request.form.get('tca'), '%Y-%m-%d').date()
                    if (request.form.get('tca') or '').strip()
                    else None
                )

                tracked_changed = (
                    (old_phone != new_phone)
                    or (old_nok_name != new_nok_name)
                    or (old_nok_contact != new_nok_contact)
                    or (old_religion != new_religion)
                    or (old_tca != new_tca)
                )

                if tracked_changed:
                    existing_count = PatientBiodataEntry.query.filter_by(patient_id=patient.id).count()
                    if existing_count == 0:
                        # Create an initial snapshot so the doctor can navigate back to what existed before the first change.
                        initial = PatientBiodataEntry(
                            patient_id=patient.id,
                            phone=(Config.encrypt_data_static(old_phone) if old_phone else None),
                            nok_name=(Config.encrypt_data_static(old_nok_name) if old_nok_name else None),
                            nok_contact=(Config.encrypt_data_static(old_nok_contact) if old_nok_contact else None),
                            religion=(old_religion or None),
                            tca=old_tca,
                            created_by=current_user.id,
                        )
                        db.session.add(initial)

                    entry = PatientBiodataEntry(
                        patient_id=patient.id,
                        phone=(Config.encrypt_data_static(new_phone) if new_phone else None),
                        nok_name=(Config.encrypt_data_static(new_nok_name) if new_nok_name else None),
                        nok_contact=(Config.encrypt_data_static(new_nok_contact) if new_nok_contact else None),
                        religion=(new_religion or None),
                        tca=new_tca,
                        created_by=current_user.id,
                    )
                    db.session.add(entry)

                patient.name = Config.encrypt_data_static(name)
                patient.age = _parse_age_years(request.form.get('age'))
                patient.gender = (request.form.get('gender') or None)
                patient.address = (
                    Config.encrypt_data_static(request.form.get('address'))
                    if (request.form.get('address') or '').strip()
                    else None
                )
                if old_phone != new_phone:
                    patient.phone = Config.encrypt_data_static(new_phone) if new_phone else None
                patient.destination = (request.form.get('destination') or None)
                patient.occupation = (
                    Config.encrypt_data_static(request.form.get('occupation'))
                    if (request.form.get('occupation') or '').strip()
                    else None
                )
                if old_religion != new_religion:
                    patient.religion = (new_religion or None)
                if old_nok_name != new_nok_name:
                    patient.nok_name = Config.encrypt_data_static(new_nok_name) if new_nok_name else None
                if old_nok_contact != new_nok_contact:
                    patient.nok_contact = Config.encrypt_data_static(new_nok_contact) if new_nok_contact else None
                if old_tca != new_tca:
                    patient.tca = new_tca
                db.session.commit()
                flash('Biodata updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating biodata: {str(e)}', 'danger')

            return _redirect_back('biodata')
        
        # Add these new sections for chief complaint and HPI
        if section == 'chief_complaint':
            try:
                chief_complaint = (request.form.get('chief_complaint') or '').strip()
                if chief_complaint:
                    old_text = (patient.chief_complaint or '').strip()
                    existing_count = PatientChiefComplaintEntry.query.filter_by(patient_id=patient.id).count()
                    if existing_count == 0 and old_text and old_text != chief_complaint:
                        db.session.add(PatientChiefComplaintEntry(
                            patient_id=patient.id,
                            complaint_text=old_text,
                            created_by=current_user.id,
                        ))
                    db.session.add(PatientChiefComplaintEntry(
                        patient_id=patient.id,
                        complaint_text=chief_complaint,
                        created_by=current_user.id,
                    ))
                    patient.chief_complaint = chief_complaint
                    db.session.commit()
                    flash('Chief complaint updated successfully!', 'success')
                else:
                    flash('Chief complaint cannot be empty', 'warning')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating chief complaint: {str(e)}', 'danger')
        
        elif section == 'hpi':
            try:
                hpi = (request.form.get('history_present_illness') or '').strip()
                if hpi:
                    old_text = (patient.history_present_illness or '').strip()
                    existing_count = PatientHPIEntry.query.filter_by(patient_id=patient.id).count()
                    if existing_count == 0 and old_text and old_text != hpi:
                        db.session.add(PatientHPIEntry(
                            patient_id=patient.id,
                            hpi_text=old_text,
                            created_by=current_user.id,
                        ))
                    db.session.add(PatientHPIEntry(
                        patient_id=patient.id,
                        hpi_text=hpi,
                        created_by=current_user.id,
                    ))
                    patient.history_present_illness = hpi
                    db.session.commit()
                    flash('History of present illness updated successfully!', 'success')
                else:
                    flash('History of present illness cannot be empty', 'warning')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating history of present illness: {str(e)}', 'danger')
        
        elif section == 'review_systems':
            try:
                review_systems = PatientReviewSystem(
                    patient_id=patient.id,
                    cns=request.form.get('cns'),
                    cvs=request.form.get('cvs'),
                    rs=request.form.get('rs'),
                    git=request.form.get('git'),
                    gut=request.form.get('gut'),
                    skin=request.form.get('skin'),
                    msk=request.form.get('msk'),
                    created_by=current_user.id,
                )
                db.session.add(review_systems)
                
                db.session.commit()
                flash('Review of systems updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating review of systems: {str(e)}', 'danger')
        
        elif section == 'history':
            try:
                history = PatientHistory(
                    patient_id=patient.id,
                    social_history=request.form.get('social_history'),
                    medical_history=request.form.get('medical_history'),
                    surgical_history=request.form.get('surgical_history'),
                    family_history=request.form.get('family_history'),
                    allergies=request.form.get('allergies'),
                    medications=request.form.get('medications'),
                    created_by=current_user.id,
                )
                db.session.add(history)
                
                db.session.commit()
                flash('Medical history updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating medical history: {str(e)}', 'danger')
        
        elif section == 'examination':
            try:
                examination = PatientExamination(
                    patient_id=patient.id,
                    general_appearance=request.form.get('general_appearance'),
                    temperature=request.form.get('temperature'),
                    pulse=request.form.get('pulse'),
                    resp_rate=request.form.get('resp_rate'),
                    bp_systolic=request.form.get('bp_systolic'),
                    bp_diastolic=request.form.get('bp_diastolic'),
                    spo2=request.form.get('spo2'),
                    cvs_exam=request.form.get('cvs_exam'),
                    resp_exam=request.form.get('resp_exam'),
                    abdo_exam=request.form.get('abdo_exam'),
                    cns_exam=request.form.get('cns_exam'),
                    created_by=current_user.id,
                )
                db.session.add(examination)
                
                db.session.commit()
                flash('Examination findings updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating examination findings: {str(e)}', 'danger')
        
        elif section == 'diagnosis':
            try:
                diagnosis = PatientDiagnosis(
                    patient_id=patient.id,
                    working_diagnosis=request.form.get('working_diagnosis'),
                    differential_diagnosis=request.form.get('differential_diagnosis'),
                    working_diagnosis_supporting_argument=request.form.get('working_diagnosis_supporting_argument'),
                    differential_diagnosis_supporting_argument=request.form.get('differential_diagnosis_supporting_argument'),
                    created_by=current_user.id,
                )
                db.session.add(diagnosis)
                
                db.session.commit()
                flash('Diagnosis updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating diagnosis: {str(e)}', 'danger')
        
        elif section == 'management':
            try:
                # Append-only management plan entries (preserve previous updates)
                prev_management = (
                    PatientManagement.query
                    .filter_by(patient_id=patient.id)
                    .order_by(PatientManagement.created_at.desc(), PatientManagement.id.desc())
                    .first()
                )

                treatment_plan = (request.form.get('treatment_plan') or '').strip()
                follow_up = (request.form.get('follow_up') or '').strip()
                notes = (request.form.get('management_notes') or '').strip()

                # Allow partial updates (e.g., dedicated modals for treatment vs follow-up)
                if not treatment_plan and prev_management:
                    treatment_plan = prev_management.treatment_plan or ''
                if not follow_up and prev_management:
                    follow_up = prev_management.follow_up or ''
                if not notes and prev_management:
                    notes = prev_management.notes or ''

                management = PatientManagement(
                    patient_id=patient.id,
                    treatment_plan=treatment_plan,
                    follow_up=follow_up,
                    notes=notes,
                    created_by=current_user.id,
                )
                db.session.add(management)

                # Prescriptions are created via /doctor/patient/complete_prescription from the
                # Management tab "Complete Prescription" button. Do not create prescriptions
                # on Management plan save to avoid duplicates.

                # Services are completed via /doctor/complete_services from the
                # Management tab "Complete Services" button.
                
                db.session.commit()
                flash('Management plan updated successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error updating management plan: {str(e)}', 'danger')
        
        elif section == 'lab_request':
            try:
                test_id = request.form.get('test_id')
                if not test_id:
                    flash('Please select a test', 'danger')
                    return _redirect_back('investigations')
                
                lab_test = db.session.get(LabTest, test_id)
                if not lab_test:
                    flash('Lab test not found', 'danger')
                    return _redirect_back('investigations')
                
                lab_request = LabRequest(
                    patient_id=patient.id,
                    test_id=lab_test.id,
                    status='pending',
                    notes=request.form.get('notes'),
                    requested_by=current_user.id
                )
                db.session.add(lab_request)
                
                # Create financial records
                create_service_sale_and_transaction(
                    patient_id=patient.id,
                    service_item=lab_test,
                    service_type='lab',
                    requested_by_id=current_user.id,
                    notes=request.form.get('notes')
                )
                
                db.session.commit()
                
                flash('Lab request sent successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error sending lab request: {str(e)}', 'danger')
        
        elif section == 'imaging_request':
            try:
                test_id = request.form.get('test_id')
                if not test_id:
                    flash('Please select a test', 'danger')
                    return _redirect_back('investigations')
                
                imaging_test = db.session.get(ImagingTest, test_id)
                if not imaging_test:
                    flash('Imaging test not found', 'danger')
                    return _redirect_back('investigations')
                
                imaging_request = ImagingRequest(
                    patient_id=patient.id,
                    test_id=imaging_test.id,
                    status='pending',
                    notes=request.form.get('notes'),
                    requested_by=current_user.id
                )
                db.session.add(imaging_request)

                # Create financial records
                create_service_sale_and_transaction(
                    patient_id=patient.id,
                    service_item=imaging_test,
                    service_type='imaging',
                    requested_by_id=current_user.id,
                    notes=request.form.get('notes')
                )

                db.session.commit()
                
                flash('Imaging request sent successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error sending imaging request: {str(e)}', 'danger')
        
        elif request.form.get('action') == 'complete_treatment':
            try:
                # Enforce pay-before-discharge for ward stays (friendly flash on block)
                try:
                    ctx = _get_patient_bed_stay_context(patient.id)
                    if ctx:
                        daily_rate = float(ctx.get('daily_rate') or 0)
                        if daily_rate > 0:
                            bed_id = int(ctx['bed_id'])
                            start_date = ctx['start_date']
                            end_date = ctx['end_date']

                            last = (
                                BedStayCharge.query
                                .filter_by(bed_id=bed_id, patient_id=patient.id)
                                .order_by(BedStayCharge.charge_end_date.desc())
                                .first()
                            )
                            last_end = last.charge_end_date if last else None
                            bill_start = start_date
                            if last_end:
                                bill_start = max(bill_start, last_end + timedelta(days=1))

                            if bill_start <= end_date:
                                days_due = (end_date - bill_start).days + 1
                            else:
                                days_due = 0

                            if days_due > 0 and not _ward_stay_is_paid_through(patient.id, bed_id, end_date):
                                amount_due = float(days_due) * daily_rate
                                flash(
                                    (
                                        'Cannot discharge: ward stay charges are unpaid. '
                                        f"Ward: {ctx.get('ward_name') or '-'}, Bed: {ctx.get('bed_number') or '-'}, "
                                        f"Due: {int(days_due)} day(s) ({bill_start.isoformat()} to {end_date.isoformat()}) "
                                        f"at {float(daily_rate):.2f}/day = {float(amount_due):.2f}. "
                                        'Please ask reception to bill/pay the ward stay, then try again.'
                                    ),
                                    'warning'
                                )
                                return _redirect_back('biodata')
                except Exception:
                    # Do not block discharge if ward stay check fails unexpectedly.
                    pass

                patient.status = 'completed'
                patient.updated_at = get_eat_now()
                db.session.commit()
                flash('Patient treatment marked as completed!', 'success')
                return redirect(url_for('doctor_patients'))
            except Exception as e:
                db.session.rollback()
                flash(f'Error completing treatment: {str(e)}', 'danger')
        
        elif request.form.get('action') == 'readmit_patient':
            try:
                patient.status = 'active'
                patient.updated_at = get_eat_now()
                db.session.commit()
                flash('Patient readmitted successfully!', 'success')
            except Exception as e:
                db.session.rollback()
                flash(f'Error readmitting patient: {str(e)}', 'danger')
        
        return _redirect_back('biodata')
    
    def _resolve_version(versions, selected_id):
        if not versions:
            return None, {'total': 0, 'index': 0, 'prev_id': None, 'next_id': None}
        selected = None
        if selected_id is not None:
            selected = next((v for v in versions if v.id == selected_id), None)
        if selected is None:
            selected = versions[-1]
        idx = next((i for i, v in enumerate(versions) if v.id == selected.id), len(versions) - 1)
        prev_id = versions[idx - 1].id if idx > 0 else None
        next_id = versions[idx + 1].id if idx < len(versions) - 1 else None
        return selected, {'total': len(versions), 'index': idx + 1, 'prev_id': prev_id, 'next_id': next_id}

    # Get all related data (append-only history; default to latest unless an id is provided)
    review_versions = PatientReviewSystem.query.filter_by(patient_id=patient.id) \
        .order_by(PatientReviewSystem.created_at.asc(), PatientReviewSystem.id.asc()).all()
    history_versions = PatientHistory.query.filter_by(patient_id=patient.id) \
        .order_by(PatientHistory.created_at.asc(), PatientHistory.id.asc()).all()
    exam_versions = PatientExamination.query.filter_by(patient_id=patient.id) \
        .order_by(PatientExamination.created_at.asc(), PatientExamination.id.asc()).all()
    diagnosis_versions = PatientDiagnosis.query.filter_by(patient_id=patient.id) \
        .order_by(PatientDiagnosis.created_at.asc(), PatientDiagnosis.id.asc()).all()
    management_versions = PatientManagement.query.filter_by(patient_id=patient.id) \
        .order_by(PatientManagement.created_at.asc(), PatientManagement.id.asc()).all()

    biodata_versions = PatientBiodataEntry.query.filter_by(patient_id=patient.id) \
        .order_by(PatientBiodataEntry.created_at.asc(), PatientBiodataEntry.id.asc()).all()
    complaint_versions = PatientChiefComplaintEntry.query.filter_by(patient_id=patient.id) \
        .order_by(PatientChiefComplaintEntry.created_at.asc(), PatientChiefComplaintEntry.id.asc()).all()
    hpi_versions = PatientHPIEntry.query.filter_by(patient_id=patient.id) \
        .order_by(PatientHPIEntry.created_at.asc(), PatientHPIEntry.id.asc()).all()

    review_systems, review_nav = _resolve_version(review_versions, request.args.get('review_id', type=int))
    history, history_nav = _resolve_version(history_versions, request.args.get('history_id', type=int))
    examination, examination_nav = _resolve_version(exam_versions, request.args.get('exam_id', type=int))
    diagnosis, diagnosis_nav = _resolve_version(diagnosis_versions, request.args.get('diagnosis_id', type=int))
    management, management_nav = _resolve_version(management_versions, request.args.get('management_id', type=int))

    biodata_entry, biodata_nav = _resolve_version(biodata_versions, request.args.get('biodata_id', type=int))
    chief_complaint_entry, chief_complaint_nav = _resolve_version(complaint_versions, request.args.get('complaint_id', type=int))
    hpi_entry, hpi_nav = _resolve_version(hpi_versions, request.args.get('hpi_id', type=int))

    def _dec(val):
        return patient._safe_decrypt(val)

    biodata_view = {
        'phone': _dec(biodata_entry.phone) if biodata_entry else patient.get_decrypted_phone,
        'nok_name': _dec(biodata_entry.nok_name) if biodata_entry else patient.get_decrypted_nok_name,
        'nok_contact': _dec(biodata_entry.nok_contact) if biodata_entry else patient.get_decrypted_nok_contact,
        'religion': (biodata_entry.religion if biodata_entry else patient.religion),
        'tca': (biodata_entry.tca if biodata_entry else patient.tca),
    }

    chief_complaint_text = (chief_complaint_entry.complaint_text if chief_complaint_entry else patient.chief_complaint)
    hpi_text = (hpi_entry.hpi_text if hpi_entry else patient.history_present_illness)
    lab_tests = LabTest.query.all()
    imaging_tests = ImagingTest.query.all()
    lab_requests = LabRequest.query.filter_by(patient_id=patient.id).all()
    imaging_requests = ImagingRequest.query.filter_by(patient_id=patient.id).all()
    prescriptions = Prescription.query.filter_by(patient_id=patient.id) \
        .order_by(Prescription.created_at.desc(), Prescription.id.desc()) \
        .options(
            db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug),
            db.joinedload(Prescription.doctor),
            db.joinedload(Prescription.dispenser),
        ).all()
    controlled_prescriptions = ControlledPrescription.query.filter_by(patient_id=patient.id) \
        .order_by(ControlledPrescription.created_at.desc(), ControlledPrescription.id.desc()) \
        .options(
            db.joinedload(ControlledPrescription.items).joinedload(ControlledPrescriptionItem.controlled_drug),
            db.joinedload(ControlledPrescription.doctor),
            db.joinedload(ControlledPrescription.dispenser),
        ).all()
    patient_services = PatientService.query.filter_by(patient_id=patient.id) \
    .order_by(
        PatientService.completed_at.desc().nullslast(),
        PatientService.updated_at.desc(),
        PatientService.created_at.desc(),
        PatientService.id.desc(),
    ).options(
        db.joinedload(PatientService.service),
        db.joinedload(PatientService.requester),
        db.joinedload(PatientService.biller),
        db.joinedload(PatientService.completer),
        db.joinedload(PatientService.performer),
        db.joinedload(PatientService.billed_sale),
    ).all()
    
    return render_template('doctor/patient_details.html',
        patient=patient,
        biodata_entry=biodata_entry,
        biodata_nav=biodata_nav,
        biodata_view=biodata_view,
        biodata_versions=biodata_versions,
        chief_complaint_entry=chief_complaint_entry,
        chief_complaint_nav=chief_complaint_nav,
        chief_complaint_text=chief_complaint_text,
        complaint_versions=complaint_versions,
        hpi_entry=hpi_entry,
        hpi_nav=hpi_nav,
        hpi_text=hpi_text,
        hpi_versions=hpi_versions,
        review_systems=review_systems,
        review_nav=review_nav,
        review_versions=review_versions,
        history=history,
        history_nav=history_nav,
        history_versions=history_versions,
        examination=examination,
        examination_nav=examination_nav,
        exam_versions=exam_versions,
        diagnosis=diagnosis,
        diagnosis_nav=diagnosis_nav,
        diagnosis_versions=diagnosis_versions,
        management=management,
        management_nav=management_nav,
        management_versions=management_versions,
        lab_tests=lab_tests,
        imaging_tests=imaging_tests,
        lab_requests=lab_requests,
        imaging_requests=imaging_requests,
        prescriptions=prescriptions,
        controlled_prescriptions=controlled_prescriptions,
        patient_services=patient_services,
        drugs=drugs,
        controlled_drugs=controlled_drugs,
        services=services
    )

@app.route('/doctor/prescription/<int:prescription_id>')
@login_required
def doctor_prescription_details(prescription_id):
    if current_user.role != 'doctor':
        return jsonify({'error': 'Unauthorized'}), 403

    prescription = db.session.get(Prescription, prescription_id)
    if not prescription:
        return jsonify({'error': 'Prescription not found'}), 404

    items = [
        {
            'id': item.id,
            'drug_id': item.drug_id,
            'drug_name': item.drug.name,
            'quantity': item.quantity,
            'dosage': item.dosage,
            'frequency': item.frequency,
            'duration': item.duration,
            'notes': item.notes,
            'status': item.status,
        }
        for item in prescription.items
    ]

    return jsonify({
        'id': prescription.id,
        'patient_id': prescription.patient_id,
        'patient_name': prescription.patient.name if prescription.patient else '',
        'patient_number': prescription.patient.op_number or prescription.patient.ip_number if prescription.patient else '',
        'notes': prescription.notes,
        'status': prescription.status,
        'created_at': prescription.created_at.strftime('%Y-%m-%d %H:%M'),
        'items': items,
    })


@app.route('/doctor/lab-request/<int:request_id>/complete', methods=['POST'])
@login_required
def complete_lab_request(request_id):
    if current_user.role not in ('doctor', 'admin'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    lab_request = db.session.get(LabRequest, request_id)
    if not lab_request:
        flash('Lab request not found', 'danger')
        return redirect(url_for('doctor_patients'))

    patient = db.session.get(Patient, lab_request.patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_patients'))

    result_text = (request.form.get('result') or '').strip()
    if not result_text:
        flash('Result cannot be empty', 'danger')
        return redirect(url_for('doctor_patient_details', patient_id=patient.id))

    force = (request.form.get('force') == '1') and (current_user.role == 'admin')
    if not force:
        is_paid = _patient_has_paid_sale_for_item(patient_id=patient.id, lab_test_id=lab_request.test_id)
        if not is_paid:
            flash('Payment required before completing this lab test. Please bill and pay via Reception.', 'warning')
            return redirect(url_for('doctor_patient_details', patient_id=patient.id))

    try:
        lab_request.result = result_text
        lab_request.status = 'completed'
        lab_request.performed_by = current_user.id
        lab_request.performed_at = get_eat_now()
        db.session.commit()
        flash('Lab result saved and request marked completed.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error saving lab result: {str(e)}', 'danger')

    return redirect(url_for('doctor_patient_details', patient_id=patient.id))


@app.route('/doctor/imaging-request/<int:request_id>/complete', methods=['POST'])
@login_required
def complete_imaging_request(request_id):
    if current_user.role not in ('doctor', 'admin'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    imaging_request = db.session.get(ImagingRequest, request_id)
    if not imaging_request:
        flash('Imaging request not found', 'danger')
        return redirect(url_for('doctor_patients'))

    patient = db.session.get(Patient, imaging_request.patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('doctor_patients'))

    result_text = (request.form.get('result') or '').strip()
    if not result_text:
        flash('Result cannot be empty', 'danger')
        return redirect(url_for('doctor_patient_details', patient_id=patient.id))

    force = (request.form.get('force') == '1') and (current_user.role == 'admin')
    if not force:
        imaging_test = db.session.get(ImagingTest, imaging_request.test_id)
        is_paid = _patient_has_paid_sale_for_imaging_test(patient_id=patient.id, imaging_test=imaging_test)
        if not is_paid:
            flash('Payment required before completing this imaging study. Please bill and pay via Reception.', 'warning')
            return redirect(url_for('doctor_patient_details', patient_id=patient.id))

    try:
        imaging_request.result = result_text
        imaging_request.status = 'completed'
        imaging_request.performed_by = current_user.id
        imaging_request.performed_at = get_eat_now()
        db.session.commit()
        flash('Imaging result saved and request marked completed.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error saving imaging result: {str(e)}', 'danger')

    return redirect(url_for('doctor_patient_details', patient_id=patient.id))

@app.route('/doctor/patient/complete_prescription', methods=['POST'])
@login_required
def complete_prescription():
    if current_user.role != 'doctor':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403
    
    data = request.get_json()
    patient_id = data.get('patient_id')
    prescriptions = data.get('prescriptions', [])
    
    if not patient_id:
        return jsonify({'success': False, 'error': 'Patient ID required'}), 400
    
    if not prescriptions:
        return jsonify({'success': False, 'error': 'No prescriptions provided'}), 400
    
    try:
        normal_items = []
        controlled_items = []
        for item in prescriptions:
            is_controlled = bool(item.get('is_controlled')) or bool(item.get('controlled_drug_id'))
            if is_controlled:
                controlled_items.append(item)
            else:
                normal_items.append(item)

        created_prescription_id = None
        created_controlled_prescription_id = None

        if normal_items:
            prescription = Prescription(
                patient_id=patient_id,
                doctor_id=current_user.id,
                status='pending',
                notes='Prescription completed by doctor'
            )
            db.session.add(prescription)
            db.session.flush()

            for item in normal_items:
                drug = db.session.get(Drug, item.get('drug_id'))
                if not drug:
                    continue
                db.session.add(PrescriptionItem(
                    prescription_id=prescription.id,
                    drug_id=drug.id,
                    quantity=int(item['quantity']),
                    dosage=item.get('dosage'),
                    frequency=item.get('frequency'),
                    duration=item.get('duration'),
                    notes=item.get('notes'),
                    status='pending'
                ))

            created_prescription_id = prescription.id
            log_audit('create_prescription', 'Prescription', prescription.id, None, {
                'patient_id': patient_id,
                'items_count': len(normal_items),
                'action': 'doctor_completed_prescription'
            })

        if controlled_items:
            c_prescription = ControlledPrescription(
                patient_id=patient_id,
                doctor_id=current_user.id,
                status='pending',
                notes='Controlled prescription completed by doctor'
            )
            db.session.add(c_prescription)
            db.session.flush()

            for item in controlled_items:
                cdrug = db.session.get(ControlledDrug, item.get('controlled_drug_id'))
                if not cdrug:
                    continue
                db.session.add(ControlledPrescriptionItem(
                    controlled_prescription_id=c_prescription.id,
                    controlled_drug_id=cdrug.id,
                    quantity=int(item['quantity']),
                    dosage=item.get('dosage'),
                    frequency=item.get('frequency'),
                    duration=item.get('duration'),
                    notes=item.get('notes'),
                    status='pending'
                ))

            created_controlled_prescription_id = c_prescription.id
            log_audit('create_controlled_prescription', 'ControlledPrescription', c_prescription.id, None, {
                'patient_id': patient_id,
                'items_count': len(controlled_items),
                'action': 'doctor_completed_controlled_prescription'
            })

        db.session.commit()

        return jsonify({
            'success': True,
            'prescription_id': created_prescription_id,
            'controlled_prescription_id': created_controlled_prescription_id,
            'message': 'Prescription sent to pharmacy successfully'
        })
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


# ============================================================================
# NURSE ROUTES
# ============================================================================

@app.route('/nurse')
@login_required
def nurse_dashboard():
    """Nurse dashboard with quick stats and pending tasks."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Count inpatients with access control
    base_inpatients_query = Patient.query.filter_by(patient_type='inpatient', status='active')
    inpatients_count = filter_accessible_patients(base_inpatients_query, current_user).count()
    
    # Count pending nurse notifications
    pending_notifications = NurseNotification.query.filter_by(status='pending').count()
    
    # Count medications due (placeholder - would need prescription system integration)
    medications_due = 0
    
    # Count available beds in accessible wards
    accessible_ward_ids = get_user_accessible_ward_ids(current_user)
    if accessible_ward_ids:
        available_beds = Bed.query.filter_by(status='available').filter(Bed.ward_id.in_(accessible_ward_ids)).count()
    else:
        available_beds = Bed.query.filter_by(status='available').count()
    
    # Get recent nursing reports
    recent_reports = (
        NursingReport.query
        .filter_by(nurse_id=current_user.id)
        .order_by(NursingReport.created_at.desc())
        .limit(10)
        .all()
    )
    
    # Get pending notifications for display (filtered by accessible wards if assigned)
    if accessible_ward_ids:
        # Filter notifications for patients in accessible wards
        notifications = (
            NurseNotification.query
            .join(Patient, NurseNotification.patient_id == Patient.id)
            .join(Bed, Bed.patient_id == Patient.id)
            .filter(NurseNotification.status == 'pending')
            .filter(Bed.ward_id.in_(accessible_ward_ids))
            .order_by(NurseNotification.notified_at.asc())
            .limit(10)
            .all()
        )
    else:
        notifications = (
            NurseNotification.query
            .filter_by(status='pending')
            .order_by(NurseNotification.notified_at.asc())
            .limit(10)
            .all()
        )
    
    return render_template(
        'nurse/dashboard.html',
        inpatients_count=inpatients_count,
        pending_notifications=pending_notifications,
        medications_due=medications_due,
        available_beds=available_beds,
        recent_reports=recent_reports,
        notifications=notifications
    )


@app.route('/nurse/patients')
@login_required
def nurse_patients():
    """List all inpatients."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Get all inpatients with access control
    base_patients_query = Patient.query.filter_by(patient_type='inpatient', status='active')
    patients = filter_accessible_patients(base_patients_query, current_user).order_by(Patient.created_at.desc()).all()
    
    # Attach latest nursing report to each patient
    for patient in patients:
        patient.latest_report = (
            NursingReport.query
            .filter_by(patient_id=patient.id)
            .order_by(NursingReport.created_at.desc())
            .first()
        )
    
    # Get all wards for filtering
    wards = Ward.query.order_by(Ward.name).all()
    
    return render_template(
        'nurse/patients.html',
        patients=patients,
        wards=wards
    )


@app.route('/nurse/patient/<int:patient_id>')
@login_required
def nurse_patient_details(patient_id):
    """Detailed view of a patient with vitals, reports, and medications."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get_or_404(Patient, patient_id)
    
    # Check if nurse can access this patient
    if not can_user_access_patient(current_user, patient):
        flash('You do not have access to this patient', 'danger')
        return redirect(url_for('nurse_patients'))
    
    # Get latest vitals (most recent nursing report with vitals)
    latest_vitals = (
        NursingReport.query
        .filter_by(patient_id=patient_id)
        .filter(
            or_(
                NursingReport.temperature.isnot(None),
                NursingReport.blood_pressure_systolic.isnot(None),
                NursingReport.pulse_rate.isnot(None)
            )
        )
        .order_by(NursingReport.created_at.desc())
        .first()
    )
    
    # Get all nursing reports
    nursing_reports = (
        NursingReport.query
        .filter_by(patient_id=patient_id)
        .order_by(NursingReport.created_at.desc())
        .all()
    )
    
    # Get medication administration history
    medications = (
        MedicationAdministration.query
        .filter_by(patient_id=patient_id)
        .order_by(MedicationAdministration.administered_at.desc())
        .limit(50)
        .all()
    )

    lab_requests = (
        LabRequest.query
        .filter(LabRequest.patient_id == patient_id)
        .order_by(LabRequest.created_at.desc())
        .limit(30)
        .all()
    )
    
    return render_template(
        'nurse/patient_details.html',
        patient=patient,
        latest_vitals=latest_vitals,
        nursing_reports=nursing_reports,
        medications=medications,
        lab_requests=lab_requests,
    )


@app.route('/nurse/patient/<int:patient_id>/vitals', methods=['POST'])
@login_required
def nurse_add_vitals(patient_id):
    """Add vital signs for a patient."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get_or_404(Patient, patient_id)
    
    try:
        # Create nursing report with vitals
        report = NursingReport(
            patient_id=patient_id,
            nurse_id=current_user.id,
            report_type='general',
            temperature=float(request.form.get('temperature')) if request.form.get('temperature') else None,
            blood_pressure_systolic=int(request.form.get('blood_pressure_systolic')) if request.form.get('blood_pressure_systolic') else None,
            blood_pressure_diastolic=int(request.form.get('blood_pressure_diastolic')) if request.form.get('blood_pressure_diastolic') else None,
            pulse_rate=int(request.form.get('pulse_rate')) if request.form.get('pulse_rate') else None,
            respiratory_rate=int(request.form.get('respiratory_rate')) if request.form.get('respiratory_rate') else None,
            oxygen_saturation=int(request.form.get('oxygen_saturation')) if request.form.get('oxygen_saturation') else None,
            blood_sugar=float(request.form.get('blood_sugar')) if request.form.get('blood_sugar') else None,
            observations=request.form.get('observations'),
            pain_level=int(request.form.get('pain_level')) if request.form.get('pain_level') else None,
            urgent=bool(request.form.get('urgent'))
        )
        
        db.session.add(report)
        db.session.commit()
        
        flash('Vital signs recorded successfully', 'success')
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error recording vitals: {e}")
        flash(f'Error recording vitals: {str(e)}', 'danger')
    
    return redirect(url_for('nurse_patient_details', patient_id=patient_id))


@app.route('/nurse/patient/<int:patient_id>/medication', methods=['POST'])
@login_required
def nurse_administer_medication(patient_id):
    """Record medication administration."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get_or_404(Patient, patient_id)
    
    try:
        # Create medication administration record
        med_admin = MedicationAdministration(
            patient_id=patient_id,
            nurse_id=current_user.id,
            medication_name=request.form.get('medication_name'),
            dosage=request.form.get('dosage'),
            route=request.form.get('route', 'oral'),
            frequency=request.form.get('frequency'),
            status=request.form.get('status', 'administered'),
            notes=request.form.get('notes'),
            administered_at=get_eat_now()
        )
        
        db.session.add(med_admin)
        db.session.commit()
        
        flash('Medication administration recorded successfully', 'success')
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error recording medication: {e}")
        flash(f'Error recording medication: {str(e)}', 'danger')
    
    return redirect(url_for('nurse_patient_details', patient_id=patient_id))


@app.route('/nurse/patient/<int:patient_id>/report', methods=['POST'])
@login_required
def nurse_add_report(patient_id):
    """Add a nursing report/observation."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get_or_404(Patient, patient_id)
    
    try:
        # Create nursing report
        report = NursingReport(
            patient_id=patient_id,
            nurse_id=current_user.id,
            report_type=request.form.get('report_type', 'general'),
            observations=request.form.get('observations'),
            symptoms=request.form.get('symptoms'),
            care_provided=request.form.get('care_provided'),
            consciousness_level=request.form.get('consciousness_level'),
            recommendations=request.form.get('recommendations'),
            urgent=bool(request.form.get('urgent')),
            doctor_notified=bool(request.form.get('doctor_notified'))
        )
        
        db.session.add(report)
        db.session.commit()
        
        flash('Nursing report saved successfully', 'success')
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error saving report: {e}")
        flash(f'Error saving report: {str(e)}', 'danger')
    
    return redirect(url_for('nurse_patient_details', patient_id=patient_id))


@app.route('/nurse/notifications')
@login_required
def nurse_notifications():
    """View all nurse notifications (pending admissions)."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Get pending notifications
    pending_notifications = (
        NurseNotification.query
        .filter_by(status='pending')
        .order_by(NurseNotification.notified_at.asc())
        .all()
    )
    
    # Calculate elapsed time for each notification
    now = get_eat_now()
    for notif in pending_notifications:
        elapsed = now - notif.notified_at
        notif.elapsed_minutes = int(elapsed.total_seconds() / 60)
    
    # Get completed notifications (last 24 hours)
    completed_cutoff = get_eat_now() - timedelta(hours=24)
    completed_notifications = (
        NurseNotification.query
        .filter_by(status='completed')
        .filter(NurseNotification.completed_at >= completed_cutoff)
        .order_by(NurseNotification.completed_at.desc())
        .limit(50)
        .all()
    )
    
    pending_count = len(pending_notifications)
    
    return render_template(
        'nurse/notifications.html',
        pending_notifications=pending_notifications,
        completed_notifications=completed_notifications,
        pending_count=pending_count
    )


@app.route('/nurse/notification/<int:notification_id>/complete', methods=['POST'])
@login_required
def nurse_complete_notification(notification_id):
    """Mark a nurse notification as completed."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    try:
        notification = _db_get_or_404(NurseNotification, notification_id)
        notification.status = 'completed'
        notification.completed_at = get_eat_now()
        
        db.session.commit()
        
        flash('Notification marked as completed', 'success')
        
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error completing notification: {e}")
        flash(f'Error: {str(e)}', 'danger')
    
    return redirect(url_for('nurse_notifications'))


def _require_role(required_roles):
    """Shared helper to gate routes by user role."""
    user_role = str(getattr(current_user, 'role', '') or '').lower().strip()
    if isinstance(required_roles, str):
        required = {required_roles}
    else:
        required = {str(r).lower().strip() for r in (required_roles or [])}
    if user_role not in required:
        flash('Unauthorized access', 'danger')
        return False
    return True


@app.route('/labtech/dashboard')
@login_required
def labtech_dashboard():
    # Doctors are allowed to access lab workflows via the "Open Lab" entry.
    # This does NOT grant labtechs access to doctor pages (doctor pages remain doctor-only).
    if not _require_role({'labtech', 'admin', 'doctor'}):
        return redirect(url_for('home'))

    pending_count = LabRequest.query.filter(LabRequest.status == 'pending').count()
    since_7d = get_eat_now() - timedelta(days=7)
    completed_7d_count = LabRequest.query.filter(LabRequest.status == 'completed', LabRequest.updated_at >= since_7d).count()
    cancelled_7d_count = LabRequest.query.filter(LabRequest.status == 'cancelled', LabRequest.updated_at >= since_7d).count()

    recent_pending = (
        LabRequest.query
        .filter(LabRequest.status == 'pending')
        .order_by(LabRequest.created_at.desc())
        .limit(15)
        .all()
    )

    return render_template(
        'labtech/dashboard.html',
        pending_count=pending_count,
        completed_7d_count=completed_7d_count,
        cancelled_7d_count=cancelled_7d_count,
        recent_pending=recent_pending,
    )


@app.route('/labtech/lab-requests')
@login_required
def labtech_lab_requests():
    if not _require_role({'labtech', 'admin', 'doctor'}):
        return redirect(url_for('home'))

    status = (request.args.get('status') or '').strip().lower() or None
    scope = (request.args.get('scope') or '').strip().lower() or None
    dept_id = (request.args.get('department_id') or '').strip() or None
    q = (request.args.get('q') or '').strip()

    query = LabRequest.query
    if status in {'pending', 'completed', 'cancelled'}:
        query = query.filter(LabRequest.status == status)

    # Scope: inpatient/outpatient based on patient numbers
    if scope in {'inpatient', 'outpatient'}:
        query = query.join(Patient, Patient.id == LabRequest.patient_id)
        if scope == 'inpatient':
            query = query.filter(Patient.ip_number.isnot(None)).filter(Patient.ip_number != '')
        else:
            query = query.filter(Patient.op_number.isnot(None)).filter(Patient.op_number != '')

    # Department filter (outpatient)
    if dept_id:
        try:
            dept_id_int = int(dept_id)
            if 'patient' not in str(query):
                query = query.join(Patient, Patient.id == LabRequest.patient_id)
            query = query.filter(Patient.department_id == dept_id_int)
        except Exception:
            dept_id = None

    if q:
        like = f"%{q}%"
        query = (
            query
            .join(Patient, Patient.id == LabRequest.patient_id)
            .join(LabTest, LabTest.id == LabRequest.test_id)
            .filter(
                or_(
                    Patient.name.ilike(like),
                    Patient.op_number.ilike(like),
                    Patient.ip_number.ilike(like),
                    LabTest.name.ilike(like),
                )
            )
        )

    requests_list = query.order_by(LabRequest.created_at.desc()).limit(500).all()

    departments = []
    try:
        departments = OutpatientDepartment.query.order_by(OutpatientDepartment.name).all()
    except Exception:
        departments = []

    return render_template(
        'labtech/lab_requests.html',
        requests=requests_list,
        status=status,
        scope=scope,
        departments=departments,
        department_id=str(dept_id) if dept_id else '',
        q=q,
    )


@app.route('/labtech/lab-request/<int:request_id>')
@login_required
def labtech_lab_request_detail(request_id):
    if not _require_role({'labtech', 'admin', 'doctor'}):
        return redirect(url_for('home'))

    lab_request = db.session.get(LabRequest, request_id)
    if not lab_request:
        flash('Lab request not found', 'danger')
        return redirect(url_for('labtech_lab_requests'))

    patient = db.session.get(Patient, lab_request.patient_id)
    return render_template('labtech/lab_request_detail.html', lab_request=lab_request, patient=patient)


@app.route('/labtech/lab-request/<int:request_id>/complete', methods=['POST'])
@login_required
def labtech_complete_lab_request(request_id):
    if not _require_role({'labtech', 'admin', 'doctor'}):
        return redirect(url_for('home'))

    lab_request = db.session.get(LabRequest, request_id)
    if not lab_request:
        flash('Lab request not found', 'danger')
        return redirect(url_for('labtech_lab_requests'))

    if lab_request.status == 'cancelled':
        flash('Cannot complete a cancelled lab request.', 'warning')
        return redirect(url_for('labtech_lab_request_detail', request_id=request_id))

    result_text = (request.form.get('result') or '').strip()
    if not result_text:
        flash('Result cannot be empty', 'danger')
        return redirect(url_for('labtech_lab_request_detail', request_id=request_id))

    # Enforce billing (admin can force)
    patient = db.session.get(Patient, lab_request.patient_id)
    force = (request.form.get('force') == '1') and (str(current_user.role).lower().strip() == 'admin')
    if not force and patient:
        is_paid = _patient_has_paid_sale_for_item(patient_id=patient.id, lab_test_id=lab_request.test_id)
        if not is_paid:
            flash('Payment required before completing this lab test. Please bill and pay via Reception.', 'warning')
            return redirect(url_for('labtech_lab_request_detail', request_id=request_id))

    try:
        lab_request.result = result_text
        lab_request.status = 'completed'
        lab_request.performed_by = current_user.id
        lab_request.performed_at = get_eat_now()
        # Preserve existing notes; allow labtech notes override if provided
        notes = (request.form.get('notes') or '').strip() or None
        if notes is not None:
            lab_request.notes = notes

        db.session.commit()

        # Notify the requesting doctor (best-effort)
        try:
            requester = db.session.get(User, lab_request.requested_by)
            if requester:
                title = 'Lab result ready'
                test_name = lab_request.test.name if lab_request.test else 'Lab Test'
                patient_name = patient.decrypted_name if patient else 'Patient'
                message = f"{test_name} result ready for {patient_name}."
                db.session.add(Notification(
                    user_id=requester.id,
                    title=title,
                    message=message,
                    is_read=False,
                    created_at=get_eat_now(),
                ))
                db.session.commit()
        except Exception:
            db.session.rollback()

        flash('Lab result saved and request marked completed.', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f'Error saving lab result: {str(e)}', 'danger')

    return redirect(url_for('labtech_lab_request_detail', request_id=request_id))


@app.route('/nurse/medication-schedule')
@login_required
def nurse_medication_schedule():
    """View medication schedule (placeholder for future integration)."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role != 'nurse':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Get all inpatients with their latest medication administrations
    patients = Patient.query.filter_by(patient_type='inpatient', status='active').all()
    
    medications = []
    now = get_eat_now()
    
    # This is a simplified version - in production, you'd have a proper scheduling system
    for patient in patients:
        # Get recent medications that might need to be repeated
        recent_meds = (
            MedicationAdministration.query
            .filter_by(patient_id=patient.id)
            .filter(MedicationAdministration.status == 'administered')
            .order_by(MedicationAdministration.administered_at.desc())
            .limit(5)
            .all()
        )
        
        for med in recent_meds:
            # Create a mock schedule entry
            med.patient = patient
            med.time_status = 'upcoming'  # Could be 'due', 'overdue', or 'upcoming'
            medications.append(med)
    
    # Get all wards for filtering
    wards = Ward.query.order_by(Ward.name).all()
    
    return render_template(
        'nurse/medication_schedule.html',
        medications=medications,
        wards=wards
    )

    
# Receptionist Routes
@app.route('/receptionist')
@login_required
def receptionist_dashboard():
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    # Calculate today's patients
    today_patients = db.session.query(Patient).join(Sale).filter(
        func.date(Sale.created_at) == date.today()
    ).distinct().count()
    
    # Calculate active patients
    active_patients = Patient.query.filter_by(status='active').count()
    
    # Calculate today's sales
    today_sales = db.session.query(func.sum(Sale.total_amount)).filter(
        func.date(Sale.created_at) == date.today()
    ).scalar() or 0
    
    # Calculate outstanding bills (from Debtor model)
    outstanding_bills = db.session.query(func.sum(Debtor.amount_owed)).scalar() or 0
    
    # Get today's appointments (placeholder - you'll need to implement this)
    today_appointments = Appointment.query.filter(
        Appointment.date == date.today()
    ).count()

    pending_appointments = Appointment.query.filter(
        Appointment.status == 'scheduled'
    ).count()

    appointments = Appointment.query.filter(
        Appointment.date == date.today()
    ).order_by(Appointment.time).all()
        
    return render_template('receptionist/dashboard.html',
        today_patients=today_patients,
        active_patients=active_patients,
        today_sales=today_sales,
        outstanding_bills=outstanding_bills,
        today_appointments=today_appointments,
        pending_appointments=pending_appointments,
        appointments=appointments
    )


@app.route('/receptionist/patients')
@login_required
def receptionist_patients():
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patients = Patient.query.order_by(Patient.created_at.desc()).all()
    return render_template('receptionist/patients.html', patients=patients)

@app.route('/receptionist/patient/<int:patient_id>')
@login_required
def receptionist_patient_details(patient_id):
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('receptionist_patients'))
    
    services = Service.query.all()
    lab_tests = LabTest.query.all()
    patient_labs = patient.labs
    # Optimize prescriptions query with eager loading to prevent N+1 queries
    prescriptions = Prescription.query.filter_by(patient_id=patient.id) \
        .options(
            db.joinedload(Prescription.items).joinedload(PrescriptionItem.drug)
        ).all()
    
    # Calculate totals with defensive checks to prevent crashes on missing relationships
    lab_total = sum(
        lab.test.price 
        for lab in patient_labs 
        if lab.test and lab.test.price is not None
    )
    service_total = 0  # Will be calculated from selected services
    prescription_total = sum(
        item.drug.selling_price * item.quantity 
        for prescription in prescriptions 
        for item in prescription.items 
        if item.status == 'dispensed' and item.drug and item.drug.selling_price is not None
    )
    
    return render_template('receptionist/patient_details.html',
        patient=patient,
        services=services,
        lab_tests=lab_tests,
        patient_labs=patient_labs,
        prescriptions=prescriptions,
        lab_total=lab_total,
        service_total=service_total,
        prescription_total=prescription_total
    )

@app.route('/receptionist/patient/<int:patient_id>', methods=['POST'])
@login_required
def receptionist_patient_actions(patient_id):
    """Handle patient actions (complete treatment, readmit) from receptionist view"""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patient = _db_get(Patient, patient_id)
    if not patient:
        flash('Patient not found', 'danger')
        return redirect(url_for('receptionist_patients'))
    
    action = request.form.get('action')
    
    if action == 'complete_treatment':
        try:
            patient.status = 'completed'
            patient.updated_at = get_eat_now()
            db.session.commit()
            flash('Patient treatment marked as completed!', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error completing treatment: {str(e)}', 'danger')
    
    elif action == 'readmit_patient':
        try:
            patient.status = 'active'
            patient.updated_at = get_eat_now()
            db.session.commit()
            flash('Patient readmitted successfully!', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error readmitting patient: {str(e)}', 'danger')
    
    return redirect(url_for('receptionist_patient_details', patient_id=patient_id))

@app.route('/receptionist/billing', methods=['POST'])
@login_required
def create_bill():
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    # Receptionist (and admin) handles billing; pharmacists only dispense.
    if user_role not in ('receptionist', 'admin'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    def _coerce_int_list(values):
        out = []
        for v in values or []:
            try:
                out.append(int(v))
            except (TypeError, ValueError):
                continue
        return out

    data = request.get_json(silent=True) if request.is_json else None
    if isinstance(data, dict):
        patient_id = data.get('patient_id')
        service_ids = _coerce_int_list(data.get('services', []))
        lab_ids = _coerce_int_list(data.get('labs', []))
        imaging_ids = _coerce_int_list(data.get('imaging_tests', []))
        prescription_item_ids = _coerce_int_list(data.get('prescription_items', []))
        controlled_prescription_item_ids = _coerce_int_list(data.get('controlled_prescription_items', []))
        include_ward_stay = bool(data.get('include_ward_stay'))
        payment_method = data.get('payment_method', 'cash')
        amount_given = data.get('amount_given', None)  # Amount client gave (for cash payments)
        notes = data.get('notes')
        insurance_policy_number = str(data.get('insurance_policy_number') or '').strip()
        card_reference = str(data.get('card_reference') or '').strip()
        paypal_reference = str(data.get('paypal_reference') or '').strip()
    else:
        patient_id = request.form.get('patient_id')
        service_ids = _coerce_int_list(request.form.getlist('services'))
        lab_ids = _coerce_int_list(request.form.getlist('lab_tests'))
        imaging_ids = _coerce_int_list(request.form.getlist('imaging_tests'))
        prescription_item_ids = _coerce_int_list(request.form.getlist('prescription_items'))
        controlled_prescription_item_ids = _coerce_int_list(request.form.getlist('controlled_prescription_items'))
        include_ward_stay = request.form.get('include_ward_stay') in ('1', 'true', 'True', 'on', 'yes')
        payment_method = request.form.get('payment_method', 'cash')
        amount_given_str = request.form.get('amount_given', None)
        amount_given = float(amount_given_str) if amount_given_str else None
        notes = request.form.get('notes')
        insurance_policy_number = (request.form.get('insurance_policy_number') or '').strip()
        card_reference = (request.form.get('card_reference') or '').strip()
        paypal_reference = (request.form.get('paypal_reference') or '').strip()
    
    try:
        patient_id_int = int(patient_id)
    except (TypeError, ValueError):
        patient_id_int = None

    patient = db.session.get(Patient, patient_id_int) if patient_id_int is not None else None
    if not patient:
        if request.is_json:
            return jsonify({'error': 'Patient not found'}), 404
        flash('Patient not found', 'danger')
        return redirect(url_for('receptionist_billing'))
    
    # Enforce insurance verification (server-side)
    if str(payment_method or '').strip().lower() == 'insurance':
        try:
            policy = (
                InsurancePolicy.query
                .filter_by(patient_id=patient.id, active=True)
                .order_by(InsurancePolicy.created_at.desc())
                .first()
            )
        except Exception:
            policy = None

        if not policy:
            msg = 'No active insurance policy for this patient. Please verify insurance or use another payment method.'
            if request.is_json:
                return jsonify({'error': msg}), 400
            flash(msg, 'danger')
            return redirect(url_for('receptionist_billing'))

        try:
            meta = _insurance_policy_meta(policy)
            if (meta.get('verification_status') or '').strip().lower() != 'verified':
                msg = 'Insurance is not verified. Please verify the patient insurance before billing with Insurance.'
                if request.is_json:
                    return jsonify({'error': msg}), 400
                flash(msg, 'danger')
                return redirect(url_for('receptionist_billing'))
        except Exception:
            msg = 'Insurance verification status unavailable. Please verify the patient insurance before billing with Insurance.'
            if request.is_json:
                return jsonify({'error': msg}), 400
            flash(msg, 'danger')
            return redirect(url_for('receptionist_billing'))

    try:
        # Compose a safe note string (stored in Sale.notes and Transaction.notes)
        note_parts = []
        if notes:
            note_parts.append(str(notes).strip())
        if payment_method == 'insurance' and insurance_policy_number:
            note_parts.append(f"Insurance policy: {insurance_policy_number}")
        if payment_method == 'card' and card_reference:
            note_parts.append(f"Card ref: {card_reference}")
        if payment_method == 'paypal' and paypal_reference:
            note_parts.append(f"PayPal ref: {paypal_reference}")
        combined_notes = ' | '.join([p for p in note_parts if p]) or None

        # Create sale
        sale = Sale(
            sale_number=generate_sale_number(),
            patient_id=patient.id,
            user_id=current_user.id,
            total_amount=0,  # Will be calculated
            payment_method=payment_method,
            status='completed',
            notes=combined_notes,
        )
        db.session.add(sale)
        db.session.flush()  # To get the sale ID
        
        total_amount = 0

        billed_service_ids: list[int] = []

        def _lab_key(test_id: int) -> str:
            return f"LABTEST-{int(test_id)}"

        def _img_key(test_id: int) -> str:
            return f"IMGTEST-{int(test_id)}"
        
        # Add services
        for service_id in service_ids:
            service = db.session.get(Service, service_id)
            if service:
                sale_item = SaleItem(
                    sale_id=sale.id,
                    service_id=service.id,
                    description=service.name,
                    quantity=1,
                    unit_price=service.price,
                    total_price=service.price
                )
                db.session.add(sale_item)
                total_amount += service.price
                billed_service_ids.append(int(service.id))

        # Best-effort: link billed service items back to requested PatientService rows.
        # Never break billing if this fails.
        try:
            if billed_service_ids:
                now = get_eat_now()
                pending_requests = (
                    PatientService.query
                    .filter(PatientService.patient_id == patient.id)
                    .filter(PatientService.service_id.in_(billed_service_ids))
                    .filter(
                        or_(
                            PatientService.status.is_(None),
                            PatientService.status == 'requested',
                            PatientService.status == 'completed',
                            PatientService.status == 'done',
                        )
                    )
                    .filter(PatientService.billed_sale_id.is_(None))
                    .order_by(PatientService.created_at.asc())
                    .all()
                )

                # Only mark one PatientService row per billed service checkbox.
                req_by_service: dict[int, list[PatientService]] = {}
                for req in pending_requests:
                    try:
                        sid = int(getattr(req, 'service_id', None) or 0)
                    except Exception:
                        sid = 0
                    if not sid:
                        continue
                    req_by_service.setdefault(sid, []).append(req)

                for sid in billed_service_ids:
                    rows = req_by_service.get(int(sid)) or []
                    if not rows:
                        continue
                    req = rows.pop(0)
                    req.status = 'billed'
                    req.billed_sale_id = sale.id
                    req.billed_by = current_user.id
                    req.billed_at = now
        except Exception:
            pass
        
        # Add lab tests
        try:
            lab_keys = [_lab_key(lid) for lid in (lab_ids or [])]
            already_billed_lab_keys: set[str] = set()
            if lab_keys:
                rows = (
                    db.session.query(SaleItem.individual_sale_number)
                    .join(Sale, SaleItem.sale_id == Sale.id)
                    .filter(Sale.patient_id == patient.id)
                    .filter(SaleItem.individual_sale_number.in_(lab_keys))
                    .all()
                )
                already_billed_lab_keys = {r[0] for r in rows if r and r[0]}
        except Exception:
            already_billed_lab_keys = set()

        for lab_id in lab_ids:
            lab = db.session.get(LabTest, lab_id)
            if not lab:
                continue
            try:
                lab_key = _lab_key(lab.id)
            except Exception:
                lab_key = None
            if lab_key and lab_key in already_billed_lab_keys:
                continue
            sale_item = SaleItem(
                sale_id=sale.id,
                lab_test_id=lab.id,
                description=lab.name,
                individual_sale_number=lab_key,
                quantity=1,
                unit_price=lab.price,
                total_price=lab.price
            )
            db.session.add(sale_item)
            total_amount += lab.price

        # Add imaging tests (stored as description-only items to avoid schema changes)
        try:
            img_keys = [_img_key(iid) for iid in (imaging_ids or [])]
            already_billed_img_keys: set[str] = set()
            if img_keys:
                rows = (
                    db.session.query(SaleItem.individual_sale_number)
                    .join(Sale, SaleItem.sale_id == Sale.id)
                    .filter(Sale.patient_id == patient.id)
                    .filter(SaleItem.individual_sale_number.in_(img_keys))
                    .all()
                )
                already_billed_img_keys = {r[0] for r in rows if r and r[0]}
        except Exception:
            already_billed_img_keys = set()

        for imaging_id in imaging_ids:
            imaging_test = db.session.get(ImagingTest, imaging_id)
            if not imaging_test or not imaging_test.is_active:
                continue
            try:
                img_key = _img_key(imaging_test.id)
            except Exception:
                img_key = None
            if img_key and img_key in already_billed_img_keys:
                continue
            kwargs = {
                'sale_id': sale.id,
                'description': f"Imaging: {imaging_test.name}",
                'individual_sale_number': img_key,
                'quantity': 1,
                'unit_price': imaging_test.price,
                'total_price': imaging_test.price,
            }
            if _sale_item_supports_imaging_test_id():
                kwargs['imaging_test_id'] = imaging_test.id
            sale_item = SaleItem(**kwargs)
            db.session.add(sale_item)
            total_amount += imaging_test.price

        # Add ward stay (auto-updating daily based on assignment and last billed period)
        if include_ward_stay:
            try:
                ctx = _get_patient_bed_stay_context(patient.id)
                if ctx:
                    bed_id = ctx['bed_id']
                    start_date = ctx['start_date']
                    end_date = ctx['end_date']
                    daily_rate = float(ctx.get('daily_rate') or 0)

                    last = (
                        BedStayCharge.query
                        .filter_by(bed_id=bed_id, patient_id=patient.id)
                        .order_by(BedStayCharge.charge_end_date.desc())
                        .first()
                    )
                    if last and getattr(last, 'charge_end_date', None):
                        start_date = max(start_date, last.charge_end_date + timedelta(days=1))

                    if start_date <= end_date:
                        days = (end_date - start_date).days + 1
                    else:
                        days = 0

                    if days > 0 and daily_rate > 0:
                        amount = float(days) * daily_rate
                        desc = f"Ward stay: {ctx['ward_name']} - Bed {ctx['bed_number']} ({start_date.isoformat()} to {end_date.isoformat()})"
                        sale_item = SaleItem(
                            sale_id=sale.id,
                            description=desc,
                            quantity=int(days),
                            unit_price=daily_rate,
                            total_price=amount,
                        )
                        db.session.add(sale_item)
                        total_amount += amount

                        charge_row = BedStayCharge(
                            bed_id=bed_id,
                            patient_id=patient.id,
                            charge_start_date=start_date,
                            charge_end_date=end_date,
                            days=int(days),
                            daily_rate=daily_rate,
                            amount=amount,
                            sale_id=sale.id,
                        )
                        db.session.add(charge_row)
            except Exception:
                # Ward stay is optional; do not break core billing flow.
                pass
        
        # Add dispensed prescriptions (incremental: avoid re-billing the same PrescriptionItem)
        def _rx_key(item_id: int) -> str:
            return f"RXITEM-{int(item_id)}"

        def _crx_key(item_id: int) -> str:
            return f"CRXITEM-{int(item_id)}"

        if prescription_item_ids:
            selected_items = (
                db.session.query(PrescriptionItem)
                .join(Prescription, PrescriptionItem.prescription_id == Prescription.id)
                .filter(Prescription.patient_id == patient.id)
                .filter(PrescriptionItem.id.in_(prescription_item_ids))
                .all()
            )
        else:
            selected_items = []

        # Preload already-billed RX item keys for this patient.
        try:
            keys_to_check: list[str] = []
            if selected_items:
                keys_to_check = [_rx_key(i.id) for i in selected_items if getattr(i, 'id', None)]
            else:
                # We'll compute keys later for the fallback path.
                keys_to_check = []

            already_billed_rx_keys: set[str] = set()
            if keys_to_check:
                rows = (
                    db.session.query(SaleItem.individual_sale_number)
                    .join(Sale, SaleItem.sale_id == Sale.id)
                    .filter(Sale.patient_id == patient.id)
                    .filter(SaleItem.individual_sale_number.in_(keys_to_check))
                    .all()
                )
                already_billed_rx_keys = {r[0] for r in rows if r and r[0]}
        except Exception:
            already_billed_rx_keys = set()

        if selected_items:
            for item in selected_items:
                if item.status == 'dispensed' and item.drug:
                    try:
                        rx_key = _rx_key(item.id)
                    except Exception:
                        rx_key = None
                    if rx_key and rx_key in already_billed_rx_keys:
                        continue
                    unit_price = float(getattr(item.drug, 'selling_price', 0) or 0)
                    qty = int(getattr(item, 'quantity', 0) or 0)
                    line_total = unit_price * qty
                    sale_item = SaleItem(
                        sale_id=sale.id,
                        drug_id=item.drug.id,
                        description=f"{item.drug.name} - {item.dosage}",
                        individual_sale_number=rx_key,
                        quantity=qty,
                        unit_price=unit_price,
                        total_price=line_total
                    )
                    db.session.add(sale_item)
                    total_amount += line_total
        else:
            prescriptions = Prescription.query.filter_by(patient_id=patient.id, status='dispensed').all()
            for prescription in prescriptions:
                for item in prescription.items:
                    if item.status == 'dispensed' and item.drug:
                        try:
                            rx_key = _rx_key(item.id)
                        except Exception:
                            rx_key = None
                        if rx_key:
                            # Check if already billed (query per-item; still safe for typical volumes)
                            try:
                                exists = (
                                    db.session.query(SaleItem.id)
                                    .join(Sale, SaleItem.sale_id == Sale.id)
                                    .filter(Sale.patient_id == patient.id)
                                    .filter(SaleItem.individual_sale_number == rx_key)
                                    .first()
                                )
                                if exists:
                                    continue
                            except Exception:
                                pass
                        unit_price = float(getattr(item.drug, 'selling_price', 0) or 0)
                        qty = int(getattr(item, 'quantity', 0) or 0)
                        line_total = unit_price * qty
                        sale_item = SaleItem(
                            sale_id=sale.id,
                            drug_id=item.drug.id,
                            description=f"{item.drug.name} - {item.dosage}",
                            individual_sale_number=rx_key,
                            quantity=qty,
                            unit_price=unit_price,
                            total_price=line_total
                        )
                        db.session.add(sale_item)
                        total_amount += line_total

        # Add dispensed controlled prescriptions (incremental: avoid re-billing the same ControlledPrescriptionItem)
        # Note: SaleItem has no controlled_drug_id column; we bill as a description-only item.
        if controlled_prescription_item_ids:
            selected_citems = (
                db.session.query(ControlledPrescriptionItem)
                .join(ControlledPrescription, ControlledPrescriptionItem.controlled_prescription_id == ControlledPrescription.id)
                .filter(ControlledPrescription.patient_id == patient.id)
                .filter(ControlledPrescriptionItem.id.in_(controlled_prescription_item_ids))
                .all()
            )
        else:
            selected_citems = []

        def _add_controlled_item(ci: 'ControlledPrescriptionItem'):
            nonlocal total_amount
            if getattr(ci, 'status', None) != 'dispensed':
                return
            drug = getattr(ci, 'controlled_drug', None)
            if not drug:
                return
            try:
                key = _crx_key(ci.id)
            except Exception:
                key = None
            if key:
                try:
                    exists = (
                        db.session.query(SaleItem.id)
                        .join(Sale, SaleItem.sale_id == Sale.id)
                        .filter(Sale.patient_id == patient.id)
                        .filter(SaleItem.individual_sale_number == key)
                        .first()
                    )
                    if exists:
                        return
                except Exception:
                    pass

            unit_price = float(getattr(drug, 'selling_price', 0) or 0)
            qty = int(getattr(ci, 'quantity', 0) or 0)
            if qty <= 0 or unit_price <= 0:
                return
            sale_item = SaleItem(
                sale_id=sale.id,
                description=f"Controlled: {drug.name} - {getattr(ci, 'dosage', '') or ''}".strip(),
                individual_sale_number=key,
                quantity=qty,
                unit_price=unit_price,
                total_price=unit_price * qty,
            )
            db.session.add(sale_item)
            total_amount += unit_price * qty

        if selected_citems:
            for ci in selected_citems:
                _add_controlled_item(ci)
        else:
            cprescriptions = ControlledPrescription.query.filter_by(patient_id=patient.id, status='dispensed').all()
            for cp in cprescriptions:
                for ci in (cp.items or []):
                    _add_controlled_item(ci)
        
        # Update sale total
        sale.total_amount = total_amount
        
        # Calculate change (for cash payments)
        change = 0
        if payment_method == 'cash' and amount_given is not None:
            amount_given = float(amount_given)
            change = amount_given - total_amount
        
        # Create transaction
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='sale',
            amount=total_amount,
            user_id=current_user.id,
            reference_id=sale.id,
            notes=combined_notes,
        )
        _maybe_set_transaction_meta(
            transaction,
            reference_table='sales',
            direction='IN',
            status='posted',
            department='reception',
            category='patient_billing',
            payment_method=sale.payment_method,
        )
        db.session.add(transaction)

        receipt_html = render_template('receptionist/receipt.html', 
                                        sale=sale, 
                                        amount_given=amount_given,
                                        change=change)
        _ensure_transaction_receipt(transaction, receipt_html, prefix='SALE', force=True)
        
        db.session.commit()
        
        log_audit('create_bill', 'Sale', sale.id, None, {
            'patient_id': patient.id,
            'total_amount': total_amount
        })
        
        if request.is_json:
            return jsonify({
                'success': True,
                'sale_id': sale.id,
                'sale_number': sale.sale_number,
                'total_amount': total_amount,
                'receipt_url': url_for('receptionist_receipt', sale_id=sale.id),
                'pdf_url': url_for('api_sale_receipt_pdf', sale_id=sale.id),
            })
        # Pass amount_given and change as query parameters for the receipt
        receipt_url = url_for('receptionist_receipt', sale_id=sale.id)
        if payment_method == 'cash' and amount_given is not None:
            receipt_url += f'?amount_given={amount_given}&change={change}'
        return redirect(receipt_url)
    except Exception as e:
        db.session.rollback()
        if request.is_json:
            return jsonify({'error': str(e)}), 500
        flash(f'Error creating bill: {str(e)}', 'danger')
        return redirect(url_for('receptionist_billing'))

@app.route('/receptionist/sale/<int:sale_id>/receipt')
@login_required
def receptionist_receipt(sale_id):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'admin'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    tx = _get_transaction_for_sale(sale_id)
    reprint_requested = request.args.get('reprint') == '1'
    stored_invalid = False

    # Prefer the persisted snapshot so "View/Print" always opens the exact generated receipt.
    if tx and tx.receipt_html:
        stored_html = tx.receipt_html
        # Backward-compat: older sanitization escaped tags, causing receipts to display as text.
        if stored_html and ('&lt;' in stored_html or '&gt;' in stored_html):
            try:
                stored_html = _sanitize_receipt_html(html_lib.unescape(stored_html))
            except Exception:
                stored_html = tx.receipt_html

        # If the stored receipt was generated before items were flushed, it may have no rows.
        if stored_html and 'No items found for this sale.' in stored_html:
            stored_invalid = True
        else:
            if reprint_requested:
                try:
                    tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                    tx.receipt_reprinted_at = get_eat_now()
                    db.session.add(tx)
                    db.session.commit()
                except Exception:
                    db.session.rollback()
                return Response(_inject_reprint_banner(stored_html, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
            return Response(stored_html, mimetype='text/html')

    sale = db.session.query(Sale).options(
        db.joinedload(Sale.user),
        db.joinedload(Sale.items).joinedload(SaleItem.drug),
        db.joinedload(Sale.patient)
    ).where(Sale.id == sale_id).first()

    if not sale:
        flash('Sale not found', 'danger')
        return redirect(url_for('receptionist_dashboard'))

    # Get amount_given and change from query params (for old receipts without snapshots)
    amount_given = request.args.get('amount_given', type=float)
    change = request.args.get('change', type=float)

    rendered = render_template(
        'receptionist/receipt.html',
        sale=sale,
        amount_given=amount_given,
        change=change,
    )

    # Persist for future reprints if transaction exists
    try:
        if not tx:
            tx = _get_transaction_for_sale(sale_id)
        if tx:
            _ensure_transaction_receipt(tx, rendered, prefix='SALE', force=stored_invalid)
            if reprint_requested:
                tx.receipt_reprint_count = int(tx.receipt_reprint_count or 0) + 1
                tx.receipt_reprinted_at = get_eat_now()
                db.session.add(tx)
            db.session.commit()
    except Exception:
        db.session.rollback()

    if reprint_requested and tx:
        return Response(_inject_reprint_banner(tx.receipt_html or rendered, tx.receipt_reprinted_at, tx.receipt_reprint_count), mimetype='text/html')
    return Response(rendered, mimetype='text/html')

# API Routes
@app.route('/api/drugs')
@login_required
def api_drugs():
    # Get role as string for safe comparison (handles EncryptedType)
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    
    # Admin and pharmacist get full access to drugs
    if user_role in ('admin', 'pharmacist'):
        filter_type = request.args.get('filter', 'all')
        
        query = db.session.query(Drug)
        
        if filter_type == 'low_stock':
            query = query.filter(Drug.remaining_quantity < 5, Drug.remaining_quantity > 0)
        elif filter_type == 'expiring_soon':
            # Drugs expiring in the next 30 days
            thirty_days_later = date.today() + timedelta(days=30)
            query = query.filter(Drug.expiry_date <= thirty_days_later, Drug.expiry_date >= date.today())
        elif filter_type == 'out_of_stock':
            query = query.filter(Drug.remaining_quantity <= 0)
        elif filter_type == 'expired':
            # Only expired drugs
            today = datetime.now().date()
            query = query.filter(Drug.expiry_date < today)
        
        drugs = query.order_by(Drug.name).all()
        
        drugs_data = [{
            'id': drug.id,
            'drug_number': drug.drug_number,
            'name': drug.name,
            'specification': drug.specification,
            'buying_price': float(drug.buying_price),
            'selling_price': float(drug.selling_price),
            'stocked_quantity': drug.stocked_quantity,
            'sold_quantity': drug.sold_quantity,
            'remaining_quantity': drug.remaining_quantity,
            'expiry_date': drug.expiry_date.isoformat() if drug.expiry_date else None,
            'status': get_drug_status(drug)  # Helper function to determine status
        } for drug in drugs]
        
        return jsonify(drugs_data)
    else:
        # Other roles get limited drug details
        search = request.args.get('search', '')
        limit = request.args.get('limit', 10, type=int)
        
        query = Drug.query.filter(Drug.remaining_quantity > 0)
        if search:
            query = query.filter(Drug.name.ilike(f'%{search}%'))
        
        drugs = query.limit(limit).all()
        
        return jsonify([{
            'id': drug.id,
            'drug_number': drug.drug_number,
            'name': drug.name,
            'specification': drug.specification,
            'selling_price': float(drug.selling_price),
            'remaining_quantity': drug.remaining_quantity
        } for drug in drugs])

# Helper function to determine drug status
def get_drug_status(drug):
    remaining = drug.remaining_quantity
    expiry_date = drug.expiry_date
    today = datetime.now().date()
    
    if remaining <= 0:
        return 'Out of Stock'
    elif remaining < 5:
        return 'Low Stock'
    elif expiry_date and expiry_date < today:
        return 'Expired'
    elif expiry_date and (expiry_date - today).days < 30:
        return 'Expiring Soon'
    else:
        return 'In Stock'


def create_service_sale_and_transaction(patient_id, service_item, service_type, requested_by_id, notes=None):
    try:
        st = (service_type or '').strip().lower()
        if st in ('lab', 'labtest', 'laboratory'):
            st = 'lab_test'
        elif st in ('imaging', 'radiology'):
            st = 'imaging_test'
        elif st in ('service', 'services'):
            st = 'service'

        # Create Sale
        sale = Sale(
            sale_number=generate_sale_number(),
            patient_id=patient_id,
            user_id=requested_by_id,
            pharmacist_name=current_user.username if hasattr(current_user, 'username') else None,
            total_amount=service_item.price,
            payment_method='internal',
            status='completed',
            notes=notes or f"{st.replace('_', ' ').title()} service sale for patient {patient_id}"
        )
        db.session.add(sale)
        db.session.flush()  # To get sale.id

        # Create SaleItem
        sale_item = SaleItem(
            sale_id=sale.id,
            service_id=service_item.id if st == 'service' else None,
            lab_test_id=service_item.id if st == 'lab_test' else None,
            imaging_test_id=service_item.id if st == 'imaging_test' else None,
            description=f"{st.replace('_', ' ').title()} sale",
            quantity=1,
            unit_price=service_item.price,
            total_price=service_item.price
        )
        db.session.add(sale_item)

        # Create Transaction
        transaction = Transaction(
            transaction_number=generate_transaction_number(),
            transaction_type='sale',
            amount=service_item.price,
            user_id=requested_by_id,
            reference_id=sale.id,
            reference_table='sales',
            direction='IN',
            status='posted',
            department=st,
            category='service',
            payer=f"Patient {patient_id}",
            notes=f"{st.replace('_', ' ').title()} sale for patient {patient_id}"
        )

        db.session.add(transaction)
        db.session.commit()

        # Log audit event for service sale
        log_audit_event(
            action=f'create_{service_type}_sale',
            table_name='sales',
            record_id=sale.id,
            description=f"Created {service_type} sale {sale.sale_number} for patient {patient_id}",
            new_values={
                'sale_id': sale.id,
                'patient_id': patient_id,
                'service_item_id': service_item.id,
                'service_type': service_type,
                'amount': sale.total_amount
            }
        )

    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to create service sale and transaction: {e}", exc_info=True)
        # Do not re-raise, allow the calling function to handle the error display


def _create_service_sale_and_transaction(service_item, service_type, patient):
    """
    Creates a Sale, SaleItem, and Transaction for a given service (LabTest or ImagingTest).
    `service_item` is the actual LabTest or ImagingTest object.
    `service_type` is a string 'lab' or 'imaging'.
    """
    if not service_item or not hasattr(service_item, 'price') or service_item.price is None:
        current_app.logger.error(f"Service item for sale has no price: {service_item}")
        raise ValueError('Service item has no price')

    if not patient or not getattr(patient, 'id', None):
        raise ValueError('Patient is required')

    # Reuse the newer unified helper.
    mapped = (service_type or '').strip().lower()
    if mapped == 'lab':
        mapped = 'lab_test'
    elif mapped == 'imaging':
        mapped = 'imaging_test'
    else:
        mapped = 'service'

    create_service_sale_and_transaction(
        patient_id=int(patient.id),
        service_item=service_item,
        service_type=mapped,
        requested_by_id=current_user.id if current_user and current_user.is_authenticated else None,
        notes=f"Internal charge for {mapped} '{getattr(service_item, 'name', '')}'",
    )

    return True



def _check_drug_stock_status(drug):
    # Check the stock status of a drug
    remaining = drug.remaining_quantity if hasattr(drug, 'remaining_quantity') else 0
    expiry_date = drug.expiry_date if hasattr(drug, 'expiry_date') else None
    today = datetime.now().date()
    
    if remaining <= 0:
        return 'Out of Stock'
    elif remaining < 5:
        return 'Low Stock'
    elif expiry_date and expiry_date < today:
        return 'Expired'
    elif expiry_date and (expiry_date - today).days < 30:
        return 'Expiring Soon'
    else:
        return 'In Stock'

# Add this function to generate drug numbers automatically
def generate_drug_number():
    last_drug = Drug.query.order_by(Drug.id.desc()).first()
    if last_drug:
        last_number = int(last_drug.drug_number.split('-')[-1]) if '-' in last_drug.drug_number else 0
        new_number = last_number + 1
    else:
        new_number = 1
    return f"DRG-{new_number:04d}"


def generate_controlled_drug_number():
    last_drug = ControlledDrug.query.order_by(ControlledDrug.id.desc()).first()
    if last_drug and last_drug.controlled_drug_number and '-' in last_drug.controlled_drug_number:
        try:
            last_number = int(last_drug.controlled_drug_number.split('-')[-1])
        except Exception:
            last_number = 0
    else:
        last_number = 0
    new_number = last_number + 1
    return f"CDR-{new_number:04d}"


def _patient_has_paid_sale_for_item(*, patient_id, lab_test_id=None, service_id=None) -> bool:
    """Return True if patient has a completed sale + posted sale transaction for the given item."""

    if not patient_id:
        return False
    if lab_test_id is None and service_id is None:
        return False

    item_filters = []
    if lab_test_id is not None:
        item_filters.append(SaleItem.lab_test_id == int(lab_test_id))
    if service_id is not None:
        item_filters.append(SaleItem.service_id == int(service_id))

    sale_ids_subq = (
        db.session.query(Sale.id)
        .join(SaleItem, SaleItem.sale_id == Sale.id)
        .filter(Sale.patient_id == int(patient_id))
        .filter(Sale.status == 'completed')
        .filter(or_(*item_filters))
        .distinct()
        .subquery()
    )

    # Require an actual ledger post for the sale (golden rule: money event posts into Transaction)
    paid_txn_exists = (
        db.session.query(Transaction.id)
        .filter(Transaction.transaction_type == 'sale')
        .filter(Transaction.reference_id.in_(db.select(sale_ids_subq.c.id)))
        .limit(1)
        .scalar()
        is not None
    )
    return bool(paid_txn_exists)


def _patient_has_paid_sale_for_imaging_test(*, patient_id, imaging_test) -> bool:
    """Best-effort check for imaging billing.

    Prefer imaging_test_id linkage when available; otherwise match by description.
    """

    if not patient_id or not imaging_test or not imaging_test.name:
        return False

    name = (imaging_test.name or '').strip()
    if not name:
        return False

    if _sale_item_supports_imaging_test_id():
        sale_ids_subq = (
            db.session.query(Sale.id)
            .join(SaleItem, SaleItem.sale_id == Sale.id)
            .filter(Sale.patient_id == int(patient_id))
            .filter(Sale.status == 'completed')
            .filter(SaleItem.imaging_test_id == int(imaging_test.id))
            .distinct()
            .subquery()
        )
    else:
        sale_ids_subq = (
            db.session.query(Sale.id)
            .join(SaleItem, SaleItem.sale_id == Sale.id)
            .filter(Sale.patient_id == int(patient_id))
            .filter(Sale.status == 'completed')
            .filter(SaleItem.description.ilike('%imaging%'))
            .filter(SaleItem.description.ilike(f'%{name}%'))
            .distinct()
            .subquery()
        )

    paid_txn_exists = (
        db.session.query(Transaction.id)
        .filter(Transaction.transaction_type == 'sale')
        .filter(Transaction.reference_id.in_(db.select(sale_ids_subq.c.id)))
        .limit(1)
        .scalar()
        is not None
    )
    return bool(paid_txn_exists)


def generate_controlled_sale_number():
    return f"CSALE-{datetime.now().strftime('%Y%m%d%H%M%S')}-{random.randint(100, 999)}"


def _allowed_prescription_file(filename: str) -> bool:
    if not filename:
        return False
    ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
    return ext in {'jpg', 'jpeg', 'png', 'webp', 'pdf'}


def _allowed_prescription_image(filename: str) -> bool:
    if not filename:
        return False
    ext = filename.rsplit('.', 1)[-1].lower() if '.' in filename else ''
    return ext in {'jpg', 'jpeg', 'png', 'webp'}


def _save_prescription_image(file_storage):
    """Save camera-captured prescription photo to uploads/controlled_prescriptions and return relative path."""
    if not file_storage or not getattr(file_storage, 'filename', None):
        return None

    # Enforce image-only (no PDF uploads)
    if not _allowed_prescription_image(file_storage.filename):
        raise ValueError('Unsupported file type. Prescription must be an image (jpg, png, webp).')

    # Enforce image mimetype when available
    mimetype = (getattr(file_storage, 'mimetype', '') or '').lower()
    if mimetype and not mimetype.startswith('image/'):
        raise ValueError('Unsupported file type. Prescription must be an image.')

    filename = secure_filename(file_storage.filename) or 'prescription.jpg'
    stamp = datetime.now().strftime('%Y%m%d%H%M%S')
    unique = f"{stamp}_{random.randint(1000, 9999)}_{filename}"

    upload_dir = os.path.join(app.root_path, 'uploads', 'controlled_prescriptions')
    os.makedirs(upload_dir, exist_ok=True)
    full_path = os.path.join(upload_dir, unique)
    file_storage.save(full_path)
    return os.path.join('uploads', 'controlled_prescriptions', unique).replace('\\', '/')





def _save_prescription_sheet(file_storage):
    """Save uploaded prescription sheet to uploads/controlled_prescriptions and return relative path."""
    if not file_storage or not getattr(file_storage, 'filename', None):
        return None
    if not _allowed_prescription_file(file_storage.filename):
        raise ValueError('Unsupported file type. Use jpg, png, webp, or pdf.')

    filename = secure_filename(file_storage.filename)
    stamp = datetime.now().strftime('%Y%m%d%H%M%S')
    unique = f"{stamp}_{random.randint(1000, 9999)}_{filename}"

    upload_dir = os.path.join(app.root_path, 'uploads', 'controlled_prescriptions')
    os.makedirs(upload_dir, exist_ok=True)

    full_path = os.path.join(upload_dir, unique)
    file_storage.save(full_path)
    return os.path.join('uploads', 'controlled_prescriptions', unique).replace('\\', '/')


@app.route('/pharmacist/api/controlled-prescriptions/upload-sheet', methods=['POST'])
@login_required
def pharmacist_upload_controlled_prescription_sheet():
    """Upload a doctor prescription sheet image for a controlled prescription.

    Returns: {success: bool, path: 'uploads/...'}
    """
    if current_user.role != 'pharmacist':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    try:
        file_storage = request.files.get('prescription_image')
        if not file_storage or not getattr(file_storage, 'filename', None):
            return jsonify({'success': False, 'error': 'No file uploaded'}), 400

        # For receipts we currently render an <img>, so keep this image-only.
        path = _save_prescription_image(file_storage)
        if not path:
            return jsonify({'success': False, 'error': 'Failed to save file'}), 400

        return jsonify({'success': True, 'path': path})
    except ValueError as ve:
        return jsonify({'success': False, 'error': str(ve)}), 400
    except Exception as e:
        current_app.logger.error(f"Error uploading prescription sheet: {str(e)}", exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to upload prescription sheet'}), 500

@app.route('/api/drugs/<int:drug_id>')
@login_required
def api_single_drug(drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    drug = _db_get_or_404(Drug, drug_id)
    return jsonify({
        'id': drug.id,
        'drug_number': drug.drug_number,
        'name': drug.name,
        'specification': drug.specification,
        'buying_price': float(drug.buying_price),
        'selling_price': float(drug.selling_price),
        'stocked_quantity': drug.stocked_quantity,
        'expiry_date': drug.expiry_date.isoformat()
    })

@app.route('/api/drugs/stats')
@login_required
def api_drug_stats():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    total_value = db.session.query(func.sum(Drug.selling_price * (Drug.stocked_quantity - Drug.sold_quantity))).scalar() or 0
    low_stock = db.session.query(func.count(Drug.id)).filter(Drug.stocked_quantity - Drug.sold_quantity < 10).filter(Drug.stocked_quantity - Drug.sold_quantity > 0).scalar()
    expiring_soon = db.session.query(func.count(Drug.id)).filter(Drug.expiry_date <= date.today() + timedelta(days=30)).filter(Drug.expiry_date >= date.today()).scalar()
    out_of_stock = db.session.query(func.count(Drug.id)).filter(Drug.stocked_quantity - Drug.sold_quantity <= 0).scalar()
    
    return jsonify({
        'total_value': float(total_value),
        'low_stock': low_stock,
        'expiring_soon': expiring_soon,
        'out_of_stock': out_of_stock
    })


@app.route('/api/controlled-drugs')
@login_required
def api_controlled_drugs():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    filter_type = request.args.get('filter', 'all')
    query = db.session.query(ControlledDrug)
    
    if filter_type == 'low_stock':
        query = query.filter(ControlledDrug.remaining_quantity < 5, ControlledDrug.remaining_quantity > 0)
    elif filter_type == 'expiring_soon':
        thirty_days_later = date.today() + timedelta(days=30)
        query = query.filter(ControlledDrug.expiry_date <= thirty_days_later, ControlledDrug.expiry_date >= date.today())
    elif filter_type == 'out_of_stock':
        query = query.filter(ControlledDrug.remaining_quantity <= 0)
    elif filter_type == 'expired':
        today = datetime.now().date()
        query = query.filter(ControlledDrug.expiry_date < today)
    
    controlled_drugs = query.order_by(ControlledDrug.name).all()
    
    drugs_data = [{
        'id': drug.id,
        'controlled_drug_number': drug.controlled_drug_number,
        'name': drug.name,
        'specification': drug.specification,
        'buying_price': float(drug.buying_price),
        'selling_price': float(drug.selling_price),
        'stocked_quantity': drug.stocked_quantity,
        'sold_quantity': drug.sold_quantity,
        'remaining_quantity': drug.remaining_quantity,
        'expiry_date': drug.expiry_date.isoformat() if drug.expiry_date else None,
        'status': get_controlled_drug_status(drug)
    } for drug in controlled_drugs]
    
    return jsonify(drugs_data)


@app.route('/api/controlled-drugs/next-number', methods=['GET'])
@login_required
def api_controlled_drugs_next_number():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    return jsonify({'controlled_drug_number': generate_controlled_drug_number()})


@app.route('/api/controlled-drugs/<int:controlled_drug_id>')
@login_required
def api_single_controlled_drug(controlled_drug_id):
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    drug = _db_get_or_404(ControlledDrug, controlled_drug_id)
    return jsonify({
        'id': drug.id,
        'controlled_drug_number': drug.controlled_drug_number,
        'name': drug.name,
        'specification': drug.specification,
        'buying_price': float(drug.buying_price),
        'selling_price': float(drug.selling_price),
        'stocked_quantity': drug.stocked_quantity,
        'sold_quantity': drug.sold_quantity,
        'expiry_date': drug.expiry_date.isoformat() if drug.expiry_date else None,
        'remaining_quantity': drug.remaining_quantity,
        'is_expired': drug.expiry_date < datetime.now().date(),
        'expires_soon': drug.expiry_date <= (datetime.now().date() + timedelta(days=30)),
    })


@app.route('/api/controlled-drugs/stats')
@login_required
def api_controlled_drug_stats():
    if current_user.role != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403
    
    total_value = db.session.query(func.sum(ControlledDrug.selling_price * (ControlledDrug.stocked_quantity - ControlledDrug.sold_quantity))).scalar() or 0
    low_stock = db.session.query(func.count(ControlledDrug.id)).filter(ControlledDrug.stocked_quantity - ControlledDrug.sold_quantity < 10).filter(ControlledDrug.stocked_quantity - ControlledDrug.sold_quantity > 0).scalar()
    expiring_soon = db.session.query(func.count(ControlledDrug.id)).filter(ControlledDrug.expiry_date <= date.today() + timedelta(days=30)).filter(ControlledDrug.expiry_date >= date.today()).scalar()
    out_of_stock = db.session.query(func.count(ControlledDrug.id)).filter(ControlledDrug.stocked_quantity - ControlledDrug.sold_quantity <= 0).scalar()
    
    return jsonify({
        'total_value': float(total_value),
        'low_stock': low_stock,
        'expiring_soon': expiring_soon,
        'out_of_stock': out_of_stock
    })


def get_controlled_drug_status(drug):
    """Helper function to determine controlled drug status"""
    remaining = drug.remaining_quantity
    expiry_date = drug.expiry_date
    today = datetime.now().date()
    
    if remaining <= 0:
        return 'Out of Stock'
    elif remaining < 5:
        return 'Low Stock'
    elif expiry_date and expiry_date < today:
        return 'Expired'
    elif expiry_date and (expiry_date - today).days < 30:
        return 'Expiring Soon'
    else:
        return 'In Stock'


@app.route('/api/patients')
@login_required
def api_patients():
    search = request.args.get('search', '')
    limit = request.args.get('limit', 10, type=int)
    
    query = Patient.query
    if search:
        query = query.filter(
            (Patient.op_number.ilike(f'%{search}%')) |
            (Patient.ip_number.ilike(f'%{search}%')) |
            (Patient.name.ilike(f'%{search}%'))
        )
    
    patients = query.limit(limit).all()
    
    return jsonify([{
        'id': patient.id,
        'op_number': patient.op_number,
        'ip_number': patient.ip_number,
        'name': Config.decrypt_data_static(patient.name),
        'age': patient.age,
        'gender': patient.gender
    } for patient in patients])


@app.route('/api/patients/<int:patient_id>')
@login_required
def api_patient_details(patient_id: int):
    """Patient details endpoint used by billing/search UIs.

    Additive endpoint (was referenced by existing JS but missing in some builds).
    """
    patient = db.session.get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    # Best-effort decrypt name (handles mixed plaintext/encrypted data)
    try:
        name = patient.get_decrypted_name
    except Exception:
        try:
            name = Config.decrypt_data_static(patient.name)
        except Exception:
            name = str(patient.name or '')

    # Decrypt sensitive fields for display (never return ciphertext to receptionist UI).
    try:
        phone = str(getattr(patient, 'get_decrypted_phone', '') or '').strip()
    except Exception:
        try:
            phone = Config.decrypt_data_static(patient.phone)
        except Exception:
            phone = str(getattr(patient, 'phone', '') or '').strip()

    try:
        address = str(getattr(patient, 'get_decrypted_address', '') or '').strip()
    except Exception:
        try:
            address = Config.decrypt_data_static(patient.address)
        except Exception:
            address = str(getattr(patient, 'address', '') or '').strip()

    try:
        nok_name = str(getattr(patient, 'get_decrypted_nok_name', '') or '').strip()
    except Exception:
        try:
            nok_name = Config.decrypt_data_static(patient.nok_name)
        except Exception:
            nok_name = str(getattr(patient, 'nok_name', '') or '').strip()

    try:
        nok_contact = str(getattr(patient, 'get_decrypted_nok_contact', '') or '').strip()
    except Exception:
        try:
            nok_contact = Config.decrypt_data_static(patient.nok_contact)
        except Exception:
            nok_contact = str(getattr(patient, 'nok_contact', '') or '').strip()

    return jsonify({
        'id': patient.id,
        'op_number': patient.op_number,
        'ip_number': patient.ip_number,
        'name': name,
        'age': patient.age,
        'gender': patient.gender,
        'phone': phone,
        'address': address,
        'nok_name': nok_name,
        'nok_contact': nok_contact,
        'status': patient.status,
        'patient_type': 'inpatient' if (patient.ip_number and str(patient.ip_number).strip()) else 'outpatient',
    })


def _parse_money(val: str | None):
    if val is None:
        return None
    try:
        s = str(val).strip()
        if not s:
            return None
        s = s.replace(',', '')
        return float(s)
    except Exception:
        return None


def _extract_cash_from_receipt_html(html: str | None):
    """Best-effort extraction of cash fields from stored receipt HTML.

    Works across multiple receipt templates by scanning for 'Amount Given'
    and either 'Change' or 'Balance' values.
    """
    if not html:
        return (None, None)
    try:
        text = re.sub(r'<[^>]+>', ' ', str(html))
        text = re.sub(r'\s+', ' ', text)
    except Exception:
        text = str(html)

    amount_given = None
    change = None

    m = re.search(r'Amount\s*Given[^0-9]*([0-9][0-9,]*\.?[0-9]*)', text, flags=re.IGNORECASE)
    if m:
        amount_given = _parse_money(m.group(1))

    m = re.search(r'(Change|Balance\s*Due|Balance)[^0-9-]*(-?[0-9][0-9,]*\.?[0-9]*)', text, flags=re.IGNORECASE)
    if m:
        change = _parse_money(m.group(2))

    return (amount_given, change)


def _resolve_cash_meta(payment_method: str | None, total_amount: float, amount_given: float | None, change: float | None, receipt_html: str | None = None):
    pm = (payment_method or '').strip().lower()
    if pm != 'cash':
        return (None, None)

    if amount_given is None or change is None:
        a2, c2 = _extract_cash_from_receipt_html(receipt_html)
        if amount_given is None:
            amount_given = a2
        if change is None:
            change = c2

    if amount_given is not None and change is None:
        try:
            change = float(amount_given) - float(total_amount or 0)
        except Exception:
            change = None

    return (amount_given, change)


@app.route('/api/receptionist/bills')
@login_required
def api_receptionist_bills():
    """List recent bills for the receptionist billing history table."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'admin', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    limit = request.args.get('limit', 50, type=int)
    limit = max(1, min(int(limit or 50), 200))
    patient_type = (request.args.get('patient_type') or 'all').strip().lower()
    scope = (request.args.get('scope') or 'patient_bills').strip().lower()

    q = (
        db.session.query(Sale)
        .options(db.joinedload(Sale.patient), db.joinedload(Sale.user))
        .order_by(Sale.created_at.desc())
    )

    # Default behavior: only show bills created via the receptionist billing flow.
    # This prevents pharmacy drug sales (and other non-frontdesk sales) from appearing in
    # the Receptionist "Created Bills" table.
    if scope != 'all_sales':
        q = q.filter(Sale.patient_id.isnot(None))

        if _transaction_supports_metadata():
            tx_exists = (
                db.session.query(Transaction.id)
                .filter(Transaction.transaction_type == 'sale')
                .filter(Transaction.reference_id == Sale.id)
                # Legacy rows may not have reference_table set.
                .filter(db.or_(Transaction.reference_table.is_(None), Transaction.reference_table == 'sales'))
                .filter(Transaction.category == 'patient_billing')
                .filter(Transaction.department.in_(['reception', 'frontdesk']))
            )
            q = q.filter(tx_exists.exists())

    # Patient type filter uses presence of IP number (same semantics as existing UI)
    if patient_type == 'inpatient':
        q = q.join(Patient, Sale.patient_id == Patient.id).filter(Patient.ip_number.isnot(None)).filter(Patient.ip_number != '')
    elif patient_type == 'outpatient':
        q = q.join(Patient, Sale.patient_id == Patient.id).filter(or_(Patient.ip_number.is_(None), Patient.ip_number == ''))

    rows = q.limit(limit).all()

    out = []
    for sale in rows:
        patient = getattr(sale, 'patient', None)
        try:
            patient_name = patient.get_decrypted_name if patient else ''
        except Exception:
            patient_name = ''

        # Attach cash amount_given/change to URLs when we can infer from stored Transaction receipt HTML.
        tx_receipt_html = None
        try:
            tx = (
                db.session.query(Transaction)
                .filter(Transaction.transaction_type == 'sale')
                .filter(Transaction.reference_id == sale.id)
                .order_by(Transaction.id.desc())
                .first()
            )
            tx_receipt_html = getattr(tx, 'receipt_html', None) if tx else None
        except Exception:
            tx_receipt_html = None

        ag = None
        ch = None
        try:
            ag, ch = _resolve_cash_meta(getattr(sale, 'payment_method', None), float(sale.total_amount or 0), None, None, tx_receipt_html)
        except Exception:
            ag = ch = None

        receipt_url = url_for('receptionist_receipt', sale_id=sale.id)
        pdf_url = url_for('api_sale_receipt_pdf', sale_id=sale.id)
        if ag is not None:
            receipt_url = f"{receipt_url}?amount_given={ag:.2f}&change={(ch if ch is not None else (ag - float(sale.total_amount or 0))):.2f}"
            pdf_url = f"{pdf_url}?amount_given={ag:.2f}&change={(ch if ch is not None else (ag - float(sale.total_amount or 0))):.2f}"

        out.append({
            'sale_id': sale.id,
            'sale_number': sale.sale_number,
            'total_amount': float(sale.total_amount or 0),
            'payment_method': sale.payment_method,
            'created_at': sale.created_at.isoformat() if getattr(sale, 'created_at', None) else None,
            'served_by': getattr(getattr(sale, 'user', None), 'username', None),
            'patient': {
                'id': getattr(patient, 'id', None),
                'name': patient_name,
                'op_number': getattr(patient, 'op_number', None),
                'ip_number': getattr(patient, 'ip_number', None),
                'age': getattr(patient, 'age', None),
                'gender': getattr(patient, 'gender', None),
            },
            'receipt_url': receipt_url,
            'pdf_url': pdf_url,
        })

    return jsonify(out)


def _draw_rubber_stamp_pdf(c, page_w, y, facility_name='MAKOKHA MEDICAL CENTRE', phone1='0741 256 531', phone2='0713 580 997'):
    try:
        from utils.stamp_signature import get_stamp_typography
        typo = get_stamp_typography()
        stamp_color = typo.get('colors', {}).get('stamp', '#2e3192')
        date_color = typo.get('colors', {}).get('date', '#dc143c')
        pdf_style = typo.get('pdf', {})
        font_bold = pdf_style.get('font_bold', 'Helvetica-Bold')
        font_regular = pdf_style.get('font_regular', 'Helvetica')
        size_title = float(pdf_style.get('size_title', 7.0) or 7.0)
        size_date = float(pdf_style.get('size_date', 8.0) or 8.0)
        size_contact = float(pdf_style.get('size_contact', 6.5) or 6.5)
        line_width = float(pdf_style.get('line_width', 1.2) or 1.2)
    except Exception:
        stamp_color = '#2e3192'
        date_color = '#dc143c'
        font_bold = 'Helvetica-Bold'
        font_regular = 'Helvetica'
        size_title = 7.0
        size_date = 8.0
        size_contact = 6.5
        line_width = 1.2

    stamp_w = page_w - 10 * mm
    stamp_h = 22 * mm
    stamp_x = 5 * mm
    stamp_y = max(12 * mm, y - stamp_h)

    c.setStrokeColor(colors.HexColor(stamp_color))
    c.setLineWidth(line_width)
    c.rect(stamp_x, stamp_y, stamp_w, stamp_h, stroke=1, fill=0)

    c.setFillColor(colors.HexColor(stamp_color))
    c.setFont(font_bold, size_title)
    c.drawCentredString(page_w / 2, stamp_y + stamp_h - 6 * mm, facility_name)

    c.setFillColor(colors.HexColor(date_color))
    c.setFont(font_bold, size_date)
    c.drawCentredString(page_w / 2, stamp_y + stamp_h - 12 * mm, datetime.now().strftime('%d %b %Y').upper())

    c.setFillColor(colors.HexColor(stamp_color))
    c.setFont(font_regular, size_contact)
    c.drawCentredString(page_w / 2, stamp_y + 4 * mm, f'Tel: {phone1} / {phone2}')

    c.setFillColor(colors.black)
    return stamp_y


@app.route('/api/sales/<int:sale_id>/receipt.pdf')
@login_required
def api_sale_receipt_pdf(sale_id: int):
    """Generate a stamped/signed PDF receipt for a sale.

    This is used by the receptionist billing UI for Print/Share flows.
    """
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'admin', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    if not _REPORTLAB_AVAILABLE:
        return jsonify({'error': 'PDF generator not available (missing reportlab).'}), 501

    sale = (
        db.session.query(Sale)
        .options(
            db.joinedload(Sale.items),
            db.joinedload(Sale.patient),
            db.joinedload(Sale.user),
        )
        .filter(Sale.id == sale_id)
        .first()
    )
    if not sale:
        return jsonify({'error': 'Sale not found'}), 404

    # Non-admins can only generate PDFs for bills they created.
    if user_role != 'admin' and getattr(sale, 'user_id', None) != current_user.id:
        return jsonify({'error': 'Forbidden'}), 403

    patient = getattr(sale, 'patient', None)
    patient_name = ''
    if patient:
        try:
            patient_name = patient.get_decrypted_name
        except Exception:
            try:
                patient_name = Config.decrypt_data_static(patient.name)
            except Exception:
                patient_name = str(patient.name or '')

    served_by = getattr(getattr(sale, 'user', None), 'username', None) or 'Reception'
    created_at = getattr(sale, 'created_at', None)
    created_str = created_at.strftime('%Y-%m-%d %H:%M') if created_at else ''

    # Categorize items
    items = list(getattr(sale, 'items', None) or [])

    def _is_ward(desc: str) -> bool:
        return (desc or '').lower().startswith('ward stay:')

    def _is_imaging(item: 'SaleItem') -> bool:
        if getattr(item, 'imaging_test_id', None):
            return True
        return (getattr(item, 'description', '') or '').lower().startswith('imaging:')

    def _is_controlled(desc: str) -> bool:
        return (desc or '').lower().startswith('controlled:')

    services = [i for i in items if getattr(i, 'service_id', None)]
    labs = [i for i in items if getattr(i, 'lab_test_id', None)]
    imaging = [i for i in items if _is_imaging(i)]
    drugs = [i for i in items if getattr(i, 'drug_id', None) and not _is_controlled(getattr(i, 'description', ''))]
    controlled = [i for i in items if _is_controlled(getattr(i, 'description', ''))]
    ward = [i for i in items if _is_ward(getattr(i, 'description', ''))]

    # Signature: prefer an admin signature if available, else current user
    signature_data_uri = None
    try:
        admin_user = User.query.filter(func.lower(User.role) == 'admin').order_by(User.id.asc()).first()
    except Exception:
        admin_user = None

    try:
        if admin_user:
            sig = DrawnSignature.query.filter_by(user_id=admin_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
        if not signature_data_uri:
            sig = DrawnSignature.query.filter_by(user_id=current_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
    except Exception:
        signature_data_uri = None

    signature_bytes = None
    if signature_data_uri and isinstance(signature_data_uri, str) and 'base64,' in signature_data_uri:
        try:
            signature_bytes = base64.b64decode(signature_data_uri.split('base64,', 1)[1])
        except Exception:
            signature_bytes = None

    # Resolve optional cash metadata (from query params OR JSON body if called internally from WhatsApp share endpoint)
    amount_given = request.args.get('amount_given', type=float)
    change = request.args.get('change', type=float)
    if amount_given is None and request.is_json:
        try:
            data = request.get_json(silent=True) or {}
            if isinstance(data, dict):
                if data.get('amount_given') is not None:
                    amount_given = float(data.get('amount_given'))
                if data.get('change') is not None:
                    change = float(data.get('change'))
        except Exception:
            pass

    tx_receipt_html = None
    try:
        tx = (
            db.session.query(Transaction)
            .filter(Transaction.transaction_type == 'sale')
            .filter(Transaction.reference_id == sale.id)
            .order_by(Transaction.id.desc())
            .first()
        )
        tx_receipt_html = getattr(tx, 'receipt_html', None) if tx else None
    except Exception:
        tx_receipt_html = None

    try:
        amount_given, change = _resolve_cash_meta(getattr(sale, 'payment_method', None), float(sale.total_amount or 0), amount_given, change, tx_receipt_html)
    except Exception:
        pass

    def _generate_pdf_bytes() -> bytes:
        # Create PDF
        buf = BytesIO()
        page_w, page_h = (80 * mm, 260 * mm)
        c = rl_canvas.Canvas(buf, pagesize=(page_w, page_h))

        y = page_h - 10 * mm

        # Logo
        try:
            logo_path = os.path.join(app.root_path, 'static', 'images', 'logo.png')
            if os.path.exists(logo_path):
                c.drawImage(logo_path, (page_w - 18 * mm) / 2, y - 18 * mm, width=18 * mm, height=18 * mm, preserveAspectRatio=True, mask='auto')
                y -= 20 * mm
        except Exception:
            pass

        # Header
        c.setFont('Helvetica-Bold', 10)
        c.drawCentredString(page_w / 2, y, 'MAKOKHA MEDICAL CENTRE')
        y -= 5 * mm
        c.setFont('Helvetica', 7)
        c.drawCentredString(page_w / 2, y, 'OFFICIAL RECEIPT')
        y -= 4 * mm
        c.setStrokeColor(colors.black)
        c.setLineWidth(0.5)
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 4 * mm

        def _kv(label: str, value: str):
            nonlocal y
            c.setFont('Helvetica-Bold', 7)
            c.drawString(5 * mm, y, f'{label}:')
            c.setFont('Helvetica', 7)
            c.drawRightString(page_w - 5 * mm, y, (value or '')[:60])
            y -= 4 * mm

        _kv('Sale', sale.sale_number)
        _kv('Date', created_str)
        _kv('Served By', served_by)
        if patient:
            _kv('Patient', patient_name)
            age = str(getattr(patient, 'age', '') or '')
            gender = str(getattr(patient, 'gender', '') or '')
            _kv('Age/Sex', f'{age} / {gender}'.strip(' /'))
            if getattr(patient, 'ip_number', None):
                _kv('IP No', str(patient.ip_number))
            if getattr(patient, 'op_number', None):
                _kv('OP No', str(patient.op_number))

        y -= 1 * mm
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 4 * mm

        def _draw_section(title: str, rows: list['SaleItem']):
            nonlocal y
            if not rows:
                return

            c.setFont('Helvetica-Bold', 8)
            c.drawString(5 * mm, y, title)
            y -= 4 * mm

            c.setFont('Helvetica', 7)
            for it in rows:
                desc = (getattr(it, 'description', '') or '').strip()
                qty = int(getattr(it, 'quantity', 1) or 1)
                unit = float(getattr(it, 'unit_price', 0) or 0)
                total = float(getattr(it, 'total_price', 0) or (unit * qty))
                line = f"{desc}"[:44]
                c.drawString(5 * mm, y, line)
                y -= 3.5 * mm
                c.setFont('Helvetica', 6.5)
                c.drawString(7 * mm, y, f"{qty} x {unit:,.2f}")
                c.drawRightString(page_w - 5 * mm, y, f"{total:,.2f}")
                y -= 4 * mm
                c.setFont('Helvetica', 7)
                if y < 55 * mm:
                    c.showPage()
                    y = page_h - 10 * mm

            y -= 1 * mm

        _draw_section('Services Done', services)
        _draw_section('Lab (Completed)', labs)
        _draw_section('Imaging (Completed)', imaging)
        _draw_section('Dispensed Drugs', drugs)
        _draw_section('Controlled Drugs', controlled)
        _draw_section('Ward Stay', ward)

        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 5 * mm
        c.setFont('Helvetica-Bold', 9)
        c.drawString(5 * mm, y, 'TOTAL')
        c.drawRightString(page_w - 5 * mm, y, f"KSh {float(sale.total_amount or 0):,.2f}")
        y -= 5 * mm
        c.setFont('Helvetica-Bold', 7)
        c.drawString(5 * mm, y, 'PAYMENT SUMMARY')
        y -= 4 * mm
        c.setFont('Helvetica', 7)
        _kv('Method', str((sale.payment_method or '').upper()))
        _kv('Amount', f"KSh {float(sale.total_amount or 0):,.2f}")
        if (str(getattr(sale, 'payment_method', '') or '').lower().strip() == 'cash') and amount_given is not None:
            _kv('Amount Given', f"KSh {float(amount_given or 0):,.2f}")
            bal = change
            if bal is None:
                try:
                    bal = float(amount_given) - float(sale.total_amount or 0)
                except Exception:
                    bal = None
            if bal is not None:
                label = 'Balance' if float(bal) >= 0 else 'Balance Due'
                _kv(label, f"KSh {float(bal):,.2f}")
        y -= 2 * mm

        # Rubber-stamp
        stamp_y = _draw_rubber_stamp_pdf(c, page_w, y)
        y = stamp_y - 6 * mm

        # Signature
        if signature_bytes:
            try:
                img = ImageReader(BytesIO(signature_bytes))
                sig_w = 35 * mm
                sig_h = 14 * mm
                c.drawImage(img, 5 * mm, max(5 * mm, y - sig_h), width=sig_w, height=sig_h, preserveAspectRatio=True, mask='auto')
                c.setFont('Helvetica', 6.5)
                c.drawString(5 * mm, max(5 * mm, y - sig_h) - 3 * mm, 'Signed')
            except Exception:
                pass

        c.showPage()
        c.save()
        buf.seek(0)

        return buf.getvalue()

    pdf_bytes = _generate_pdf_bytes()
    filename = f"receipt-{sale.sale_number}.pdf"
    return Response(
        pdf_bytes,
        mimetype='application/pdf',
        headers={
            'Content-Disposition': f'attachment; filename={filename}'
        },
    )


@app.route('/api/sales/<int:sale_id>/share-whatsapp', methods=['POST'])
@login_required
def api_sale_share_whatsapp(sale_id: int):
    """Send a sale receipt PDF to a WhatsApp number via Meta Cloud API.

    If the request includes a manual destination number (JSON body {"to": "..."}),
    that number is used even for walk-in sales that have no linked patient.
    """
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'admin', 'pharmacist'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    if not _REPORTLAB_AVAILABLE:
        return jsonify({'success': False, 'error': 'PDF generator not available (missing reportlab).'}), 501

    sale = (
        db.session.query(Sale)
        .options(
            db.joinedload(Sale.items),
            db.joinedload(Sale.patient),
            db.joinedload(Sale.user),
        )
        .filter(Sale.id == sale_id)
        .first()
    )
    if not sale:
        return jsonify({'success': False, 'error': 'Sale not found'}), 404

    # Non-admins can only share bills they created.
    if user_role != 'admin' and getattr(sale, 'user_id', None) != current_user.id:
        return jsonify({'success': False, 'error': 'Forbidden'}), 403

    patient = getattr(sale, 'patient', None)

    data = request.get_json(silent=True) if request.is_json else None
    if isinstance(data, dict):
        override_to = (data.get('to') or '').strip()
    else:
        override_to = ''

    # Always require manual entry; never auto-load patient phone.
    to_msisdn = normalize_msisdn(override_to)
    if not to_msisdn:
        return jsonify({'success': False, 'error': 'Enter a valid phone number for WhatsApp (e.g. 0712xxxxxx or +2547xxxxxxx).'}), 400

    # Reuse the PDF generation logic by calling the PDF endpoint implementation.
    # (Generated here again to avoid internal HTTP calls.)
    try:
        # Generate bytes by calling the same function path.
        # NOTE: This relies on the local helper inside api_sale_receipt_pdf; keep in sync.
        # To avoid duplication in the future, consider extracting to a module-level helper.
        pdf_resp = api_sale_receipt_pdf(sale_id)
        if isinstance(pdf_resp, Response) and pdf_resp.mimetype == 'application/pdf':
            pdf_bytes = pdf_resp.get_data()
        else:
            return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500
    except Exception as e:
        current_app.logger.error(f'WhatsApp PDF generation failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500

    filename = f"Receipt-{sale.sale_number}.pdf"
    caption = f"Makokha Medical Centre\nReceipt {sale.sale_number}\nTotal KSh {float(sale.total_amount or 0):,.2f}"

    try:
        settings = load_whatsapp_settings(current_app.instance_path)
        if settings:
            result = send_document(
                to_msisdn=to_msisdn,
                pdf_bytes=pdf_bytes,
                filename=filename,
                caption=caption,
                token=settings.token,
                phone_number_id=settings.phone_number_id,
                version=settings.api_version,
            )
        else:
            result = send_document(to_msisdn=to_msisdn, pdf_bytes=pdf_bytes, filename=filename, caption=caption)
    except WhatsAppConfigError as e:
        return jsonify({'success': False, 'error': str(e)}), 501
    except Exception as e:
        current_app.logger.error(f'WhatsApp send failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': f'WhatsApp send failed: {str(e)}'}), 500

    return jsonify({'success': True, 'to': to_msisdn, 'result': result})


@app.route('/admin/whatsapp-settings', methods=['GET', 'POST'])
@login_required
def admin_whatsapp_settings():
    """Admin UI to store/test WhatsApp Cloud API settings (no env vars required)."""
    if str(getattr(current_user, 'role', '')).lower().strip() != 'admin':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    existing = load_whatsapp_settings(current_app.instance_path)

    if request.method == 'POST':
        phone_number_id = (request.form.get('phone_number_id') or '').strip()
        api_version = (request.form.get('api_version') or 'v19.0').strip() or 'v19.0'
        token = (request.form.get('token') or '').strip()

        # Allow leaving token blank to keep current token.
        if not token and existing:
            token = existing.token

        if not phone_number_id or not token:
            flash('Phone Number ID and Token are required.', 'danger')
        else:
            save_whatsapp_settings(
                instance_path=current_app.instance_path,
                token=token,
                phone_number_id=phone_number_id,
                api_version=api_version,
            )
            flash('WhatsApp settings saved.', 'success')
            existing = load_whatsapp_settings(current_app.instance_path)

    return render_template(
        'admin/whatsapp_settings.html',
        settings=existing,
        masked_token=mask_token(existing.token) if existing else '',
    )


@app.route('/admin/whatsapp-settings/test', methods=['POST'])
@login_required
def admin_whatsapp_settings_test():
    if str(getattr(current_user, 'role', '')).lower().strip() != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    settings = load_whatsapp_settings(current_app.instance_path)
    if not settings:
        return jsonify({'success': False, 'error': 'WhatsApp settings not configured.'}), 400

    data = request.get_json(silent=True) if request.is_json else None
    if isinstance(data, dict):
        raw_phone = (data.get('to') or '').strip()
        text = (data.get('text') or '').strip() or 'Makokha Medical Centre: WhatsApp configuration test OK.'
    else:
        raw_phone = (request.form.get('to') or '').strip()
        text = (request.form.get('text') or '').strip() or 'Makokha Medical Centre: WhatsApp configuration test OK.'

    to_msisdn = normalize_msisdn(raw_phone)
    if not to_msisdn:
        return jsonify({'success': False, 'error': 'Invalid phone number (expected e.g. 0712xxxxxx or +2547xxxxxxx).'}), 400

    try:
        payload = send_text(
            to_msisdn=to_msisdn,
            text=text,
            token=settings.token,
            phone_number_id=settings.phone_number_id,
            version=settings.api_version,
        )
        return jsonify({'success': True, 'to': to_msisdn, 'result': payload})
    except Exception as e:
        current_app.logger.error(f'WhatsApp test send failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/refunds/<int:refund_id>/receipt.pdf')
@login_required
def api_refund_receipt_pdf(refund_id: int):
    """PDF receipt for refunds (pharmacist/admin)."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('pharmacist', 'admin'):
        return jsonify({'error': 'Unauthorized'}), 403

    if not _REPORTLAB_AVAILABLE:
        return jsonify({'error': 'PDF generator not available (missing reportlab).'}), 501

    refund = (
        db.session.query(Refund)
        .options(
            db.joinedload(Refund.items).joinedload(RefundItem.sale_item),
            db.joinedload(Refund.sale).joinedload(Sale.patient),
            db.joinedload(Refund.user),
        )
        .filter(Refund.id == refund_id)
        .first()
    )
    if not refund:
        return jsonify({'error': 'Refund not found'}), 404

    if user_role != 'admin' and getattr(refund, 'user_id', None) != current_user.id:
        return jsonify({'error': 'Forbidden'}), 403

    patient_name = ''
    try:
        if refund.sale and refund.sale.patient:
            patient_name = refund.sale.patient.get_decrypted_name
    except Exception:
        patient_name = ''

    created_at = getattr(refund, 'created_at', None)
    created_str = created_at.strftime('%Y-%m-%d %H:%M') if created_at else ''
    served_by = getattr(getattr(refund, 'user', None), 'username', None) or 'Pharmacy'

    # Signature: prefer an admin signature if available, else current user
    signature_data_uri = None
    try:
        admin_user = User.query.filter(func.lower(User.role) == 'admin').order_by(User.id.asc()).first()
    except Exception:
        admin_user = None

    try:
        if admin_user:
            sig = DrawnSignature.query.filter_by(user_id=admin_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
        if not signature_data_uri:
            sig = DrawnSignature.query.filter_by(user_id=current_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
    except Exception:
        signature_data_uri = None

    signature_bytes = None
    if signature_data_uri and isinstance(signature_data_uri, str) and 'base64,' in signature_data_uri:
        try:
            signature_bytes = base64.b64decode(signature_data_uri.split('base64,', 1)[1])
        except Exception:
            signature_bytes = None

    buf = BytesIO()
    page_w, page_h = (80 * mm, 240 * mm)
    c = rl_canvas.Canvas(buf, pagesize=(page_w, page_h))
    y = page_h - 10 * mm

    c.setFont('Helvetica-Bold', 10)
    c.drawCentredString(page_w / 2, y, 'MAKOKHA MEDICAL CENTRE')
    y -= 5 * mm
    c.setFont('Helvetica', 7)
    c.drawCentredString(page_w / 2, y, 'REFUND RECEIPT')
    y -= 4 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    def _kv(label: str, value: str):
        nonlocal y
        c.setFont('Helvetica-Bold', 7)
        c.drawString(5 * mm, y, f'{label}:')
        c.setFont('Helvetica', 7)
        c.drawRightString(page_w - 5 * mm, y, (value or '')[:60])
        y -= 4 * mm

    _kv('Refund', refund.refund_number)
    _kv('Date', created_str)
    _kv('Served By', served_by)
    if patient_name:
        _kv('Patient', patient_name)
    try:
        if refund.sale and refund.sale.sale_number:
            _kv('Orig Sale', refund.sale.sale_number)
    except Exception:
        pass

    y -= 1 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    c.setFont('Helvetica-Bold', 8)
    c.drawString(5 * mm, y, 'Items')
    y -= 4 * mm
    c.setFont('Helvetica', 7)
    for it in (refund.items or []):
        desc = ''
        try:
            desc = (getattr(getattr(it, 'sale_item', None), 'drug_name', None) or getattr(getattr(it, 'sale_item', None), 'description', None) or 'Item')
        except Exception:
            desc = 'Item'
        qty = int(getattr(it, 'quantity', 1) or 1)
        unit = float(getattr(it, 'unit_price', 0) or 0)
        total = float(getattr(it, 'total_price', 0) or (unit * qty))

        c.drawString(5 * mm, y, str(desc)[:44])
        y -= 3.5 * mm
        c.setFont('Helvetica', 6.5)
        c.drawString(7 * mm, y, f"{qty} x {unit:,.2f}")
        c.drawRightString(page_w - 5 * mm, y, f"{total:,.2f}")
        y -= 4 * mm
        c.setFont('Helvetica', 7)

    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 5 * mm
    c.setFont('Helvetica-Bold', 9)
    c.drawString(5 * mm, y, 'TOTAL REFUND')
    c.drawRightString(page_w - 5 * mm, y, f"KSh {float(refund.total_amount or 0):,.2f}")
    y -= 6 * mm

    # Stamp
    try:
        stamp_y = _draw_rubber_stamp_pdf(c, page_w, y)
    except Exception:
        # Fallback: keep existing behavior if helper isn't in scope for any reason
        stamp_w = page_w - 10 * mm
        stamp_h = 22 * mm
        stamp_x = 5 * mm
        stamp_y = max(12 * mm, y - stamp_h)
        c.setStrokeColor(colors.HexColor('#2e3192'))
        c.setLineWidth(1.2)
        c.rect(stamp_x, stamp_y, stamp_w, stamp_h, stroke=1, fill=0)
        c.setFont('Helvetica-Bold', 7)
        c.setFillColor(colors.HexColor('#2e3192'))
        c.drawCentredString(page_w / 2, stamp_y + stamp_h - 6 * mm, 'MAKOKHA MEDICAL CENTRE')
        c.setFillColor(colors.HexColor('#dc143c'))
        c.setFont('Helvetica-Bold', 8)
        c.drawCentredString(page_w / 2, stamp_y + stamp_h - 12 * mm, datetime.now().strftime('%d %b %Y').upper())
        c.setFillColor(colors.HexColor('#2e3192'))
        c.setFont('Helvetica', 6.5)
        c.drawCentredString(page_w / 2, stamp_y + 4 * mm, 'Tel: 0741 256 531 / 0713 580 997')
        c.setFillColor(colors.black)
    y = stamp_y - 6 * mm

    if signature_bytes:
        try:
            img = ImageReader(BytesIO(signature_bytes))
            sig_w = 35 * mm
            sig_h = 14 * mm
            c.drawImage(img, 5 * mm, max(5 * mm, y - sig_h), width=sig_w, height=sig_h, preserveAspectRatio=True, mask='auto')
            c.setFont('Helvetica', 6.5)
            c.drawString(5 * mm, max(5 * mm, y - sig_h) - 3 * mm, 'Signed')
        except Exception:
            pass

    c.showPage()
    c.save()
    buf.seek(0)

    pdf_bytes = buf.getvalue()
    filename = f"refund-{refund.refund_number}.pdf"
    return Response(pdf_bytes, mimetype='application/pdf', headers={'Content-Disposition': f'attachment; filename={filename}'})


@app.route('/api/refunds/<int:refund_id>/share-whatsapp', methods=['POST'])
@login_required
def api_refund_share_whatsapp(refund_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('pharmacist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    refund = db.session.get(Refund, refund_id)
    if not refund:
        return jsonify({'success': False, 'error': 'Refund not found'}), 404

    if user_role != 'admin' and getattr(refund, 'user_id', None) != current_user.id:
        return jsonify({'success': False, 'error': 'Forbidden'}), 403

    data = request.get_json(silent=True) if request.is_json else None
    override_to = (data.get('to') or '').strip() if isinstance(data, dict) else ''

    # Always require manual entry; never auto-load patient phone.
    to_msisdn = normalize_msisdn(override_to)
    if not to_msisdn:
        return jsonify({'success': False, 'error': 'Enter a valid phone number for WhatsApp.'}), 400

    try:
        pdf_resp = api_refund_receipt_pdf(refund_id)
        if isinstance(pdf_resp, Response) and pdf_resp.mimetype == 'application/pdf':
            pdf_bytes = pdf_resp.get_data()
        else:
            return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500
    except Exception as e:
        current_app.logger.error(f'Refund WhatsApp PDF generation failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500

    filename = f"Refund-{refund.refund_number}.pdf"
    caption = f"Makokha Medical Centre\nRefund {refund.refund_number}\nTotal KSh {float(refund.total_amount or 0):,.2f}"

    try:
        settings = load_whatsapp_settings(current_app.instance_path)
        if settings:
            result = send_document(
                to_msisdn=to_msisdn,
                pdf_bytes=pdf_bytes,
                filename=filename,
                caption=caption,
                token=settings.token,
                phone_number_id=settings.phone_number_id,
                version=settings.api_version,
            )
        else:
            result = send_document(to_msisdn=to_msisdn, pdf_bytes=pdf_bytes, filename=filename, caption=caption)
    except WhatsAppConfigError as e:
        return jsonify({'success': False, 'error': str(e)}), 501
    except Exception as e:
        current_app.logger.error(f'Refund WhatsApp send failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

    return jsonify({'success': True, 'to': to_msisdn, 'result': result})


@app.route('/api/controlled-sales/<int:sale_id>/receipt.pdf')
@login_required
def api_controlled_sale_receipt_pdf(sale_id: int):
    """PDF receipt for controlled sales."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('pharmacist', 'admin'):
        return jsonify({'error': 'Unauthorized'}), 403

    if not _REPORTLAB_AVAILABLE:
        return jsonify({'error': 'PDF generator not available (missing reportlab).'}), 501

    sale = (
        db.session.query(ControlledSale)
        .options(
            db.joinedload(ControlledSale.items),
            db.joinedload(ControlledSale.patient),
            db.joinedload(ControlledSale.user),
        )
        .filter(ControlledSale.id == sale_id)
        .first()
    )
    if not sale:
        return jsonify({'error': 'Controlled sale not found'}), 404

    if user_role != 'admin' and getattr(sale, 'user_id', None) != current_user.id:
        return jsonify({'error': 'Forbidden'}), 403

    patient_name = ''
    try:
        if sale.patient:
            patient_name = sale.patient.get_decrypted_name
    except Exception:
        patient_name = ''

    created_at = getattr(sale, 'created_at', None)
    created_str = created_at.strftime('%Y-%m-%d %H:%M') if created_at else ''
    served_by = getattr(getattr(sale, 'user', None), 'username', None) or 'Pharmacy'

    signature_data_uri = None
    try:
        admin_user = User.query.filter(func.lower(User.role) == 'admin').order_by(User.id.asc()).first()
    except Exception:
        admin_user = None

    try:
        if admin_user:
            sig = DrawnSignature.query.filter_by(user_id=admin_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
        if not signature_data_uri:
            sig = DrawnSignature.query.filter_by(user_id=current_user.id, is_active=True).first()
            signature_data_uri = getattr(sig, 'signature_data', None) if sig else None
    except Exception:
        signature_data_uri = None

    signature_bytes = None
    if signature_data_uri and isinstance(signature_data_uri, str) and 'base64,' in signature_data_uri:
        try:
            signature_bytes = base64.b64decode(signature_data_uri.split('base64,', 1)[1])
        except Exception:
            signature_bytes = None

    amount_given = request.args.get('amount_given', type=float)
    change = request.args.get('change', type=float)
    if amount_given is None and request.is_json:
        try:
            data = request.get_json(silent=True) or {}
            if isinstance(data, dict):
                if data.get('amount_given') is not None:
                    amount_given = float(data.get('amount_given'))
                if data.get('change') is not None:
                    change = float(data.get('change'))
        except Exception:
            pass

    # Controlled sales store receipt_html directly; use that for best-effort extraction
    try:
        amount_given, change = _resolve_cash_meta(getattr(sale, 'payment_method', None), float(getattr(sale, 'total_amount', 0) or 0), amount_given, change, getattr(sale, 'receipt_html', None))
    except Exception:
        pass

    buf = BytesIO()
    page_w, page_h = (80 * mm, 260 * mm)
    c = rl_canvas.Canvas(buf, pagesize=(page_w, page_h))
    y = page_h - 10 * mm

    c.setFont('Helvetica-Bold', 10)
    c.drawCentredString(page_w / 2, y, 'MAKOKHA MEDICAL CENTRE')
    y -= 5 * mm
    c.setFont('Helvetica', 7)
    c.drawCentredString(page_w / 2, y, 'CONTROLLED DRUGS RECEIPT')
    y -= 4 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    def _kv(label: str, value: str):
        nonlocal y
        c.setFont('Helvetica-Bold', 7)
        c.drawString(5 * mm, y, f'{label}:')
        c.setFont('Helvetica', 7)
        c.drawRightString(page_w - 5 * mm, y, (value or '')[:60])
        y -= 4 * mm

    _kv('Sale', str(getattr(sale, 'sale_number', '') or sale.id))
    _kv('Date', created_str)
    _kv('Served By', served_by)

    # Customer/Patient details (mirror pharmacist controlled receipt)
    customer_name = str(getattr(sale, 'customer_name', '') or '').strip()
    customer_phone = str(getattr(sale, 'customer_phone', '') or '').strip()
    customer_age = str(getattr(sale, 'customer_age', '') or '').strip()
    customer_gender = str(getattr(sale, 'customer_gender', '') or '').strip()
    diagnosis = str(getattr(sale, 'diagnosis', '') or '').strip()
    destination = str(getattr(sale, 'destination', '') or '').strip()

    if not customer_name and getattr(sale, 'patient', None):
        try:
            customer_name = str(getattr(sale.patient, 'get_decrypted_name', '') or '').strip()
        except Exception:
            customer_name = ''
    if not customer_phone and getattr(sale, 'patient', None):
        try:
            customer_phone = str(getattr(sale.patient, 'phone', '') or '').strip()
        except Exception:
            customer_phone = ''
    if not customer_age and getattr(sale, 'patient', None):
        try:
            customer_age = str(getattr(sale.patient, 'age', '') or '').strip()
        except Exception:
            customer_age = ''
    if not customer_gender and getattr(sale, 'patient', None):
        try:
            customer_gender = str(getattr(sale.patient, 'gender', '') or '').strip()
        except Exception:
            customer_gender = ''
    if not destination and getattr(sale, 'patient', None):
        try:
            destination = str(getattr(sale.patient, 'destination', '') or '').strip()
        except Exception:
            destination = ''

    if customer_name:
        _kv('Customer', customer_name)
    if customer_phone:
        _kv('Phone', customer_phone)
    if customer_age or customer_gender:
        _kv('Age/Sex', f"{customer_age} / {customer_gender}".strip(' /'))
    if diagnosis:
        _kv('Dx', diagnosis)
    if destination:
        _kv('Destination', destination)

    y -= 1 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    c.setFont('Helvetica-Bold', 8)
    c.drawString(5 * mm, y, 'Items')
    y -= 4 * mm
    c.setFont('Helvetica', 7)

    for it in (sale.items or []):
        desc = (getattr(it, 'controlled_drug_name', '') or '').strip() or 'Drug'
        qty = int(getattr(it, 'quantity', 1) or 1)
        unit = float(getattr(it, 'unit_price', 0) or 0)
        total = float(getattr(it, 'total_price', 0) or (unit * qty))

        c.drawString(5 * mm, y, desc[:44])
        y -= 3.5 * mm
        c.setFont('Helvetica', 6.5)
        c.drawString(7 * mm, y, f"{qty} x {unit:,.2f}")
        c.drawRightString(page_w - 5 * mm, y, f"{total:,.2f}")
        y -= 4 * mm
        c.setFont('Helvetica', 7)
        if y < 55 * mm:
            c.showPage()
            y = page_h - 10 * mm

    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 5 * mm
    c.setFont('Helvetica-Bold', 9)
    c.drawString(5 * mm, y, 'TOTAL')
    c.drawRightString(page_w - 5 * mm, y, f"KSh {float(getattr(sale, 'total_amount', 0) or 0):,.2f}")
    y -= 5 * mm

    c.setFont('Helvetica-Bold', 7)
    c.drawString(5 * mm, y, 'PAYMENT SUMMARY')
    y -= 4 * mm
    c.setFont('Helvetica', 7)
    _kv('Method', str((getattr(sale, 'payment_method', '') or '').upper()))
    _kv('Amount', f"KSh {float(getattr(sale, 'total_amount', 0) or 0):,.2f}")
    if (str(getattr(sale, 'payment_method', '') or '').lower().strip() == 'cash') and amount_given is not None:
        _kv('Amount Given', f"KSh {float(amount_given or 0):,.2f}")
        bal = change
        if bal is None:
            try:
                bal = float(amount_given) - float(getattr(sale, 'total_amount', 0) or 0)
            except Exception:
                bal = None
        if bal is not None:
            label = 'Balance' if float(bal) >= 0 else 'Balance Due'
            _kv(label, f"KSh {float(bal):,.2f}")
    y -= 2 * mm

    try:
        stamp_y = _draw_rubber_stamp_pdf(c, page_w, y)
    except Exception:
        stamp_w = page_w - 10 * mm
        stamp_h = 22 * mm
        stamp_x = 5 * mm
        stamp_y = max(12 * mm, y - stamp_h)
        c.setStrokeColor(colors.HexColor('#2e3192'))
        c.setLineWidth(1.2)
        c.rect(stamp_x, stamp_y, stamp_w, stamp_h, stroke=1, fill=0)
        c.setFont('Helvetica-Bold', 7)
        c.setFillColor(colors.HexColor('#2e3192'))
        c.drawCentredString(page_w / 2, stamp_y + stamp_h - 6 * mm, 'MAKOKHA MEDICAL CENTRE')
        c.setFillColor(colors.HexColor('#dc143c'))
        c.setFont('Helvetica-Bold', 8)
        c.drawCentredString(page_w / 2, stamp_y + stamp_h - 12 * mm, datetime.now().strftime('%d %b %Y').upper())
        c.setFillColor(colors.HexColor('#2e3192'))
        c.setFont('Helvetica', 6.5)
        c.drawCentredString(page_w / 2, stamp_y + 4 * mm, 'Tel: 0741 256 531 / 0713 580 997')
        c.setFillColor(colors.black)
    y = stamp_y - 6 * mm

    if signature_bytes:
        try:
            img = ImageReader(BytesIO(signature_bytes))
            sig_w = 35 * mm
            sig_h = 14 * mm
            c.drawImage(img, 5 * mm, max(5 * mm, y - sig_h), width=sig_w, height=sig_h, preserveAspectRatio=True, mask='auto')
            c.setFont('Helvetica', 6.5)
            c.drawString(5 * mm, max(5 * mm, y - sig_h) - 3 * mm, 'Signed')
        except Exception:
            pass

    c.showPage()
    c.save()
    buf.seek(0)

    pdf_bytes = buf.getvalue()
    filename = f"controlled-receipt-{getattr(sale, 'sale_number', sale.id)}.pdf"
    return Response(pdf_bytes, mimetype='application/pdf', headers={'Content-Disposition': f'attachment; filename={filename}'})


@app.route('/api/controlled-sales/<int:sale_id>/share-whatsapp', methods=['POST'])
@login_required
def api_controlled_sale_share_whatsapp(sale_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('pharmacist', 'admin'):
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    sale = db.session.get(ControlledSale, sale_id)
    if not sale:
        return jsonify({'success': False, 'error': 'Controlled sale not found'}), 404

    if user_role != 'admin' and getattr(sale, 'user_id', None) != current_user.id:
        return jsonify({'success': False, 'error': 'Forbidden'}), 403

    data = request.get_json(silent=True) if request.is_json else None
    override_to = (data.get('to') or '').strip() if isinstance(data, dict) else ''

    # Always require manual entry; never auto-load patient/customer phone.
    to_msisdn = normalize_msisdn(override_to)
    if not to_msisdn:
        return jsonify({'success': False, 'error': 'Enter a valid phone number for WhatsApp.'}), 400

    try:
        pdf_resp = api_controlled_sale_receipt_pdf(sale_id)
        if isinstance(pdf_resp, Response) and pdf_resp.mimetype == 'application/pdf':
            pdf_bytes = pdf_resp.get_data()
        else:
            return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500
    except Exception as e:
        current_app.logger.error(f'Controlled WhatsApp PDF generation failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500

    filename = f"Controlled-Receipt-{getattr(sale, 'sale_number', sale.id)}.pdf"
    caption = f"Makokha Medical Centre\nControlled Receipt {getattr(sale, 'sale_number', sale.id)}\nTotal KSh {float(getattr(sale, 'total_amount', 0) or 0):,.2f}"

    try:
        settings = load_whatsapp_settings(current_app.instance_path)
        if settings:
            result = send_document(
                to_msisdn=to_msisdn,
                pdf_bytes=pdf_bytes,
                filename=filename,
                caption=caption,
                token=settings.token,
                phone_number_id=settings.phone_number_id,
                version=settings.api_version,
            )
        else:
            result = send_document(to_msisdn=to_msisdn, pdf_bytes=pdf_bytes, filename=filename, caption=caption)
    except WhatsAppConfigError as e:
        return jsonify({'success': False, 'error': str(e)}), 501
    except Exception as e:
        current_app.logger.error(f'Controlled WhatsApp send failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

    return jsonify({'success': True, 'to': to_msisdn, 'result': result})


@app.route('/api/transactions/<int:transaction_id>/receipt.pdf')
@login_required
def api_transaction_receipt_pdf(transaction_id: int):
    """PDF for admin transaction receipts.

    This PDF mirrors the `admin/transaction_receipt.html` structure so that
    transactions always share their *own* PDF format.
    """
    if str(getattr(current_user, 'role', '')).lower().strip() != 'admin':
        return jsonify({'error': 'Unauthorized'}), 403

    tx = _db_get(Transaction, transaction_id)
    if not tx:
        return jsonify({'error': 'Transaction not found'}), 404

    if not _REPORTLAB_AVAILABLE:
        return jsonify({'error': 'PDF generator not available (missing reportlab).'}), 501

    # Load reference objects (best-effort; never fail the PDF if missing)
    sale = None
    refund = None
    expense = None
    purchase = None
    ref_id = getattr(tx, 'reference_id', None)
    try:
        if tx.transaction_type == 'sale' and ref_id:
            sale = (
                db.session.query(Sale)
                .options(
                    db.joinedload(Sale.items),
                    db.joinedload(Sale.patient),
                    db.joinedload(Sale.user),
                )
                .filter(Sale.id == int(ref_id))
                .first()
            )
        elif tx.transaction_type == 'refund' and ref_id:
            refund = (
                db.session.query(Refund)
                .options(
                    db.joinedload(Refund.items).joinedload(RefundItem.sale_item),
                    db.joinedload(Refund.sale).joinedload(Sale.patient),
                    db.joinedload(Refund.user),
                )
                .filter(Refund.id == int(ref_id))
                .first()
            )
        elif tx.transaction_type == 'expense' and ref_id:
            expense = _db_get(Expense, int(ref_id))
        elif tx.transaction_type == 'purchase' and ref_id:
            purchase = _db_get(Purchase, int(ref_id))
        elif tx.transaction_type == 'controlled_sale' and ref_id:
            # Keep controlled sale inside the transaction PDF (do not reuse controlled sale receipt PDF).
            # If needed later, we can expand details similar to the sale section.
            pass
    except Exception:
        sale = refund = expense = purchase = None

    buf = BytesIO()
    page_w, page_h = (80 * mm, 260 * mm)
    c = rl_canvas.Canvas(buf, pagesize=(page_w, page_h))
    y = page_h - 10 * mm

    def _ensure_space(min_y: float = 20 * mm):
        nonlocal y
        if y < min_y:
            c.showPage()
            y = page_h - 10 * mm

    def _kv(label: str, value: str):
        nonlocal y
        _ensure_space()
        c.setFont('Helvetica-Bold', 7)
        c.drawString(5 * mm, y, f'{label}:')
        c.setFont('Helvetica', 7)
        c.drawRightString(page_w - 5 * mm, y, (value or '')[:60])
        y -= 4 * mm

    def _section(title: str):
        nonlocal y
        _ensure_space(30 * mm)
        y -= 2 * mm
        c.setFont('Helvetica-Bold', 8)
        c.drawString(5 * mm, y, title)
        y -= 4 * mm

    def _table_row(col1: str, col2: str, col3: str, col4: str):
        nonlocal y
        _ensure_space(26 * mm)
        c.setFont('Helvetica', 6.5)
        # Column layout within 70mm printable width
        x1 = 5 * mm
        x2 = 43 * mm
        x3 = 54 * mm
        x4 = page_w - 5 * mm
        c.drawString(x1, y, (col1 or '')[:28])
        c.drawRightString(x2, y, (col2 or '')[:10])
        c.drawRightString(x3, y, (col3 or '')[:10])
        c.drawRightString(x4, y, (col4 or '')[:12])
        y -= 3.8 * mm

    # Optional cash metadata (query/body/receipt_html)
    amount_given = request.args.get('amount_given', type=float)
    change = request.args.get('change', type=float)
    if amount_given is None and request.is_json:
        try:
            data = request.get_json(silent=True) or {}
            if isinstance(data, dict):
                if data.get('amount_given') is not None:
                    amount_given = float(data.get('amount_given'))
                if data.get('change') is not None:
                    change = float(data.get('change'))
        except Exception:
            pass

    try:
        base_amt = float((getattr(sale, 'total_amount', None) if sale else getattr(tx, 'amount', 0)) or 0)
        amount_given, change = _resolve_cash_meta(getattr(sale, 'payment_method', None) if sale else getattr(tx, 'payment_method', None), base_amt, amount_given, change, getattr(tx, 'receipt_html', None))
    except Exception:
        pass

    # Header
    c.setFont('Helvetica-Bold', 10)
    c.drawCentredString(page_w / 2, y, 'MAKOKHA MEDICAL CENTRE')
    y -= 5 * mm
    c.setFont('Helvetica', 7)
    c.drawCentredString(page_w / 2, y, 'TRANSACTION RECEIPT')
    y -= 4 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    # Meta (matches admin/transaction_receipt.html)
    _kv('Receipt #', str(getattr(tx, 'receipt_number', '') or f"TX-{tx.id}"))
    _kv('Transaction #', str(getattr(tx, 'transaction_number', '') or ''))
    _kv('Type', str(getattr(tx, 'transaction_type', '') or '').capitalize())
    try:
        _kv('Date', tx.created_at.strftime('%Y-%m-%d %H:%M') if tx.created_at else '')
    except Exception:
        _kv('Date', '')
    if getattr(tx, 'receipt_reprinted_at', None):
        try:
            _kv('Reprinted', tx.receipt_reprinted_at.strftime('%Y-%m-%d %H:%M'))
        except Exception:
            pass
    processed_by = getattr(getattr(tx, 'user', None), 'username', '') or ''
    _kv('Processed By', processed_by)
    notes = str(getattr(tx, 'notes', '') or '')
    if notes:
        _kv('Notes', notes[:60])

    y -= 1 * mm
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 4 * mm

    # Body
    if sale:
        _section('Sale Items')
        _table_row('Drug', 'Qty', 'Unit', 'Total')
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 3 * mm
        for it in (getattr(sale, 'items', None) or []):
            desc = (getattr(it, 'drug_name', None) or getattr(it, 'description', None) or '').strip() or 'Item'
            qty = int(getattr(it, 'quantity', 0) or 0)
            unit = float(getattr(it, 'unit_price', 0) or 0)
            total = float(getattr(it, 'total_price', 0) or (unit * qty))
            _table_row(desc, str(qty), f"{unit:,.2f}", f"{total:,.2f}")
        y -= 1 * mm
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 5 * mm
        c.setFont('Helvetica-Bold', 8)
        c.drawString(5 * mm, y, 'Total:')
        c.drawRightString(page_w - 5 * mm, y, f"KSh {float(getattr(sale, 'total_amount', 0) or 0):,.2f}")
        y -= 6 * mm
    elif refund:
        _section('Refund Items')
        _table_row('Item', 'Qty', 'Unit', 'Total')
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 3 * mm
        for it in (getattr(refund, 'items', None) or []):
            sale_item = getattr(it, 'sale_item', None)
            desc = (getattr(sale_item, 'drug_name', None) or getattr(getattr(sale_item, 'drug', None), 'name', None) or '').strip() or 'Item'
            qty = int(getattr(it, 'quantity', 0) or 0)
            unit = float(getattr(it, 'unit_price', 0) or 0)
            total = float(getattr(it, 'total_price', 0) or (unit * qty))
            _table_row(desc, str(qty), f"{unit:,.2f}", f"{total:,.2f}")
        y -= 1 * mm
        c.line(5 * mm, y, page_w - 5 * mm, y)
        y -= 5 * mm
        c.setFont('Helvetica-Bold', 8)
        c.drawString(5 * mm, y, 'Refund Total:')
        c.drawRightString(page_w - 5 * mm, y, f"KSh {float(getattr(refund, 'total_amount', 0) or 0):,.2f}")
        y -= 6 * mm
    elif expense:
        _section('Expense')
        _kv('Category', str(getattr(expense, 'category', '') or ''))
        _kv('Description', str(getattr(expense, 'description', '') or '')[:60])
    elif purchase:
        _section('Purchase')
        _kv('Supplier', str(getattr(purchase, 'supplier', '') or ''))
        _kv('Invoice #', str(getattr(purchase, 'invoice_number', '') or ''))

    # Always show transaction amount at bottom
    _ensure_space(24 * mm)
    c.line(5 * mm, y, page_w - 5 * mm, y)
    y -= 5 * mm
    c.setFont('Helvetica-Bold', 9)
    c.drawString(5 * mm, y, 'Amount')
    c.drawRightString(page_w - 5 * mm, y, f"KSh {float(getattr(tx, 'amount', 0) or 0):,.2f}")
    y -= 6 * mm

    # Payment summary for customer-pay (sale) transactions
    if sale:
        pm = str((getattr(sale, 'payment_method', None) or getattr(tx, 'payment_method', None) or '')).strip().lower()
        c.setFont('Helvetica-Bold', 8)
        c.drawString(5 * mm, y, 'Payment Summary')
        y -= 4 * mm
        _kv('Method', str((getattr(sale, 'payment_method', None) or getattr(tx, 'payment_method', None) or '').upper()))
        _kv('Amount', f"KSh {float(getattr(sale, 'total_amount', 0) or 0):,.2f}")
        if pm == 'cash' and amount_given is not None:
            _kv('Amount Given', f"KSh {float(amount_given or 0):,.2f}")
            bal = change
            if bal is None:
                try:
                    bal = float(amount_given) - float(getattr(sale, 'total_amount', 0) or 0)
                except Exception:
                    bal = None
            if bal is not None:
                label = 'Balance' if float(bal) >= 0 else 'Balance Due'
                _kv(label, f"KSh {float(bal):,.2f}")

    c.showPage()
    c.save()
    buf.seek(0)

    pdf_bytes = buf.getvalue()
    filename = f"transaction-{getattr(tx, 'receipt_number', '') or tx.id}.pdf"
    return Response(pdf_bytes, mimetype='application/pdf', headers={'Content-Disposition': f'attachment; filename={filename}'})


@app.route('/api/transactions/<int:transaction_id>/share-whatsapp', methods=['POST'])
@login_required
def api_transaction_share_whatsapp(transaction_id: int):
    if str(getattr(current_user, 'role', '')).lower().strip() != 'admin':
        return jsonify({'success': False, 'error': 'Unauthorized'}), 403

    tx = db.session.get(Transaction, transaction_id)
    if not tx:
        return jsonify({'success': False, 'error': 'Transaction not found'}), 404

    data = request.get_json(silent=True) if request.is_json else None
    override_to = (data.get('to') or '').strip() if isinstance(data, dict) else ''

    to_msisdn = normalize_msisdn(override_to)
    if not to_msisdn:
        return jsonify({'success': False, 'error': 'Enter a valid phone number for WhatsApp.'}), 400

    try:
        pdf_resp = api_transaction_receipt_pdf(transaction_id)
        if isinstance(pdf_resp, Response) and pdf_resp.mimetype == 'application/pdf':
            pdf_bytes = pdf_resp.get_data()
        else:
            return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500
    except Exception as e:
        current_app.logger.error(f'Transaction WhatsApp PDF generation failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': 'Failed to generate PDF'}), 500

    filename = f"Transaction-{getattr(tx, 'receipt_number', '') or ('TX-' + str(tx.id))}.pdf"
    caption = f"Makokha Medical Centre\nTransaction {getattr(tx, 'receipt_number', '') or ('TX-' + str(tx.id))}\nAmount KSh {float(getattr(tx, 'amount', 0) or 0):,.2f}"

    try:
        settings = load_whatsapp_settings(current_app.instance_path)
        if settings:
            result = send_document(
                to_msisdn=to_msisdn,
                pdf_bytes=pdf_bytes,
                filename=filename,
                caption=caption,
                token=settings.token,
                phone_number_id=settings.phone_number_id,
                version=settings.api_version,
            )
        else:
            result = send_document(to_msisdn=to_msisdn, pdf_bytes=pdf_bytes, filename=filename, caption=caption)
    except WhatsAppConfigError as e:
        return jsonify({'success': False, 'error': str(e)}), 501
    except Exception as e:
        current_app.logger.error(f'Transaction WhatsApp send failed: {str(e)}', exc_info=True)
        return jsonify({'success': False, 'error': str(e)}), 500

    return jsonify({'success': True, 'to': to_msisdn, 'result': result})

@app.route('/api/notifications_list')
@login_required

def create_notification(user_id, message, url=None):
    """Helper function to create a notification."""
    try:
        notification = Notification(
            user_id=user_id,
            message=message,
            url=url
        )
        db.session.add(notification)
        db.session.commit()
        return notification
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f"Failed to create notification: {e}")
        return None

@app.route('/api/notifications', methods=['GET'])
@login_required
def api_get_notifications():
    """API endpoint to get all notifications for the current user."""
    notifications = Notification.query.filter_by(user_id=current_user.id).order_by(Notification.created_at.desc()).all()
    return jsonify([n.to_dict() for n in notifications])

@app.route('/api/notifications/<int:notification_id>/read', methods=['POST'])
@login_required
def mark_notification_read(notification_id):
    """API endpoint to mark a notification as read."""
    notification = _db_get_or_404(Notification, notification_id)
    if notification.user_id != current_user.id:
        abort(403)
    notification.is_read = True
    db.session.commit()
    return jsonify({'success': True})
def get_notifications():
    notifications = Notification.query.filter_by(user_id=current_user.id, is_read=False).order_by(Notification.created_at.desc()).all()
    return jsonify([{
        'id': n.id,
        'message': n.message,
        'link': n.link,
        'created_at': n.created_at.strftime('%Y-%m-%d %H:%M')
    } for n in notifications])



@app.route('/receptionist/billing')
@login_required
def receptionist_billing():
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))
    
    patients = Patient.query.filter_by(status='active').all()
    services = Service.query.all()
    lab_tests = LabTest.query.all()
    imaging_tests = ImagingTest.query.filter_by(is_active=True).order_by(ImagingTest.name).all()
    
    return render_template('receptionist/billing.html',
        patients=patients,
        services=services,
        lab_tests=lab_tests,
        imaging_tests=imaging_tests,
    )


@app.route('/api/patient/<int:patient_id>/requested-services')
@login_required
def api_patient_requested_services(patient_id: int):
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    try:
        rows = (
            PatientService.query
            .filter(PatientService.patient_id == patient.id)
            .filter(or_(PatientService.status.is_(None), PatientService.status == 'requested'))
            .filter(PatientService.billed_sale_id.is_(None))
            .order_by(PatientService.created_at.desc())
            .all()
        )
        return jsonify([
            {
                'patient_service_id': r.id,
                'service_id': r.service_id,
                'service_name': (r.service.name if getattr(r, 'service', None) else None),
                'status': r.status or 'requested',
                'created_at': r.created_at.isoformat() if getattr(r, 'created_at', None) else None,
            }
            for r in rows
        ])
    except Exception:
        # Never break UI; return empty.
        return jsonify([])


@app.route('/api/patient/<int:patient_id>/completed-services')
@login_required
def api_patient_completed_services(patient_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    try:
        # Billing should show all unbilled services for the patient, regardless of
        # whether they are still "requested" or already "done".
        rows = (
            PatientService.query
            .filter(PatientService.patient_id == patient.id)
            .filter(PatientService.billed_sale_id.is_(None))
            .filter(
                or_(
                    PatientService.status.is_(None),
                    PatientService.status.in_(['requested', 'in_progress', 'done', 'completed'])
                )
            )
            .order_by(PatientService.created_at.desc())
            .all()
        )
        return jsonify([
            {
                'patient_service_id': r.id,
                'service_id': r.service_id,
                'service_name': (r.service.name if getattr(r, 'service', None) else None),
                'price': float(getattr(getattr(r, 'service', None), 'price', 0) or 0),
                'service_price': float(getattr(getattr(r, 'service', None), 'price', 0) or 0),
                'status': r.status or 'requested',
                'created_at': r.created_at.isoformat() if getattr(r, 'created_at', None) else None,
            }
            for r in rows
        ])
    except Exception:
        return jsonify([])


@app.route('/api/drugs/search')
@login_required
def api_drugs_search():
    q = (request.args.get('q') or '').strip()
    limit = request.args.get('limit', 25, type=int)
    limit = max(1, min(int(limit or 25), 100))

    query = Drug.query.filter(Drug.remaining_quantity > 0)
    if q:
        like = f"%{q}%"
        query = query.filter(or_(Drug.name.ilike(like), Drug.generic_name.ilike(like)))

    rows = query.order_by(Drug.name).limit(limit).all()
    return jsonify([
        {
            'id': d.id,
            'name': d.name,
            'generic_name': d.generic_name,
            'remaining_quantity': int(d.remaining_quantity or 0),
        }
        for d in rows
    ])


@app.route('/api/controlled-drugs/search')
@login_required
def api_controlled_drugs_search():
    q = (request.args.get('q') or '').strip()
    limit = request.args.get('limit', 25, type=int)
    limit = max(1, min(int(limit or 25), 100))

    query = ControlledDrug.query.filter(ControlledDrug.remaining_quantity > 0)
    if q:
        like = f"%{q}%"
        query = query.filter(or_(ControlledDrug.name.ilike(like), ControlledDrug.generic_name.ilike(like)))

    rows = query.order_by(ControlledDrug.name).limit(limit).all()
    return jsonify([
        {
            'id': d.id,
            'name': d.name,
            'generic_name': d.generic_name,
            'remaining_quantity': int(d.remaining_quantity or 0),
        }
        for d in rows
    ])


@app.route('/api/services/search')
@login_required
def api_services_search():
    q = (request.args.get('q') or '').strip()
    limit = request.args.get('limit', 20, type=int)
    limit = max(1, min(int(limit or 20), 50))

    query = Service.query.filter_by(is_active=True)
    if q:
        like = f"%{q}%"
        query = query.filter(or_(Service.name.ilike(like), Service.description.ilike(like)))

    rows = query.order_by(Service.name).limit(limit).all()
    return jsonify([
        {
            'id': s.id,
            'name': s.name,
            'price': float(s.price or 0),
            'description': s.description,
        }
        for s in rows
    ])


@app.route('/api/doctor/patient/<int:patient_id>/requested-services', methods=['POST'])
@login_required
def api_doctor_add_requested_service(patient_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('doctor', 'admin'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    data = request.get_json(silent=True) if request.is_json else None
    if isinstance(data, dict):
        service_id = data.get('service_id')
        notes = (data.get('notes') or '').strip() or None
    else:
        service_id = request.form.get('service_id')
        notes = (request.form.get('notes') or '').strip() or None

    try:
        service_id_int = int(service_id)
    except Exception:
        return jsonify({'error': 'Invalid service'}), 400

    service = _db_get(Service, service_id_int)
    if not service or not getattr(service, 'is_active', True):
        return jsonify({'error': 'Service not found'}), 404

    row = PatientService(
        patient_id=patient.id,
        service_id=service.id,
        notes=notes,
        status='requested',
        requested_by=current_user.id,
    )

    try:
        db.session.add(row)
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        current_app.logger.error(f'api_doctor_add_requested_service failed: {str(e)}', exc_info=True)
        return jsonify({'error': 'Server error'}), 500

    return jsonify({
        'success': True,
        'patient_service_id': row.id,
        'service_id': row.service_id,
        'service_name': service.name,
        'status': row.status or 'requested',
        'created_at': row.created_at.isoformat() if getattr(row, 'created_at', None) else None,
    }), 201


@app.route('/doctor/api/patient/<int:patient_id>/services-done', methods=['GET'])
@login_required
def doctor_api_patient_services_done(patient_id: int):
    """Doctor-only: fetch services marked done/completed for patient_details live refresh."""
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('doctor', 'admin'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    try:
        rows = (
            PatientService.query
            .filter(PatientService.patient_id == patient.id)
            .filter(PatientService.status.in_(['completed', 'done']))
            .order_by(
                PatientService.completed_at.desc().nullslast(),
                PatientService.updated_at.desc().nullslast(),
                PatientService.created_at.desc().nullslast(),
                PatientService.id.desc(),
            )
            .all()
        )

        payload = []
        for r in rows:
            service = getattr(r, 'service', None)
            payload.append({
                'patient_service_id': r.id,
                'service_id': r.service_id,
                'service_name': (service.name if service else None),
                'notes': getattr(r, 'notes', None),
                'status': r.status or 'done',
                'billed_sale_id': getattr(r, 'billed_sale_id', None),
                'completed_at': r.completed_at.isoformat() if getattr(r, 'completed_at', None) else None,
                'updated_at': r.updated_at.isoformat() if getattr(r, 'updated_at', None) else None,
                'created_at': r.created_at.isoformat() if getattr(r, 'created_at', None) else None,
                'performed_by_name': (getattr(getattr(r, 'performer', None), 'username', None)),
                'completed_by_name': (getattr(getattr(r, 'completer', None), 'username', None)),
                'billed_by_name': (getattr(getattr(r, 'biller', None), 'username', None)),
                'requested_by_name': (getattr(getattr(r, 'requester', None), 'username', None)),
            })

        return jsonify(payload)
    except Exception:
        return jsonify([])


@app.route('/api/patient/<int:patient_id>/prescriptions')
@login_required
def api_patient_prescriptions(patient_id: int):
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    prescriptions = (
        Prescription.query
        .filter_by(patient_id=patient.id)
        .order_by(Prescription.created_at.desc())
        .all()
    )

    payload = []
    for prescription in prescriptions:
        items_payload = []
        for item in (prescription.items or []):
            if getattr(item, 'status', None) != 'dispensed':
                continue
            drug = getattr(item, 'drug', None)
            if not drug:
                continue
            unit_price = float(getattr(drug, 'selling_price', 0) or 0)
            qty = int(getattr(item, 'quantity', 0) or 0)
            items_payload.append({
                'id': item.id,
                'drug_name': getattr(drug, 'name', None),
                'drug_number': getattr(drug, 'drug_number', None),
                'quantity': qty,
                'unit_price': unit_price,
                'total_price': float(unit_price * qty),
                'status': 'dispensed',
                'dispensed': True,
            })
        if items_payload:
            payload.append({'id': prescription.id, 'items': items_payload})

    return jsonify(payload)


@app.route('/api/patient/<int:patient_id>/controlled-prescriptions')
@login_required
def api_patient_controlled_prescriptions(patient_id: int):
    # Allow both receptionist and pharmacist to access
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    cprescriptions = (
        ControlledPrescription.query
        .filter_by(patient_id=patient.id)
        .order_by(ControlledPrescription.created_at.desc())
        .all()
    )

    payload = []
    for cp in cprescriptions:
        items_payload = []
        for item in (cp.items or []):
            if getattr(item, 'status', None) != 'dispensed':
                continue
            drug = getattr(item, 'controlled_drug', None)
            if not drug:
                continue
            unit_price = float(getattr(drug, 'selling_price', 0) or 0)
            qty = int(getattr(item, 'quantity', 0) or 0)
            items_payload.append({
                'id': item.id,
                'drug_name': getattr(drug, 'name', None),
                'drug_number': getattr(drug, 'drug_number', None),
                'quantity': qty,
                'unit_price': unit_price,
                'total_price': float(unit_price * qty),
                'status': 'dispensed',
                'dispensed': True,
            })
        if items_payload:
            payload.append({'id': cp.id, 'items': items_payload})

    return jsonify(payload)


@app.route('/api/patient/<int:patient_id>/completed-labs')
@login_required
def api_patient_completed_labs(patient_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    try:
        lab_ids = {int(l.test_id) for l in (patient.labs or []) if getattr(l, 'test_id', None)}
    except Exception:
        lab_ids = set()

    if not lab_ids:
        return jsonify([])

    try:
        lab_keys = [f"LABTEST-{int(lid)}" for lid in lab_ids]
        rows = (
            db.session.query(SaleItem.individual_sale_number)
            .join(Sale, SaleItem.sale_id == Sale.id)
            .filter(Sale.patient_id == patient.id)
            .filter(SaleItem.individual_sale_number.in_(lab_keys))
            .all()
        )
        already_billed = {r[0] for r in rows if r and r[0]}
    except Exception:
        already_billed = set()

    out = []
    for lab in LabTest.query.filter(LabTest.id.in_(lab_ids)).order_by(LabTest.name).all():
        key = f"LABTEST-{int(lab.id)}"
        if key in already_billed:
            continue
        out.append({
            'lab_test_id': lab.id,
            'name': lab.name,
            'price': float(lab.price or 0),
        })

    return jsonify(out)


@app.route('/api/patient/<int:patient_id>/completed-imaging')
@login_required
def api_patient_completed_imaging(patient_id: int):
    user_role = str(current_user.role).lower().strip() if current_user.role else ''
    if user_role not in ('receptionist', 'pharmacist'):
        return jsonify({'error': 'Unauthorized'}), 403

    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    try:
        imaging_ids = {
            int(r.test_id) for r in (patient.imaging_requests or [])
            if getattr(r, 'test_id', None) and (getattr(r, 'status', None) or '').lower() not in ('cancelled', 'canceled')
        }
    except Exception:
        imaging_ids = set()

    if not imaging_ids:
        return jsonify([])

    try:
        img_keys = [f"IMGTEST-{int(iid)}" for iid in imaging_ids]
        rows = (
            db.session.query(SaleItem.individual_sale_number)
            .join(Sale, SaleItem.sale_id == Sale.id)
            .filter(Sale.patient_id == patient.id)
            .filter(SaleItem.individual_sale_number.in_(img_keys))
            .all()
        )
        already_billed = {r[0] for r in rows if r and r[0]}
    except Exception:
        already_billed = set()

    out = []
    for img in ImagingTest.query.filter(ImagingTest.id.in_(imaging_ids)).order_by(ImagingTest.name).all():
        key = f"IMGTEST-{int(img.id)}"
        if key in already_billed:
            continue
        out.append({
            'imaging_test_id': img.id,
            'name': img.name,
            'price': float(img.price or 0),
        })

    return jsonify(out)


@app.route('/api/patient/<int:patient_id>/ward-stay-preview')
@login_required
def api_patient_ward_stay_preview(patient_id: int):
    """Preview ward-stay charges due for the currently assigned bed.

    Returns a computed (not persisted) preview so the receptionist UI can show
    an auto-updating daily amount.
    """
    patient = _db_get(Patient, patient_id)
    if not patient:
        return jsonify({'error': 'Patient not found'}), 404

    ctx = _get_patient_bed_stay_context(patient.id)
    if not ctx:
        return jsonify({'assigned': False})

    daily_rate = float(ctx.get('daily_rate') or 0)
    start_date = ctx['start_date']
    end_date = ctx['end_date']

    last = (
        BedStayCharge.query
        .filter_by(bed_id=ctx['bed_id'], patient_id=patient.id)
        .order_by(BedStayCharge.charge_end_date.desc())
        .first()
    )
    last_end = last.charge_end_date if last else None
    if last_end:
        start_date = max(start_date, last_end + timedelta(days=1))

    if start_date <= end_date:
        days = (end_date - start_date).days + 1
    else:
        days = 0
    amount = float(days) * daily_rate

    return jsonify({
        'assigned': True,
        'ward_name': ctx['ward_name'],
        'bed_number': ctx['bed_number'],
        'daily_rate': daily_rate,
        'start_date': start_date.isoformat(),
        'end_date': end_date.isoformat(),
        'days': int(days),
        'amount': float(amount),
        'last_billed_through': last_end.isoformat() if last_end else None,
        'source': ctx.get('source'),
    })

@app.route('/api/lab-tests')
@login_required
def api_lab_tests():
    search = request.args.get('search', '')
    limit = request.args.get('limit', 10, type=int)
    
    query = LabTest.query
    if search:
        query = query.filter(LabTest.name.ilike(f'%{search}%'))
    
    tests = query.limit(limit).all()
    
    return jsonify([{
        'id': test.id,
        'name': test.name,
        'price': test.price,
        'description': test.description
    } for test in tests])

@app.route('/api/services')
@login_required
def api_services():
    search = request.args.get('search', '')
    limit = request.args.get('limit', 10, type=int)
    
    query = Service.query
    if search:
        query = query.filter(Service.name.ilike(f'%{search}%'))
    
    services = query.limit(limit).all()
    
    return jsonify([{
        'id': service.id,
        'name': service.name,
        'price': service.price,
        'description': service.description
    } for service in services])

@app.route('/static/js/sw.js')
def sw():
    return send_from_directory('static/js', 'sw.js')

@app.route('/favicon.ico')
def favicon():
    return send_from_directory('static', 'favicon.ico')


# Error handlers
@app.errorhandler(400)
def bad_request(e):
    return render_template('errors/400.html'), 400

@app.errorhandler(401)
def unauthorized(e):
    return render_template('errors/401.html'), 401

@app.errorhandler(403)
def forbidden(e):
    return render_template('errors/403.html'), 403

@app.errorhandler(404)
def page_not_found(e):
    return render_template('errors/404.html'), 404

@app.errorhandler(405)
def method_not_allowed(e):
    return render_template('errors/405.html'), 405

@app.errorhandler(500)
def internal_server_error(e):
    return render_template('errors/500.html'), 500


def initialize_database():
    """Ensure the database exists and all model tables are created.

    This is safe to run repeatedly: existing tables are left unchanged.
    """
    with app.app_context():
        try:
            # Ensure instance/ exists for the default SQLite path.
            try:
                os.makedirs(os.path.join(app.root_path, 'instance'), exist_ok=True)
            except Exception:
                pass

            # Skip detailed database checks in debug mode for faster startup
            if app.config.get('DEBUG'):
                db.create_all()
                return

            # Create only missing tables (db.create_all is idempotent).
            from sqlalchemy import inspect as sa_inspect

            engine = db.engine
            inspector = sa_inspect(engine)
            existing_tables = set(inspector.get_table_names())
            expected_tables = set(db.metadata.tables.keys())
            missing_tables = sorted(expected_tables - existing_tables)

            if missing_tables:
                db.create_all()
                app.logger.info(
                    "Database schema initialized/updated. Created %d missing tables.",
                    len(missing_tables),
                )
            else:
                app.logger.info(
                    "Database schema already up to date (%d tables).",
                    len(existing_tables),
                )

            # Ensure all tables/columns exist (runtime-safe migration for older DBs).
            created_tables, added_cols = _ensure_all_tables_and_columns(engine)
            if created_tables or added_cols:
                app.logger.info(
                    "Schema sync applied: created %d tables, added %d columns.",
                    created_tables,
                    added_cols,
                )
        except Exception:
            app.logger.exception('Database initialization failed')
            # In development/testing, fail fast so we don't start with a broken/empty schema.
            if app.config.get('DEBUG') or app.config.get('TESTING'):
                raise

app.register_blueprint(auth_bp, url_prefix='/auth')

# =================================================================================================
# INSURANCE ROUTES
# =================================================================================================

def admin_required(f):
    @wraps(f)
    def wrapper(*args, **kwargs):
        # Example: Only allow users with role 'admin'
        if not current_user.is_authenticated or getattr(current_user, 'role', None) != 'admin':
            flash('Admin access required.', 'danger')
            return redirect(url_for('home'))
        return f(*args, **kwargs)
    return wrapper

@app.route('/admin/insurance_providers')
@login_required
@admin_required
def insurance_providers():
    providers = InsuranceProvider.query.all()
    return render_template('admin/insurance_providers.html', providers=providers)

@app.route('/admin/insurance_providers/add', methods=['POST'])
@login_required
@admin_required
def add_insurance_provider():
    try:
        name = request.form.get('name')
        contact_person = request.form.get('contact_person')
        phone = request.form.get('phone')
        email = request.form.get('email')
        address = request.form.get('address')
        is_active = request.form.get('is_active') == 'true'

        if not name:
            return jsonify({'success': False, 'error': 'Provider name is required'}), 400

        new_provider = InsuranceProvider(
            name=name,
            contact_person=contact_person,
            phone=phone,
            email=email,
            address=address,
            is_active=is_active
        )
        db.session.add(new_provider)
        db.session.commit()
        
        # Return JSON for AJAX or redirect for regular form
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': True, 'message': 'Insurance provider added successfully'})
        
        flash('Insurance provider added successfully.', 'success')
        return redirect(url_for('insurance_providers'))
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': str(e)}), 500
        flash(f'Error adding provider: {str(e)}', 'danger')
        return redirect(url_for('insurance_providers'))

@app.route('/admin/insurance_providers/edit/<int:provider_id>', methods=['POST'])
@login_required
@admin_required
def edit_insurance_provider(provider_id):
    try:
        provider = _db_get_or_404(InsuranceProvider, provider_id)
        provider.name = request.form.get('name')
        provider.contact_person = request.form.get('contact_person')
        provider.phone = request.form.get('phone')
        provider.email = request.form.get('email')
        provider.address = request.form.get('address')
        provider.is_active = request.form.get('is_active') == 'true'

        if not provider.name:
            if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
                return jsonify({'success': False, 'error': 'Provider name is required'}), 400
            flash('Provider name is required.', 'danger')
            return redirect(url_for('insurance_providers'))

        db.session.commit()
        
        # Return JSON for AJAX or redirect for regular form
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': True, 'message': 'Insurance provider updated successfully'})
        
        flash('Insurance provider updated successfully.', 'success')
        return redirect(url_for('insurance_providers'))
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': str(e)}), 500
        flash(f'Error updating provider: {str(e)}', 'danger')
        return redirect(url_for('insurance_providers'))

@app.route('/admin/insurance_providers/delete/<int:provider_id>', methods=['POST'])
@app.route('/admin/delete_insurance-provider/<int:provider_id>', methods=['POST'])
@login_required
@admin_required
def delete_insurance_provider(provider_id):
    try:
        provider = _db_get_or_404(InsuranceProvider, provider_id)
        provider_name = provider.name
        db.session.delete(provider)
        db.session.commit()
        
        # Return JSON for AJAX or redirect for regular form
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': True, 'message': f'Insurance provider {provider_name} deleted successfully'})
        
        flash('Insurance provider deleted successfully.', 'success')
        return redirect(url_for('insurance_providers'))
    except Exception as e:
        db.session.rollback()
        if request.headers.get('X-CSRFToken') or 'application/json' in request.headers.get('Accept', ''):
            return jsonify({'success': False, 'error': str(e)}), 500
        flash(f'Error deleting provider: {str(e)}', 'danger')
        return redirect(url_for('insurance_providers'))

# =================================================================================================
# END INSURANCE ROUTES
# =================================================================================================

# =================================================================================================
# PATIENT INSURANCE POLICY ROUTES
# =================================================================================================

@app.route('/admin/patient_insurance')
@login_required
@admin_required
def patient_insurance():
    patient_insurances = PatientInsurance.query.all()
    patients = Patient.query.all()
    providers = InsuranceProvider.query.all()
    return render_template('admin/patient_insurance.html', 
                           patient_insurances=patient_insurances, 
                           patients=patients, 
                           providers=providers)

@app.route('/admin/patient_insurance/add', methods=['POST'])
@login_required
@admin_required
def add_patient_insurance():
    patient_id = request.form.get('patient_id')
    provider_id = request.form.get('provider_id')
    policy_number = request.form.get('policy_number')
    valid_from_str = request.form.get('valid_from')
    valid_to_str = request.form.get('valid_to')

    valid_from = datetime.strptime(valid_from_str, '%Y-%m-%d') if valid_from_str else None
    valid_to = datetime.strptime(valid_to_str, '%Y-%m-%d') if valid_to_str else None

    new_patient_insurance = PatientInsurance(
        patient_id=patient_id,
        provider_id=provider_id,
        policy_number=policy_number,
        valid_from=valid_from,
        valid_to=valid_to
    )
    db.session.add(new_patient_insurance)
    db.session.commit()
    flash('Patient insurance policy added successfully.', 'success')
    return redirect(url_for('patient_insurance'))

@app.route('/admin/patient_insurance/edit/<int:patient_insurance_id>', methods=['POST'])
@login_required
@admin_required
def edit_patient_insurance(patient_insurance_id):
    p_insurance = _db_get_or_404(PatientInsurance, patient_insurance_id)
    p_insurance.patient_id = request.form.get('patient_id')
    p_insurance.provider_id = request.form.get('provider_id')
    p_insurance.policy_number = request.form.get('policy_number')
    valid_from_str = request.form.get('valid_from')
    valid_to_str = request.form.get('valid_to')

    p_insurance.valid_from = datetime.strptime(valid_from_str, '%Y-%m-%d') if valid_from_str else None
    p_insurance.valid_to = datetime.strptime(valid_to_str, '%Y-%m-%d') if valid_to_str else None
    
    db.session.commit()
    flash('Patient insurance policy updated successfully.', 'success')
    return redirect(url_for('patient_insurance'))

@app.route('/admin/patient_insurance/delete/<int:patient_insurance_id>', methods=['POST'])
@login_required
@admin_required
def delete_patient_insurance(patient_insurance_id):
    p_insurance = _db_get_or_404(PatientInsurance, patient_insurance_id)
    db.session.delete(p_insurance)
    db.session.commit()
    flash('Patient insurance policy deleted successfully.', 'success')
    return redirect(url_for('patient_insurance'))

@app.route('/admin/claims')
@login_required
@admin_required
def claims():
    claims = Claim.query.all()
    patient_insurances = PatientInsurance.query.all()
    return render_template('admin/claims.html', claims=claims, patient_insurances=patient_insurances)

@app.route('/admin/claims/create', methods=['POST'])
@login_required
@admin_required
def create_claim():
    patient_insurance_id = request.form.get('patient_insurance_id')
    date_filed_str = request.form.get('date_filed')
    total_amount = request.form.get('total_amount')
    notes = request.form.get('notes')

    date_filed = datetime.strptime(date_filed_str, '%Y-%m-%d') if date_filed_str else get_eat_now()

    new_claim = Claim(
        patient_insurance_id=patient_insurance_id,
        date_filed=date_filed,
        total_amount=total_amount,
        status='Pending',
        notes=notes
    )
    db.session.add(new_claim)
    db.session.commit()
    flash('Claim created successfully.', 'success')
    return redirect(url_for('claims'))

@app.route('/admin/claims/update/<int:claim_id>', methods=['POST'])
@login_required
@admin_required
def update_claim(claim_id):
    claim = _db_get_or_404(Claim, claim_id)
    claim.total_amount = request.form.get('total_amount')
    claim.amount_paid = request.form.get('amount_paid') if request.form.get('amount_paid') else None
    date_paid_str = request.form.get('date_paid')
    claim.date_paid = datetime.strptime(date_paid_str, '%Y-%m-%d') if date_paid_str else None
    claim.status = request.form.get('status')
    claim.notes = request.form.get('notes')
    
    db.session.commit()
    flash('Claim updated successfully.', 'success')
    return redirect(url_for('claims'))

def generate_invoice_number():
    # Generate a unique invoice number, e.g., INV-YYYYMMDD-XXXX
    today_str = get_eat_now().strftime('%Y%m%d')
    last_invoice = Invoice.query.filter(Invoice.invoice_number.like(f"INV-{today_str}-%")).order_by(Invoice.invoice_number.desc()).first()
    if last_invoice:
        last_seq = int(last_invoice.invoice_number.split('-')[-1])
        new_seq = last_seq + 1
    else:
        new_seq = 1
    return f"INV-{today_str}-{new_seq:04d}"

@app.route('/admin/invoices')
@login_required
@admin_required
def invoices():
    invoices = Invoice.query.order_by(Invoice.date_issued.desc()).all()
    return render_template('admin/invoices.html', invoices=invoices)

@app.route('/admin/invoices/create', methods=['GET', 'POST'])
@login_required
@admin_required
def create_invoice():
    if request.method == 'POST':
        patient_id = request.form.get('patient_id')
        date_issued_str = request.form.get('date_issued')
        due_date_str = request.form.get('due_date')
        notes = request.form.get('notes')

        date_issued = datetime.strptime(date_issued_str, '%Y-%m-%d') if date_issued_str else get_eat_now()
        due_date = datetime.strptime(due_date_str, '%Y-%m-%d') if due_date_str else None

        total_amount = 0
        invoice_items_data = []
        descriptions = request.form.getlist('item_description')
        quantities = request.form.getlist('item_quantity')
        unit_prices = request.form.getlist('item_unit_price')

        for i in range(len(descriptions)):
            quantity = int(quantities[i])
            unit_price = Decimal(unit_prices[i])
            total_price = quantity * unit_price
            total_amount += total_price
            invoice_items_data.append({
                'description': descriptions[i],
                'quantity': quantity,
                'unit_price': unit_price,
                'total_price': total_price
            })

        new_invoice = Invoice(
            invoice_number=generate_invoice_number(),
            patient_id=patient_id,
            date_issued=date_issued,
            due_date=due_date,
            total_amount=total_amount,
            notes=notes
        )
        db.session.add(new_invoice)
        db.session.flush()

        for item_data in invoice_items_data:
            invoice_item = InvoiceItem(invoice_id=new_invoice.id, **item_data)
            db.session.add(invoice_item)

        db.session.commit()
        flash('Invoice created successfully.', 'success')
        return redirect(url_for('invoices'))

    patients = Patient.query.all()
    return render_template('admin/create_edit_invoice.html', patients=patients, invoice=None)

@app.route('/admin/invoices/edit/<int:invoice_id>', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_invoice(invoice_id):
    invoice = _db_get_or_404(Invoice, invoice_id)
    if request.method == 'POST':
        invoice.patient_id = request.form.get('patient_id')
        invoice.date_issued = datetime.strptime(request.form.get('date_issued'), '%Y-%m-%d')
        due_date_str = request.form.get('due_date')
        invoice.due_date = datetime.strptime(due_date_str, '%Y-%m-%d') if due_date_str else None
        invoice.notes = request.form.get('notes')

        # Clear existing items
        for item in invoice.items:
            db.session.delete(item)
        db.session.flush()

        total_amount = 0
        descriptions = request.form.getlist('item_description')
        quantities = request.form.getlist('item_quantity')
        unit_prices = request.form.getlist('item_unit_price')

        for i in range(len(descriptions)):
            quantity = int(quantities[i])
            unit_price = Decimal(unit_prices[i])
            total_price = quantity * unit_price
            total_amount += total_price
            
            invoice_item = InvoiceItem(
                invoice_id=invoice.id,
                description=descriptions[i],
                quantity=quantity,
                unit_price=unit_price,
                total_price=total_price
            )
            db.session.add(invoice_item)

        invoice.total_amount = total_amount
        db.session.commit()
        flash('Invoice updated successfully.', 'success')
        return redirect(url_for('invoices'))

    patients = Patient.query.all()
    return render_template('admin/create_edit_invoice.html', patients=patients, invoice=invoice)

@app.route('/admin/invoices/view/<int:invoice_id>')
@login_required
@admin_required
def view_invoice(invoice_id):
    invoice = _db_get_or_404(Invoice, invoice_id)
    return render_template('admin/view_invoice.html', invoice=invoice)

@app.route('/admin/invoices/delete/<int:invoice_id>', methods=['POST'])
@login_required
@admin_required
def delete_invoice(invoice_id):
    invoice = _db_get_or_404(Invoice, invoice_id)
    db.session.delete(invoice)
    db.session.commit()
    flash('Invoice deleted successfully.', 'success')
    return redirect(url_for('invoices'))


# =================================================================================================
# M-PESA (Safaricom Daraja) - Receive money via Till (Buy Goods)
#   - STK Push: auto-callback includes MpesaReceiptNumber
#   - Manual Till: if Safaricom pushes C2B confirmation callbacks for your shortcode, capture TransID
#     (Note: some setups don't send callbacks for pure Till payments; STK is the most reliable.)
# =================================================================================================

def _to_decimal_2dp(value) -> Decimal:
    try:
        d = Decimal(str(value))
    except Exception:
        d = Decimal('0')
    return d.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)


def _invoice_recalc_status(invoice: 'Invoice') -> None:
    total = _to_decimal_2dp(invoice.total_amount)
    paid = _to_decimal_2dp(invoice.paid_amount)
    if paid >= total and total > 0:
        invoice.status = 'paid'
        return
    # Keep overdue if already overdue, otherwise unpaid
    if invoice.status == 'overdue':
        return
    invoice.status = 'unpaid'


def _apply_payment_to_invoice(invoice: 'Invoice', amount: Decimal) -> None:
    if invoice.status == 'void':
        return
    invoice.paid_amount = _to_decimal_2dp(_to_decimal_2dp(invoice.paid_amount) + _to_decimal_2dp(amount))
    _invoice_recalc_status(invoice)


@app.post('/api/mpesa/stkpush')
@login_required
@roles_required_json('receptionist', 'pharmacist')
@limiter.limit('20/minute')
def mpesa_stkpush():
    """Initiate an STK Push (Till / Buy Goods).

    Body JSON:
      - phone_number: 07.. or 254..
      - amount: optional (defaults to invoice outstanding if invoice_number supplied)
      - invoice_number: optional (recommended)

    Returns Daraja response including CheckoutRequestID.
    """
    from utils.mpesa_daraja import (
        daraja_post_json,
        daraja_timestamp,
        generate_stk_password,
        get_access_token,
        normalize_msisdn_ke,
        safe_json_dumps,
    )

    data = request.get_json(silent=True) or {}
    phone = normalize_msisdn_ke(data.get('phone_number') or '')
    invoice_number = (data.get('invoice_number') or '').strip()

    if not phone:
        return jsonify({'error': 'phone_number is required and must be a valid KE number'}), 400

    till_shortcode = (app.config.get('MPESA_TILL_SHORTCODE') or '').strip()
    passkey = (app.config.get('MPESA_PASSKEY') or '').strip()
    callback_url = (app.config.get('MPESA_STK_CALLBACK_URL') or '').strip()
    consumer_key = (app.config.get('MPESA_CONSUMER_KEY') or '').strip()
    consumer_secret = (app.config.get('MPESA_CONSUMER_SECRET') or '').strip()
    base_url = (app.config.get('MPESA_BASE_URL') or '').strip()
    timeout = float(app.config.get('MPESA_HTTP_TIMEOUT') or 45.0)

    missing = [k for k, v in {
        'MPESA_TILL_SHORTCODE': till_shortcode,
        'MPESA_PASSKEY': passkey,
        'MPESA_STK_CALLBACK_URL': callback_url,
        'MPESA_CONSUMER_KEY': consumer_key,
        'MPESA_CONSUMER_SECRET': consumer_secret,
        'MPESA_BASE_URL': base_url,
    }.items() if not v]
    if missing:
        return jsonify({'error': 'M-Pesa is not configured', 'missing': missing}), 500

    invoice = None
    amount = data.get('amount')
    if invoice_number:
        invoice = Invoice.query.filter_by(invoice_number=invoice_number).first()
        if not invoice:
            return jsonify({'error': f'invoice_number not found: {invoice_number}'}), 404
        outstanding = _to_decimal_2dp(_to_decimal_2dp(invoice.total_amount) - _to_decimal_2dp(invoice.paid_amount))
        if amount is None or str(amount).strip() == '':
            amount = outstanding
        if _to_decimal_2dp(amount) <= 0:
            return jsonify({'error': 'Invoice has no outstanding balance'}), 400
    else:
        if amount is None or str(amount).strip() == '':
            return jsonify({'error': 'amount is required when invoice_number is not provided'}), 400

    amount_dec = _to_decimal_2dp(amount)
    if amount_dec <= 0:
        return jsonify({'error': 'amount must be > 0'}), 400

    timestamp = daraja_timestamp(get_eat_now())
    password = generate_stk_password(till_shortcode, passkey, timestamp)

    payment = MpesaPayment(
        source='stk',
        status='pending',
        invoice_id=invoice.id if invoice else None,
        invoice_number=invoice.invoice_number if invoice else (invoice_number or None),
        initiated_by_user_id=int(current_user.id),
        phone_number=phone,
        amount_expected=amount_dec,
        raw_payload=safe_json_dumps({'request': data}),
    )
    db.session.add(payment)
    db.session.flush()

    # Create a high-level PaymentIntent + ProviderTxn anchor (best-effort; does not block).
    payment_intent = None
    provider_txn = None
    try:
        if _payment_intents_supported():
            payment_intent = _create_payment_intent(
                direction='IN',
                intent_type='STK_C2B',
                amount=amount_dec,
                currency='KES',
                reference=invoice.invoice_number if invoice else (invoice_number or f"MPESA-{payment.id}"),
                invoice=invoice,
                initiated_by_user_id=int(current_user.id),
                status='pending',
                notes='STK push initiated',
            )
    except Exception:
        payment_intent = None

    body = {
        'BusinessShortCode': till_shortcode,
        'Password': password,
        'Timestamp': timestamp,
        'TransactionType': 'CustomerBuyGoodsOnline',
        'Amount': int(amount_dec),
        'PartyA': phone,
        'PartyB': till_shortcode,
        'PhoneNumber': phone,
        'CallBackURL': callback_url,
        'AccountReference': invoice.invoice_number if invoice else (invoice_number or f'MPESA-{payment.id}'),
        'TransactionDesc': f'Clinic payment {invoice.invoice_number}' if invoice else 'Clinic payment',
    }

    try:
        if payment_intent is not None and database_has_table('mpesa_provider_txns'):
            provider_txn = _create_mpesa_provider_txn(
                payment_intent_id=int(payment_intent.id),
                direction='IN',
                provider_action='stk_push',
                status='pending',
                raw_request=safe_json_dumps(body),
            )
            _maybe_set_link_fields(payment, payment_intent_id=int(payment_intent.id), provider_txn_id=int(provider_txn.id) if provider_txn else None)
            db.session.add(payment)
            db.session.flush()
    except Exception:
        provider_txn = None

    try:
        token = get_access_token(base_url=base_url, consumer_key=consumer_key, consumer_secret=consumer_secret, timeout=timeout)
        resp = daraja_post_json(base_url=base_url, path='/mpesa/stkpush/v1/processrequest', token=token, json_body=body, timeout=timeout)
    except Exception as e:
        app.logger.exception('STK push failed')
        payment.status = 'failed'
        payment.result_desc = str(e)[:250]
        db.session.commit()
        return jsonify({'error': 'STK push failed', 'detail': str(e)}), 502

    payment.merchant_request_id = (resp.get('MerchantRequestID') or None)
    payment.checkout_request_id = (resp.get('CheckoutRequestID') or None)
    payment.result_desc = (resp.get('ResponseDescription') or resp.get('CustomerMessage') or None)

    try:
        if provider_txn is not None:
            _maybe_set_link_fields(
                provider_txn,
                merchant_request_id=payment.merchant_request_id,
                checkout_request_id=payment.checkout_request_id,
            )
            db.session.add(provider_txn)
    except Exception:
        pass
    db.session.commit()

    return jsonify({'ok': True, 'daraja': resp, 'payment_id': payment.id}), 200


@app.post('/api/mpesa/stk/callback')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_stk_callback():
    from utils.mpesa_daraja import parse_stk_callback, safe_json_dumps

    payload = request.get_json(silent=True) or {}
    parsed = parse_stk_callback(payload)

    checkout_id = (parsed.get('checkout_request_id') or '').strip()
    merchant_id = (parsed.get('merchant_request_id') or '').strip()
    result_code = parsed.get('result_code')
    result_desc = parsed.get('result_desc')

    payment = None
    if checkout_id:
        payment = MpesaPayment.query.filter_by(checkout_request_id=checkout_id).first()
    if not payment and merchant_id:
        payment = MpesaPayment.query.filter_by(merchant_request_id=merchant_id).first()
    if not payment:
        payment = MpesaPayment(source='stk', status='pending')
        db.session.add(payment)

    payment.raw_payload = safe_json_dumps(payload)
    payment.checkout_request_id = checkout_id or payment.checkout_request_id
    payment.merchant_request_id = merchant_id or payment.merchant_request_id
    try:
        payment.result_code = int(result_code) if result_code is not None else None
    except Exception:
        payment.result_code = None
    payment.result_desc = (result_desc or '')[:250] if result_desc else None

    if payment.result_code == 0:
        receipt = (parsed.get('mpesa_receipt_number') or '').strip() or None
        payment.mpesa_receipt_number = payment.mpesa_receipt_number or receipt
        payment.phone_number = payment.phone_number or (parsed.get('phone_number') or None)
        if parsed.get('amount') is not None:
            payment.amount_received = _to_decimal_2dp(parsed.get('amount'))
        payment.status = 'success'

        # Update intent/provider txn (best-effort)
        try:
            if _payment_intents_supported():
                provider_txn = None
                if getattr(payment, 'provider_txn_id', None):
                    provider_txn = _db_get(MpesaProviderTxn, int(payment.provider_txn_id))
                if not provider_txn and checkout_id:
                    provider_txn = MpesaProviderTxn.query.filter_by(checkout_request_id=checkout_id).first()
                if not provider_txn and merchant_id:
                    provider_txn = MpesaProviderTxn.query.filter_by(merchant_request_id=merchant_id).first()
                if provider_txn:
                    provider_txn.status = 'success'
                    provider_txn.mpesa_receipt_number = provider_txn.mpesa_receipt_number or payment.mpesa_receipt_number
                    provider_txn.result_code = 0
                    provider_txn.result_desc = (payment.result_desc or provider_txn.result_desc)
                    provider_txn.raw_callback = safe_json_dumps(payload)
                    provider_txn.callback_received_at = provider_txn.callback_received_at or get_eat_now()
                    provider_txn.completed_at = provider_txn.completed_at or get_eat_now()
                    db.session.add(provider_txn)
                    _maybe_set_link_fields(payment, provider_txn_id=int(provider_txn.id), payment_intent_id=int(provider_txn.payment_intent_id))

                    pi = _db_get(PaymentIntent, int(provider_txn.payment_intent_id)) if getattr(provider_txn, 'payment_intent_id', None) else None
                    if pi:
                        pi.status = 'success'
                        db.session.add(pi)
        except Exception:
            pass

        # Auto-post to invoice if linked
        if payment.invoice_id:
            invoice = _db_get(Invoice, payment.invoice_id)
            if invoice and payment.amount_received:
                _apply_payment_to_invoice(invoice, _to_decimal_2dp(payment.amount_received))

        # Ledger transaction (only if we know who initiated the request)
        if payment.initiated_by_user_id and payment.amount_received:
            tx_exists = None
            if payment.mpesa_receipt_number:
                tx_exists = Transaction.query.filter(
                    Transaction.payment_method == 'mpesa',
                    Transaction.notes.ilike(f"%{payment.mpesa_receipt_number}%"),
                ).first()
            if not tx_exists:
                tx = Transaction(
                    transaction_number=generate_transaction_number(),
                    transaction_type='payment',
                    amount=float(_to_decimal_2dp(payment.amount_received)),
                    user_id=int(payment.initiated_by_user_id),
                    reference_id=int(payment.invoice_id) if payment.invoice_id else None,
                    reference_table='invoices' if payment.invoice_id else None,
                    payment_intent_id=getattr(payment, 'payment_intent_id', None),
                    provider_txn_id=getattr(payment, 'provider_txn_id', None),
                    direction='IN',
                    status='posted',
                    payer=str(payment.phone_number or ''),
                    payment_method='mpesa',
                    notes=f"M-Pesa receipt: {payment.mpesa_receipt_number}" if payment.mpesa_receipt_number else 'M-Pesa payment',
                    receipt_number=payment.invoice_number if payment.invoice_number else None,
                )
                db.session.add(tx)

                # Store a printable receipt for admin/reprint workflows
                try:
                    payer_name = None
                    purpose = None
                    if payment.invoice_id:
                        inv = _db_get(Invoice, payment.invoice_id)
                        if inv:
                            purpose = f"Invoice {getattr(inv, 'invoice_number', '')}".strip()
                            try:
                                patient = _db_get(Patient, inv.patient_id) if getattr(inv, 'patient_id', None) else None
                                if patient:
                                    payer_name = getattr(patient, 'full_name', None) or getattr(patient, 'name', None) or None
                            except Exception:
                                payer_name = None

                    receipt_html = _build_mpesa_receipt_html(
                        receipt_title='Reception Payment Receipt',
                        direction='IN',
                        clinic_txn_code=getattr(tx, 'clinic_transaction_code', None) or tx.transaction_number,
                        mpesa_code=payment.mpesa_receipt_number,
                        party_label='Payer',
                        party_name=payer_name,
                        party_phone=payment.phone_number,
                        amount=_to_decimal_2dp(payment.amount_received),
                        currency='KES',
                        purpose=purpose,
                        served_by_user_id=int(payment.initiated_by_user_id) if payment.initiated_by_user_id else None,
                        created_at=get_eat_now(),
                    )
                    _ensure_transaction_receipt(tx, receipt_html, prefix='PAY', force=True)
                except Exception:
                    pass
    else:
        payment.status = 'failed'

        try:
            if _payment_intents_supported():
                provider_txn = None
                if getattr(payment, 'provider_txn_id', None):
                    provider_txn = _db_get(MpesaProviderTxn, int(payment.provider_txn_id))
                if not provider_txn and checkout_id:
                    provider_txn = MpesaProviderTxn.query.filter_by(checkout_request_id=checkout_id).first()
                if not provider_txn and merchant_id:
                    provider_txn = MpesaProviderTxn.query.filter_by(merchant_request_id=merchant_id).first()
                if provider_txn:
                    provider_txn.status = 'failed'
                    provider_txn.result_code = int(payment.result_code) if payment.result_code is not None else None
                    provider_txn.result_desc = (payment.result_desc or provider_txn.result_desc)
                    provider_txn.raw_callback = safe_json_dumps(payload)
                    provider_txn.callback_received_at = provider_txn.callback_received_at or get_eat_now()
                    provider_txn.completed_at = provider_txn.completed_at or get_eat_now()
                    db.session.add(provider_txn)

                    pi = _db_get(PaymentIntent, int(provider_txn.payment_intent_id)) if getattr(provider_txn, 'payment_intent_id', None) else None
                    if pi:
                        pi.status = 'failed'
                        db.session.add(pi)
        except Exception:
            pass

    db.session.commit()
    # Safaricom expects 200 OK; body not strictly required
    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


@app.post('/api/mpesa/c2b/validation')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_c2b_validation():
    """C2B validation endpoint.

    For most clinics, accept all and validate later. You can enforce shortcode checks here.
    """
    payload = request.get_json(silent=True) or {}
    short_code = (payload.get('BusinessShortCode') or payload.get('ShortCode') or '').strip()
    expected = (app.config.get('MPESA_TILL_SHORTCODE') or '').strip()

    if expected and short_code and short_code != expected:
        return jsonify({'ResultCode': 1, 'ResultDesc': 'Rejected: invalid shortcode'}), 200
    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


@app.post('/api/mpesa/c2b/confirmation')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_c2b_confirmation():
    """C2B confirmation endpoint.

    NOTE: Depending on your Safaricom setup, pure Till (Buy Goods) manual payments may not trigger these callbacks.
    STK Push is the recommended reliable flow.
    """
    from utils.mpesa_daraja import parse_c2b_payload, safe_json_dumps

    payload = request.get_json(silent=True) or {}
    parsed = parse_c2b_payload(payload)

    receipt = parsed.get('trans_id')
    existing = MpesaPayment.query.filter_by(mpesa_receipt_number=receipt).first() if receipt else None
    if existing:
        # idempotent replay
        return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200

    bill_ref = (parsed.get('bill_ref') or '').strip() or None
    invoice = Invoice.query.filter_by(invoice_number=bill_ref).first() if bill_ref else None

    payment = MpesaPayment(
        source='c2b',
        status='success',
        invoice_id=invoice.id if invoice else None,
        invoice_number=invoice.invoice_number if invoice else bill_ref,
        phone_number=parsed.get('msisdn'),
        amount_received=_to_decimal_2dp(parsed.get('amount')) if parsed.get('amount') is not None else None,
        mpesa_receipt_number=receipt,
        bill_ref_number=bill_ref,
        trans_time=parsed.get('trans_time'),
        business_short_code=parsed.get('short_code'),
        raw_payload=safe_json_dumps(payload),
    )
    db.session.add(payment)

    # Anchor to PaymentIntent/ProviderTxn (best-effort)
    try:
        if _payment_intents_supported() and payment.amount_received:
            pi = _create_payment_intent(
                direction='IN',
                intent_type='MANUAL_TILL',
                amount=_to_decimal_2dp(payment.amount_received),
                currency='KES',
                reference=invoice.invoice_number if invoice else (bill_ref or receipt),
                invoice=invoice,
                initiated_by_user_id=None,
                status='success',
                notes='C2B confirmation received',
            )
            ptxn = _create_mpesa_provider_txn(
                payment_intent_id=int(pi.id),
                direction='IN',
                provider_action='c2b_confirmation',
                status='success',
                mpesa_receipt_number=receipt,
                result_code=0,
                result_desc='C2B confirmation',
                raw_callback=safe_json_dumps(payload),
            )
            _maybe_set_link_fields(payment, payment_intent_id=int(pi.id), provider_txn_id=int(ptxn.id) if ptxn else None)
    except Exception:
        pass

    if invoice and payment.amount_received:
        _apply_payment_to_invoice(invoice, _to_decimal_2dp(payment.amount_received))

        # Post to ledger as IN (best-effort). For manual Till, we attribute to a "system" user if none.
        try:
            system_user_id = app.config.get('MPESA_SYSTEM_USER_ID')
            if not system_user_id:
                # If you want ledger posting for webhooks, set MPESA_SYSTEM_USER_ID to an existing admin user id.
                system_user_id = None

            if not system_user_id:
                raise RuntimeError('MPESA_SYSTEM_USER_ID not set')

            tx = Transaction(
                transaction_number=generate_transaction_number(),
                transaction_type='payment',
                amount=float(_to_decimal_2dp(payment.amount_received)),
                user_id=int(system_user_id),
                reference_id=int(invoice.id),
                notes=f"Manual Till payment. M-Pesa receipt: {payment.mpesa_receipt_number}",
                created_at=get_eat_now(),
            )
            _maybe_set_transaction_meta(
                tx,
                reference_table='invoices',
                direction='IN',
                status='posted',
                payment_method='mpesa',
                payer=str(payment.phone_number or ''),
            )
            _maybe_set_link_fields(
                tx,
                payment_intent_id=getattr(payment, 'payment_intent_id', None),
                provider_txn_id=getattr(payment, 'provider_txn_id', None),
            )
            db.session.add(tx)

            # Receipt HTML
            try:
                purpose = f"Invoice {getattr(invoice, 'invoice_number', '')}".strip() if invoice else None
                receipt_html = _build_mpesa_receipt_html(
                    receipt_title='Reception Payment Receipt',
                    direction='IN',
                    clinic_txn_code=getattr(tx, 'clinic_transaction_code', None) or tx.transaction_number,
                    mpesa_code=payment.mpesa_receipt_number,
                    party_label='Payer',
                    party_name=None,
                    party_phone=payment.phone_number,
                    amount=_to_decimal_2dp(payment.amount_received),
                    currency='KES',
                    purpose=purpose,
                    served_by_user_id=int(system_user_id) if system_user_id else None,
                    served_by_label='SYSTEM' if not system_user_id else None,
                    created_at=get_eat_now(),
                )
                _ensure_transaction_receipt(tx, receipt_html, prefix='PAY', force=True)
            except Exception:
                pass
        except Exception:
            pass

    db.session.commit()
    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


def _daraja_extract_result(payload: dict) -> dict:
    """Best-effort extraction for Daraja async callbacks (B2C/B2B/TxnStatus/etc)."""
    result = payload.get('Result') or payload.get('result') or {}
    out = {
        'conversation_id': result.get('ConversationID') or result.get('conversationID') or payload.get('ConversationID'),
        'originator_conversation_id': result.get('OriginatorConversationID') or result.get('originatorConversationID') or payload.get('OriginatorConversationID'),
        'result_code': result.get('ResultCode'),
        'result_desc': result.get('ResultDesc') or result.get('ResultDescription'),
        'transaction_id': None,
    }

    try:
        params = (result.get('ResultParameters') or {}).get('ResultParameter') or []
        for p in params:
            key = (p.get('Key') or '').strip()
            val = p.get('Value')
            if not key:
                continue
            if key in {'TransactionID', 'TransID', 'ReceiptNo', 'TransactionReceipt'}:
                out['transaction_id'] = str(val) if val is not None else None
                break
    except Exception:
        pass
    return out


@app.post('/api/mpesa/transaction-status/query')
@login_required
@roles_required_json('receptionist', 'pharmacist', 'admin')
@limiter.limit('20/minute')
def mpesa_transaction_status_query():
    """Request a Daraja Transaction Status query for an M-Pesa receipt code.

    Use this as a fallback when manual Till payments don't trigger C2B confirmations.

    Body JSON:
      - mpesa_code (required): e.g. QAB123XYZ
      - invoice_number (optional)
      - amount (optional): amount you expect to post if verified
      - phone_number (optional)
    """
    data = request.get_json(silent=True) or {}
    ok, result = _mpesa_initiate_transaction_status_query(data, requested_by_user_id=int(current_user.id))
    if not ok:
        return jsonify(result), int(result.get('_status') or 400)
    return jsonify(result), 200


def _mpesa_initiate_transaction_status_query(data: dict, requested_by_user_id: int) -> tuple[bool, dict]:
    """Shared implementation for Transaction Status query (used by JSON API + admin dashboard)."""
    from utils.mpesa_daraja import (
        daraja_post_json,
        get_access_token,
        normalize_msisdn_ke,
        safe_json_dumps,
    )

    if not database_has_table('mpesa_txn_status_queries'):
        return False, {'error': 'M-Pesa tables not ready. Run migrations.', '_status': 500}

    mpesa_code = (data.get('mpesa_code') or '').strip().upper()
    invoice_number = (data.get('invoice_number') or '').strip()
    phone = normalize_msisdn_ke(data.get('phone_number') or '') if data.get('phone_number') else None
    amount = data.get('amount')

    if not mpesa_code:
        return False, {'error': 'mpesa_code is required', '_status': 400}

    # Avoid duplicate queries for the same code (best-effort)
    existing = MpesaTransactionStatusQuery.query.filter_by(transaction_id=mpesa_code).order_by(MpesaTransactionStatusQuery.id.desc()).first()
    if existing and existing.status == 'pending':
        return True, {'ok': True, 'query_id': existing.id, 'status': existing.status}

    initiator = (app.config.get('MPESA_INITIATOR_NAME') or '').strip()
    sec_cred = (app.config.get('MPESA_SECURITY_CREDENTIAL') or '').strip()
    party_a = (app.config.get('MPESA_OUTGOING_SHORTCODE') or '').strip()
    result_url = (app.config.get('MPESA_TRANSACTION_STATUS_RESULT_URL') or '').strip()
    timeout_url = (app.config.get('MPESA_TRANSACTION_STATUS_TIMEOUT_URL') or '').strip()
    endpoint = (app.config.get('MPESA_TRANSACTION_STATUS_ENDPOINT') or '').strip()

    consumer_key = (app.config.get('MPESA_CONSUMER_KEY') or '').strip()
    consumer_secret = (app.config.get('MPESA_CONSUMER_SECRET') or '').strip()
    base_url = (app.config.get('MPESA_BASE_URL') or '').strip()
    timeout = float(app.config.get('MPESA_HTTP_TIMEOUT') or 45.0)

    missing = [k for k, v in {
        'MPESA_INITIATOR_NAME': initiator,
        'MPESA_SECURITY_CREDENTIAL': sec_cred,
        'MPESA_OUTGOING_SHORTCODE': party_a,
        'MPESA_TRANSACTION_STATUS_RESULT_URL': result_url,
        'MPESA_TRANSACTION_STATUS_TIMEOUT_URL': timeout_url,
        'MPESA_TRANSACTION_STATUS_ENDPOINT': endpoint,
        'MPESA_CONSUMER_KEY': consumer_key,
        'MPESA_CONSUMER_SECRET': consumer_secret,
        'MPESA_BASE_URL': base_url,
    }.items() if not v]
    if missing:
        return False, {'error': 'M-Pesa Transaction Status is not configured', 'missing': missing, '_status': 500}

    invoice = Invoice.query.filter_by(invoice_number=invoice_number).first() if invoice_number else None
    if invoice_number and not invoice:
        return False, {'error': f'invoice_number not found: {invoice_number}', '_status': 404}

    amount_dec = _to_decimal_2dp(amount) if amount is not None and str(amount).strip() != '' else None
    if invoice and amount_dec is None:
        outstanding = _to_decimal_2dp(_to_decimal_2dp(invoice.total_amount) - _to_decimal_2dp(invoice.paid_amount))
        amount_dec = outstanding if outstanding > 0 else None

    body = {
        'Initiator': initiator,
        'SecurityCredential': sec_cred,
        'CommandID': 'TransactionStatusQuery',
        'TransactionID': mpesa_code,
        'PartyA': party_a,
        'IdentifierType': 4,
        'ResultURL': result_url,
        'QueueTimeOutURL': timeout_url,
        'Remarks': f'Verify manual Till for {invoice_number}' if invoice_number else 'Verify manual Till',
        'Occasion': invoice_number or '',
    }

    # PaymentIntent + ProviderTxn anchor (best-effort)
    pi = None
    ptxn = None
    try:
        if _payment_intents_supported():
            pi = _create_payment_intent(
                direction='IN',
                intent_type='MANUAL_TILL',
                amount=_to_decimal_2dp(amount_dec) if amount_dec is not None else Decimal('0.00'),
                currency='KES',
                reference=invoice.invoice_number if invoice else (invoice_number or mpesa_code),
                invoice=invoice,
                initiated_by_user_id=int(requested_by_user_id),
                status='pending',
                notes=f"Transaction status query for {mpesa_code}",
            )
            if pi is not None:
                ptxn = _create_mpesa_provider_txn(
                    payment_intent_id=int(pi.id),
                    direction='IN',
                    provider_action='txn_status_query',
                    status='pending',
                    mpesa_receipt_number=mpesa_code,
                    raw_request=safe_json_dumps(body),
                )
    except Exception:
        pi = None
        ptxn = None

    q = MpesaTransactionStatusQuery(
        transaction_id=mpesa_code,
        status='pending',
        requested_by_user_id=int(requested_by_user_id),
        invoice_id=invoice.id if invoice else None,
        invoice_number=invoice.invoice_number if invoice else (invoice_number or None),
        amount_expected=amount_dec,
        payer_phone_number=phone,
        raw_request=safe_json_dumps(body),
        payment_intent_id=int(pi.id) if pi else None,
        provider_txn_id=int(ptxn.id) if ptxn else None,
    )
    db.session.add(q)
    db.session.flush()

    try:
        token = get_access_token(base_url=base_url, consumer_key=consumer_key, consumer_secret=consumer_secret, timeout=timeout)
        resp = daraja_post_json(base_url=base_url, path=endpoint, token=token, json_body=body, timeout=timeout)
    except Exception as e:
        app.logger.exception('Transaction status query failed')
        q.status = 'failed'
        q.result_desc = str(e)[:250]
        db.session.commit()
        return False, {'error': 'Transaction status query failed', 'detail': str(e), '_status': 502}

    q.conversation_id = resp.get('ConversationID') or resp.get('ConversationId') or q.conversation_id
    q.originator_conversation_id = resp.get('OriginatorConversationID') or resp.get('OriginatorConversationId') or q.originator_conversation_id
    q.result_desc = (resp.get('ResponseDescription') or q.result_desc)
    q.raw_result = safe_json_dumps(resp)

    try:
        if ptxn is not None:
            _maybe_set_link_fields(
                ptxn,
                conversation_id=q.conversation_id,
                originator_conversation_id=q.originator_conversation_id,
                result_desc=(resp.get('ResponseDescription') or None),
            )
            db.session.add(ptxn)
    except Exception:
        pass
    db.session.commit()

    return True, {'ok': True, 'query_id': q.id, 'daraja': resp}


@app.post('/api/mpesa/transaction-status/result')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_transaction_status_result():
    from utils.mpesa_daraja import safe_json_dumps

    payload = request.get_json(silent=True) or {}
    extracted = _daraja_extract_result(payload)

    q = None
    oid = (extracted.get('originator_conversation_id') or '').strip()
    cid = (extracted.get('conversation_id') or '').strip()
    if oid:
        q = MpesaTransactionStatusQuery.query.filter_by(originator_conversation_id=oid).first()
    if not q and cid:
        q = MpesaTransactionStatusQuery.query.filter_by(conversation_id=cid).first()

    # Always accept callback even if we can't match
    if not q:
        return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200

    q.raw_result = safe_json_dumps(payload)
    try:
        q.result_code = int(extracted.get('result_code')) if extracted.get('result_code') is not None else None
    except Exception:
        q.result_code = None
    q.result_desc = (extracted.get('result_desc') or '')[:250] if extracted.get('result_desc') else None

    # Update canonical ProviderTxn/PaymentIntent (best-effort)
    try:
        if _payment_intents_supported():
            if getattr(q, 'provider_txn_id', None):
                ptxn = _db_get(MpesaProviderTxn, int(q.provider_txn_id))
                if ptxn:
                    _maybe_set_link_fields(
                        ptxn,
                        status='success' if q.result_code == 0 else 'failed',
                        result_code=q.result_code,
                        result_desc=q.result_desc,
                        raw_callback=q.raw_result,
                    )
                    db.session.add(ptxn)
            if getattr(q, 'payment_intent_id', None):
                pi = _db_get(PaymentIntent, int(q.payment_intent_id))
                if pi:
                    pi.status = 'success' if q.result_code == 0 else 'failed'
                    pi.updated_at = get_eat_now()
                    db.session.add(pi)
    except Exception:
        pass

    if q.result_code == 0:
        q.status = 'success'

        # If we can post, do it idempotently.
        invoice = _db_get(Invoice, q.invoice_id) if q.invoice_id else None
        amount = _to_decimal_2dp(q.amount_expected) if q.amount_expected is not None else None

        if invoice and amount and amount > 0:
            # Avoid duplicate MpesaPayment/Transaction for same code
            already = MpesaPayment.query.filter_by(mpesa_receipt_number=q.transaction_id).first()
            if not already:
                mp = MpesaPayment(
                    source='c2b_verify',
                    status='success',
                    invoice_id=invoice.id,
                    invoice_number=invoice.invoice_number,
                    phone_number=q.payer_phone_number,
                    amount_received=amount,
                    mpesa_receipt_number=q.transaction_id,
                    bill_ref_number=invoice.invoice_number,
                    raw_payload=q.raw_result,
                    initiated_by_user_id=q.requested_by_user_id,
                )
                _maybe_set_link_fields(
                    mp,
                    payment_intent_id=getattr(q, 'payment_intent_id', None),
                    provider_txn_id=getattr(q, 'provider_txn_id', None),
                )
                db.session.add(mp)

            _apply_payment_to_invoice(invoice, amount)

            tx = Transaction.query.filter_by(reference_table='mpesa_txn_status_queries', reference_id=q.id).first()
            if not tx:
                tx = Transaction(
                    transaction_number=generate_transaction_number(),
                    transaction_type='payment',
                    amount=float(amount),
                    user_id=int(q.requested_by_user_id),
                    reference_id=int(q.id),
                    notes=f"Manual Till verified. M-Pesa receipt: {q.transaction_id}. Invoice: {invoice.invoice_number}",
                    created_at=get_eat_now(),
                )
                _maybe_set_transaction_meta(
                    tx,
                    reference_table='mpesa_txn_status_queries',
                    direction='IN',
                    status='posted',
                    payment_method='mpesa',
                    payer=str(q.payer_phone_number or ''),
                )
                _maybe_set_link_fields(
                    tx,
                    payment_intent_id=getattr(q, 'payment_intent_id', None),
                    provider_txn_id=getattr(q, 'provider_txn_id', None),
                )
                db.session.add(tx)

                try:
                    receipt_html = _build_mpesa_receipt_html(
                        receipt_title='Reception Payment Receipt',
                        direction='IN',
                        clinic_txn_code=getattr(tx, 'clinic_transaction_code', None) or tx.transaction_number,
                        mpesa_code=q.transaction_id,
                        party_label='Payer',
                        party_name=None,
                        party_phone=q.payer_phone_number,
                        amount=amount,
                        currency='KES',
                        purpose=f"Invoice {invoice.invoice_number}",
                        served_by_user_id=int(q.requested_by_user_id) if q.requested_by_user_id else None,
                        created_at=get_eat_now(),
                    )
                    _ensure_transaction_receipt(tx, receipt_html, prefix='PAY', force=True)
                except Exception:
                    pass
    else:
        q.status = 'failed'

    db.session.commit()
    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


@app.post('/api/mpesa/transaction-status/timeout')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_transaction_status_timeout():
    from utils.mpesa_daraja import safe_json_dumps

    payload = request.get_json(silent=True) or {}
    extracted = _daraja_extract_result(payload)
    oid = (extracted.get('originator_conversation_id') or '').strip()
    cid = (extracted.get('conversation_id') or '').strip()

    q = None
    if oid:
        q = MpesaTransactionStatusQuery.query.filter_by(originator_conversation_id=oid).first()
    if not q and cid:
        q = MpesaTransactionStatusQuery.query.filter_by(conversation_id=cid).first()
    if q:
        q.status = 'failed'
        q.raw_result = safe_json_dumps(payload)
        q.result_desc = (q.result_desc or 'Timeout')[:250]

        # Update canonical ProviderTxn/PaymentIntent (best-effort)
        try:
            if _payment_intents_supported():
                if getattr(q, 'provider_txn_id', None):
                    ptxn = _db_get(MpesaProviderTxn, int(q.provider_txn_id))
                    if ptxn:
                        _maybe_set_link_fields(
                            ptxn,
                            status='failed',
                            result_desc=(q.result_desc or 'Timeout')[:250],
                            raw_callback=q.raw_result,
                        )
                        db.session.add(ptxn)
                if getattr(q, 'payment_intent_id', None):
                    pi = _db_get(PaymentIntent, int(q.payment_intent_id))
                    if pi:
                        pi.status = 'failed'
                        pi.updated_at = get_eat_now()
                        db.session.add(pi)
        except Exception:
            pass
        db.session.commit()

    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


def _mpesa_outgoing_common_config():
    initiator = (app.config.get('MPESA_INITIATOR_NAME') or '').strip()
    sec_cred = (app.config.get('MPESA_SECURITY_CREDENTIAL') or '').strip()
    party_a = (app.config.get('MPESA_OUTGOING_SHORTCODE') or '').strip()
    consumer_key = (app.config.get('MPESA_CONSUMER_KEY') or '').strip()
    consumer_secret = (app.config.get('MPESA_CONSUMER_SECRET') or '').strip()
    base_url = (app.config.get('MPESA_BASE_URL') or '').strip()
    timeout = float(app.config.get('MPESA_HTTP_TIMEOUT') or 45.0)
    return {
        'initiator': initiator,
        'security_credential': sec_cred,
        'party_a': party_a,
        'consumer_key': consumer_key,
        'consumer_secret': consumer_secret,
        'base_url': base_url,
        'timeout': timeout,
    }


def _post_mpesa_payout_receipt(tx: 'Transaction', payout: 'MpesaPayout') -> None:
    try:
        beneficiary = (
            payout.beneficiary_msisdn
            or payout.beneficiary_paybill
            or payout.beneficiary_till
            or payout.beneficiary_pochi
            or ''
        )
        receipt_html = _build_mpesa_receipt_html(
            receipt_title='Outgoing Payment Receipt (Admin)',
            direction='OUT',
            clinic_txn_code=getattr(tx, 'clinic_transaction_code', None) or tx.transaction_number,
            mpesa_code=payout.mpesa_transaction_id,
            party_label='Beneficiary',
            party_name=None,
            party_phone=(payout.beneficiary_msisdn or payout.beneficiary_pochi),
            amount=_to_decimal_2dp(payout.amount),
            currency='KES',
            purpose=f"M-Pesa payout ({payout.payout_type})",
            extra_lines=[
                (f"Beneficiary: {beneficiary}" if beneficiary else ""),
                (f"Remarks: {payout.remarks}" if payout.remarks else ""),
            ],
            served_by_user_id=int(payout.initiated_by_user_id) if payout.initiated_by_user_id else None,
            created_at=get_eat_now(),
        )
        _ensure_transaction_receipt(tx, receipt_html, prefix='PAY', force=True)
    except Exception:
        pass


@app.post('/api/mpesa/payout/b2c')
@login_required
@roles_required_json('admin')
@limiter.limit('10/minute')
def mpesa_payout_b2c():
    """Admin: Send money to a phone number (B2C)."""
    data = request.get_json(silent=True) or {}
    ok, result = _mpesa_initiate_payout_b2c(data, initiated_by_user_id=int(current_user.id))
    if not ok:
        return jsonify(result), int(result.get('_status') or 400)
    return jsonify(result), 200


def _mpesa_initiate_payout_b2c(data: dict, initiated_by_user_id: int) -> tuple[bool, dict]:
    from utils.mpesa_daraja import (
        daraja_post_json,
        get_access_token,
        normalize_msisdn_ke,
        safe_json_dumps,
    )

    if not database_has_table('mpesa_payouts'):
        return False, {'error': 'M-Pesa tables not ready. Run migrations.', '_status': 500}

    phone = normalize_msisdn_ke(data.get('phone_number') or '')
    amount = _to_decimal_2dp(data.get('amount'))
    remarks = (data.get('remarks') or 'Clinic payout').strip()
    occasion = (data.get('occasion') or '').strip() or None
    command_id = (data.get('command_id') or 'BusinessPayment').strip()

    if not phone:
        return False, {'error': 'phone_number is required', '_status': 400}
    if amount <= 0:
        return False, {'error': 'amount must be > 0', '_status': 400}

    pi = None
    ptxn = None
    try:
        if _payment_intents_supported():
            pi = _create_payment_intent(
                direction='OUT',
                intent_type='B2C',
                amount=_to_decimal_2dp(amount),
                currency='KES',
                reference=f"B2C {phone}",
                initiated_by_user_id=int(initiated_by_user_id),
                status='pending',
                notes=(remarks or None),
            )
            if pi is not None:
                ptxn = _create_mpesa_provider_txn(
                    payment_intent_id=int(pi.id),
                    direction='OUT',
                    provider_action='b2c',
                    status='pending',
                )
    except Exception:
        pi = None
        ptxn = None

    cfg = _mpesa_outgoing_common_config()
    endpoint = (app.config.get('MPESA_B2C_ENDPOINT') or '').strip()
    result_url = (app.config.get('MPESA_B2C_RESULT_URL') or '').strip()
    timeout_url = (app.config.get('MPESA_B2C_TIMEOUT_URL') or '').strip()
    missing = [k for k, v in {
        'MPESA_INITIATOR_NAME': cfg['initiator'],
        'MPESA_SECURITY_CREDENTIAL': cfg['security_credential'],
        'MPESA_OUTGOING_SHORTCODE': cfg['party_a'],
        'MPESA_B2C_ENDPOINT': endpoint,
        'MPESA_B2C_RESULT_URL': result_url,
        'MPESA_B2C_TIMEOUT_URL': timeout_url,
        'MPESA_CONSUMER_KEY': cfg['consumer_key'],
        'MPESA_CONSUMER_SECRET': cfg['consumer_secret'],
        'MPESA_BASE_URL': cfg['base_url'],
    }.items() if not v]
    if missing:
        return False, {'error': 'M-Pesa B2C is not configured', 'missing': missing, '_status': 500}

    payout = MpesaPayout(
        payout_type='b2c',
        status='pending',
        initiated_by_user_id=int(initiated_by_user_id),
        beneficiary_msisdn=phone,
        amount=amount,
        remarks=remarks,
        occasion=occasion,
        payment_intent_id=int(pi.id) if pi else None,
        provider_txn_id=int(ptxn.id) if ptxn else None,
    )
    db.session.add(payout)
    db.session.flush()

    body = {
        'InitiatorName': cfg['initiator'],
        'SecurityCredential': cfg['security_credential'],
        'CommandID': command_id,
        'Amount': int(amount),
        'PartyA': cfg['party_a'],
        'PartyB': phone,
        'Remarks': remarks,
        'QueueTimeOutURL': timeout_url,
        'ResultURL': result_url,
        'Occasion': occasion or '',
    }
    payout.raw_request = safe_json_dumps(body)
    try:
        if ptxn is not None:
            _maybe_set_link_fields(ptxn, raw_request=payout.raw_request)
            db.session.add(ptxn)
    except Exception:
        pass

    try:
        token = get_access_token(base_url=cfg['base_url'], consumer_key=cfg['consumer_key'], consumer_secret=cfg['consumer_secret'], timeout=cfg['timeout'])
        resp = daraja_post_json(base_url=cfg['base_url'], path=endpoint, token=token, json_body=body, timeout=cfg['timeout'])
    except Exception as e:
        app.logger.exception('B2C payout failed')
        payout.status = 'failed'
        payout.result_desc = str(e)[:250]
        db.session.commit()
        return False, {'error': 'B2C payout failed', 'detail': str(e), '_status': 502}

    payout.conversation_id = resp.get('ConversationID') or resp.get('ConversationId')
    payout.originator_conversation_id = resp.get('OriginatorConversationID') or resp.get('OriginatorConversationId')
    payout.response_code = resp.get('ResponseCode')
    payout.response_description = resp.get('ResponseDescription')
    payout.raw_result = safe_json_dumps(resp)

    try:
        if ptxn is not None:
            _maybe_set_link_fields(
                ptxn,
                conversation_id=payout.conversation_id,
                originator_conversation_id=payout.originator_conversation_id,
                result_desc=(payout.response_description or None),
                raw_callback=payout.raw_result,
            )
            db.session.add(ptxn)
    except Exception:
        pass
    db.session.commit()
    return True, {'ok': True, 'payout_id': payout.id, 'daraja': resp}


@app.post('/api/mpesa/payout/b2b')
@login_required
@roles_required_json('admin')
@limiter.limit('10/minute')
def mpesa_payout_b2b():
    """Admin: Pay a PayBill or Till (B2B)."""
    data = request.get_json(silent=True) or {}
    ok, result = _mpesa_initiate_payout_b2b(data, initiated_by_user_id=int(current_user.id))
    if not ok:
        return jsonify(result), int(result.get('_status') or 400)
    return jsonify(result), 200


def _mpesa_initiate_payout_b2b(data: dict, initiated_by_user_id: int) -> tuple[bool, dict]:
    from utils.mpesa_daraja import (
        daraja_post_json,
        get_access_token,
        safe_json_dumps,
    )

    if not database_has_table('mpesa_payouts'):
        return False, {'error': 'M-Pesa tables not ready. Run migrations.', '_status': 500}

    amount = _to_decimal_2dp(data.get('amount'))
    remarks = (data.get('remarks') or 'Clinic payout').strip()
    account_ref = (data.get('account_reference') or '').strip() or None
    command_id = (data.get('command_id') or '').strip()  # if empty, infer below
    paybill = (data.get('paybill') or '').strip() or None
    till = (data.get('till') or '').strip() or None

    if amount <= 0:
        return False, {'error': 'amount must be > 0', '_status': 400}
    if not paybill and not till:
        return False, {'error': 'Provide paybill or till', '_status': 400}
    if paybill and till:
        return False, {'error': 'Provide only one of paybill or till', '_status': 400}

    receiver = paybill or till
    receiver_identifier_type = 4 if paybill else 2
    if not command_id:
        command_id = 'BusinessPayBill' if paybill else 'BusinessBuyGoods'

    pi = None
    ptxn = None
    try:
        if _payment_intents_supported():
            pi = _create_payment_intent(
                direction='OUT',
                intent_type='B2B',
                amount=_to_decimal_2dp(amount),
                currency='KES',
                reference=f"B2B {receiver}",
                initiated_by_user_id=int(initiated_by_user_id),
                status='pending',
                notes=(remarks or None),
            )
            if pi is not None:
                ptxn = _create_mpesa_provider_txn(
                    payment_intent_id=int(pi.id),
                    direction='OUT',
                    provider_action='b2b',
                    status='pending',
                )
    except Exception:
        pi = None
        ptxn = None

    cfg = _mpesa_outgoing_common_config()
    endpoint = (app.config.get('MPESA_B2B_ENDPOINT') or '').strip()
    result_url = (app.config.get('MPESA_B2B_RESULT_URL') or '').strip()
    timeout_url = (app.config.get('MPESA_B2B_TIMEOUT_URL') or '').strip()
    missing = [k for k, v in {
        'MPESA_INITIATOR_NAME': cfg['initiator'],
        'MPESA_SECURITY_CREDENTIAL': cfg['security_credential'],
        'MPESA_OUTGOING_SHORTCODE': cfg['party_a'],
        'MPESA_B2B_ENDPOINT': endpoint,
        'MPESA_B2B_RESULT_URL': result_url,
        'MPESA_B2B_TIMEOUT_URL': timeout_url,
        'MPESA_CONSUMER_KEY': cfg['consumer_key'],
        'MPESA_CONSUMER_SECRET': cfg['consumer_secret'],
        'MPESA_BASE_URL': cfg['base_url'],
    }.items() if not v]
    if missing:
        return False, {'error': 'M-Pesa B2B is not configured', 'missing': missing, '_status': 500}

    payout = MpesaPayout(
        payout_type='b2b',
        status='pending',
        initiated_by_user_id=int(initiated_by_user_id),
        beneficiary_paybill=paybill,
        beneficiary_till=till,
        amount=amount,
        remarks=remarks,
        payment_intent_id=int(pi.id) if pi else None,
        provider_txn_id=int(ptxn.id) if ptxn else None,
    )
    db.session.add(payout)
    db.session.flush()

    body = {
        'Initiator': cfg['initiator'],
        'SecurityCredential': cfg['security_credential'],
        'CommandID': command_id,
        'Amount': int(amount),
        'PartyA': cfg['party_a'],
        'PartyB': receiver,
        'SenderIdentifierType': 4,
        'ReceiverIdentifierType': receiver_identifier_type,
        'Remarks': remarks,
        'AccountReference': account_ref or f'PAYOUT-{payout.id}',
        'QueueTimeOutURL': timeout_url,
        'ResultURL': result_url,
    }
    payout.raw_request = safe_json_dumps(body)
    try:
        if ptxn is not None:
            _maybe_set_link_fields(ptxn, raw_request=payout.raw_request)
            db.session.add(ptxn)
    except Exception:
        pass

    try:
        token = get_access_token(base_url=cfg['base_url'], consumer_key=cfg['consumer_key'], consumer_secret=cfg['consumer_secret'], timeout=cfg['timeout'])
        resp = daraja_post_json(base_url=cfg['base_url'], path=endpoint, token=token, json_body=body, timeout=cfg['timeout'])
    except Exception as e:
        app.logger.exception('B2B payout failed')
        payout.status = 'failed'
        payout.result_desc = str(e)[:250]
        db.session.commit()
        return False, {'error': 'B2B payout failed', 'detail': str(e), '_status': 502}

    payout.conversation_id = resp.get('ConversationID') or resp.get('ConversationId')
    payout.originator_conversation_id = resp.get('OriginatorConversationID') or resp.get('OriginatorConversationId')
    payout.response_code = resp.get('ResponseCode')
    payout.response_description = resp.get('ResponseDescription')
    payout.raw_result = safe_json_dumps(resp)

    try:
        if ptxn is not None:
            _maybe_set_link_fields(
                ptxn,
                conversation_id=payout.conversation_id,
                originator_conversation_id=payout.originator_conversation_id,
                result_desc=(payout.response_description or None),
                raw_callback=payout.raw_result,
            )
            db.session.add(ptxn)
    except Exception:
        pass
    db.session.commit()
    return True, {'ok': True, 'payout_id': payout.id, 'daraja': resp}


@app.post('/api/mpesa/payout/b2pochi')
@login_required
@roles_required_json('admin')
@limiter.limit('10/minute')
def mpesa_payout_b2pochi():
    """Admin: Send money to a Pochi la Biashara target.

    NOTE: Endpoint varies by setup; configure MPESA_B2POCHI_ENDPOINT + callback URLs.
    """
    data = request.get_json(silent=True) or {}
    ok, result = _mpesa_initiate_payout_b2pochi(data, initiated_by_user_id=int(current_user.id))
    if not ok:
        return jsonify(result), int(result.get('_status') or 400)
    return jsonify(result), 200


def _mpesa_initiate_payout_b2pochi(data: dict, initiated_by_user_id: int) -> tuple[bool, dict]:
    from utils.mpesa_daraja import (
        daraja_post_json,
        get_access_token,
        normalize_msisdn_ke,
        safe_json_dumps,
    )

    if not database_has_table('mpesa_payouts'):
        return False, {'error': 'M-Pesa tables not ready. Run migrations.', '_status': 500}

    phone = normalize_msisdn_ke(data.get('phone_number') or '')
    amount = _to_decimal_2dp(data.get('amount'))
    remarks = (data.get('remarks') or 'Clinic payout').strip()
    occasion = (data.get('occasion') or '').strip() or None
    command_id = (data.get('command_id') or 'BusinessPayment').strip()

    if not phone:
        return False, {'error': 'phone_number is required', '_status': 400}
    if amount <= 0:
        return False, {'error': 'amount must be > 0', '_status': 400}

    pi = None
    ptxn = None
    try:
        if _payment_intents_supported():
            pi = _create_payment_intent(
                direction='OUT',
                intent_type='B2POCHI',
                amount=_to_decimal_2dp(amount),
                currency='KES',
                reference=f"B2POCHI {phone}",
                initiated_by_user_id=int(initiated_by_user_id),
                status='pending',
                notes=(remarks or None),
            )
            if pi is not None:
                ptxn = _create_mpesa_provider_txn(
                    payment_intent_id=int(pi.id),
                    direction='OUT',
                    provider_action='b2pochi',
                    status='pending',
                )
    except Exception:
        pi = None
        ptxn = None

    cfg = _mpesa_outgoing_common_config()
    endpoint = (app.config.get('MPESA_B2POCHI_ENDPOINT') or '').strip()
    result_url = (app.config.get('MPESA_B2POCHI_RESULT_URL') or '').strip()
    timeout_url = (app.config.get('MPESA_B2POCHI_TIMEOUT_URL') or '').strip()
    missing = [k for k, v in {
        'MPESA_INITIATOR_NAME': cfg['initiator'],
        'MPESA_SECURITY_CREDENTIAL': cfg['security_credential'],
        'MPESA_OUTGOING_SHORTCODE': cfg['party_a'],
        'MPESA_B2POCHI_ENDPOINT': endpoint,
        'MPESA_B2POCHI_RESULT_URL': result_url,
        'MPESA_B2POCHI_TIMEOUT_URL': timeout_url,
        'MPESA_CONSUMER_KEY': cfg['consumer_key'],
        'MPESA_CONSUMER_SECRET': cfg['consumer_secret'],
        'MPESA_BASE_URL': cfg['base_url'],
    }.items() if not v]
    if missing:
        return False, {'error': 'M-Pesa B2Pochi is not configured', 'missing': missing, '_status': 500}

    payout = MpesaPayout(
        payout_type='b2pochi',
        status='pending',
        initiated_by_user_id=int(initiated_by_user_id),
        beneficiary_pochi=phone,
        amount=amount,
        remarks=remarks,
        occasion=occasion,
        payment_intent_id=int(pi.id) if pi else None,
        provider_txn_id=int(ptxn.id) if ptxn else None,
    )
    db.session.add(payout)
    db.session.flush()

    body = {
        'Initiator': cfg['initiator'],
        'SecurityCredential': cfg['security_credential'],
        'CommandID': command_id,
        'Amount': int(amount),
        'PartyA': cfg['party_a'],
        'PartyB': phone,
        'Remarks': remarks,
        'QueueTimeOutURL': timeout_url,
        'ResultURL': result_url,
        'Occasion': occasion or '',
    }
    payout.raw_request = safe_json_dumps(body)
    try:
        if ptxn is not None:
            _maybe_set_link_fields(ptxn, raw_request=payout.raw_request)
            db.session.add(ptxn)
    except Exception:
        pass

    try:
        token = get_access_token(base_url=cfg['base_url'], consumer_key=cfg['consumer_key'], consumer_secret=cfg['consumer_secret'], timeout=cfg['timeout'])
        resp = daraja_post_json(base_url=cfg['base_url'], path=endpoint, token=token, json_body=body, timeout=cfg['timeout'])
    except Exception as e:
        app.logger.exception('B2Pochi payout failed')
        payout.status = 'failed'
        payout.result_desc = str(e)[:250]
        db.session.commit()
        return False, {'error': 'B2Pochi payout failed', 'detail': str(e), '_status': 502}

    payout.conversation_id = resp.get('ConversationID') or resp.get('ConversationId')
    payout.originator_conversation_id = resp.get('OriginatorConversationID') or resp.get('OriginatorConversationId')
    payout.response_code = resp.get('ResponseCode')
    payout.response_description = resp.get('ResponseDescription')
    payout.raw_result = safe_json_dumps(resp)

    try:
        if ptxn is not None:
            _maybe_set_link_fields(
                ptxn,
                conversation_id=payout.conversation_id,
                originator_conversation_id=payout.originator_conversation_id,
                result_desc=(payout.response_description or None),
                raw_callback=payout.raw_result,
            )
            db.session.add(ptxn)
    except Exception:
        pass
    db.session.commit()
    return True, {'ok': True, 'payout_id': payout.id, 'daraja': resp}


def _mpesa_payout_handle_result(payload: dict) -> None:
    from utils.mpesa_daraja import safe_json_dumps

    extracted = _daraja_extract_result(payload)
    oid = (extracted.get('originator_conversation_id') or '').strip()
    cid = (extracted.get('conversation_id') or '').strip()

    payout = None
    if oid:
        payout = MpesaPayout.query.filter_by(originator_conversation_id=oid).first()
    if not payout and cid:
        payout = MpesaPayout.query.filter_by(conversation_id=cid).first()
    if not payout:
        return

    payout.raw_result = safe_json_dumps(payload)
    try:
        payout.result_code = int(extracted.get('result_code')) if extracted.get('result_code') is not None else None
    except Exception:
        payout.result_code = None
    payout.result_desc = (extracted.get('result_desc') or '')[:250] if extracted.get('result_desc') else None
    payout.mpesa_transaction_id = payout.mpesa_transaction_id or (extracted.get('transaction_id') or None)

    # Update canonical ProviderTxn/PaymentIntent (best-effort)
    try:
        if _payment_intents_supported():
            if getattr(payout, 'provider_txn_id', None):
                ptxn = _db_get(MpesaProviderTxn, int(payout.provider_txn_id))
                if ptxn:
                    _maybe_set_link_fields(
                        ptxn,
                        status='success' if payout.result_code == 0 else 'failed',
                        result_code=payout.result_code,
                        result_desc=payout.result_desc,
                        mpesa_transaction_id=payout.mpesa_transaction_id,
                        raw_callback=payout.raw_result,
                    )
                    db.session.add(ptxn)
            if getattr(payout, 'payment_intent_id', None):
                pi = _db_get(PaymentIntent, int(payout.payment_intent_id))
                if pi:
                    pi.status = 'success' if payout.result_code == 0 else 'failed'
                    pi.updated_at = get_eat_now()
                    db.session.add(pi)
    except Exception:
        pass

    if payout.result_code == 0:
        payout.status = 'success'

        # Idempotent ledger posting
        tx = Transaction.query.filter_by(reference_table='mpesa_payouts', reference_id=payout.id).first()
        if not tx:
            tx = Transaction(
                transaction_number=generate_transaction_number(),
                transaction_type='expense',
                amount=float(_to_decimal_2dp(payout.amount)),
                user_id=int(payout.initiated_by_user_id),
                reference_id=int(payout.id),
                notes=(
                    f"M-Pesa payout ({payout.payout_type}). "
                    f"M-Pesa Txn: {payout.mpesa_transaction_id or ''}"
                ).strip(),
                created_at=get_eat_now(),
            )
            _maybe_set_transaction_meta(
                tx,
                reference_table='mpesa_payouts',
                direction='OUT',
                status='posted',
                payment_method='mpesa',
                department='admin',
                category='mpesa_payout',
            )
            _maybe_set_link_fields(
                tx,
                payment_intent_id=getattr(payout, 'payment_intent_id', None),
                provider_txn_id=getattr(payout, 'provider_txn_id', None),
            )
            db.session.add(tx)
            _post_mpesa_payout_receipt(tx, payout)
    else:
        payout.status = 'failed'


@app.post('/api/mpesa/payout/result')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_payout_result():
    payload = request.get_json(silent=True) or {}
    _mpesa_payout_handle_result(payload)
    db.session.commit()
    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200


@app.post('/api/mpesa/payout/timeout')
@csrf.exempt
@limiter.limit('120/minute')
def mpesa_payout_timeout():
    from utils.mpesa_daraja import safe_json_dumps

    payload = request.get_json(silent=True) or {}
    extracted = _daraja_extract_result(payload)
    oid = (extracted.get('originator_conversation_id') or '').strip()
    cid = (extracted.get('conversation_id') or '').strip()

    payout = None
    if oid:
        payout = MpesaPayout.query.filter_by(originator_conversation_id=oid).first()
    if not payout and cid:
        payout = MpesaPayout.query.filter_by(conversation_id=cid).first()
    if payout:
        payout.status = 'failed'
        payout.raw_result = safe_json_dumps(payload)
        payout.result_desc = (payout.result_desc or 'Timeout')[:250]

        # Update canonical ProviderTxn/PaymentIntent (best-effort)
        try:
            if _payment_intents_supported():
                if getattr(payout, 'provider_txn_id', None):
                    ptxn = _db_get(MpesaProviderTxn, int(payout.provider_txn_id))
                    if ptxn:
                        _maybe_set_link_fields(
                            ptxn,
                            status='failed',
                            result_desc=(payout.result_desc or 'Timeout')[:250],
                            raw_callback=payout.raw_result,
                        )
                        db.session.add(ptxn)
                if getattr(payout, 'payment_intent_id', None):
                    pi = _db_get(PaymentIntent, int(payout.payment_intent_id))
                    if pi:
                        pi.status = 'failed'
                        pi.updated_at = get_eat_now()
                        db.session.add(pi)
        except Exception:
            pass
        db.session.commit()

    return jsonify({'ResultCode': 0, 'ResultDesc': 'Accepted'}), 200

# =================================================================================================
# VENDOR ROUTES
# =================================================================================================

@app.route('/admin/vendors')
@login_required
@admin_required
def vendors():
    vendors = Vendor.query.all()
    return render_template('admin/vendors.html', vendors=vendors)

@app.route('/admin/vendors/add', methods=['POST'])
@login_required
@admin_required
def add_vendor():
    name = request.form.get('name')
    contact_person = request.form.get('contact_person')
    phone = request.form.get('phone')
    email = request.form.get('email')
    address = request.form.get('address')
    is_active = request.form.get('is_active') == 'true'

    if not name:
        flash('Vendor name is required.', 'danger')
        return redirect(url_for('vendors'))

    new_vendor = Vendor(
        name=name,
        contact=contact_person or phone,
        email=email,
        address=address,
        is_active=is_active
    )
    db.session.add(new_vendor)
    db.session.commit()
    flash('Vendor added successfully.', 'success')
    return redirect(url_for('vendors'))

@app.route('/admin/vendors/edit/<int:vendor_id>', methods=['POST'])
@login_required
@admin_required
def edit_vendor(vendor_id):
    vendor = _db_get_or_404(Vendor, vendor_id)
    vendor.name = request.form.get('name')
    contact_person = request.form.get('contact_person')
    phone = request.form.get('phone')
    vendor.contact = contact_person or phone
    vendor.email = request.form.get('email')
    vendor.address = request.form.get('address')
    vendor.is_active = request.form.get('is_active') == 'true'

    if not vendor.name:
        flash('Vendor name is required.', 'danger')
        return redirect(url_for('vendors'))

    db.session.commit()
    flash('Vendor updated successfully.', 'success')
    return redirect(url_for('vendors'))

@app.route('/admin/vendors/delete/<int:vendor_id>', methods=['POST'])
@login_required
@admin_required
def delete_vendor(vendor_id):
    vendor = _db_get_or_404(Vendor, vendor_id)
    db.session.delete(vendor)
    db.session.commit()
    flash('Vendor deleted successfully.', 'success')
    return redirect(url_for('vendors'))

# =================================================================================================
# END VENDOR ROUTES
# =================================================================================================

@app.route('/admin/employees')
@login_required
@admin_required
def employees():
    employees = Employee.query.all()
    return render_template('admin/employees.html', employees=employees)

@app.route('/admin/employees/create', methods=['GET', 'POST'])
@login_required
@admin_required
def create_employee():
    if request.method == 'POST':
        name = request.form.get('name')
        position = request.form.get('position')
        salary = request.form.get('salary')
        hire_date_str = request.form.get('hire_date')
        contact = request.form.get('contact')

        hire_date = datetime.strptime(hire_date_str, '%Y-%m-%d') if hire_date_str else None
        
        new_employee = Employee(
            name=name,
            position=position,
            salary=float(salary) if salary else None,
            hire_date=hire_date,
            contact=contact
        )
        db.session.add(new_employee)
        db.session.commit()
        flash('Employee created successfully.', 'success')
        return redirect(url_for('employees'))

    return render_template('admin/create_edit_employee.html', employee=None)

@app.route('/admin/employees/edit/<int:employee_id>', methods=['GET', 'POST'])
@login_required
@admin_required
def edit_employee(employee_id):
    employee = _db_get_or_404(Employee, employee_id)
    if request.method == 'POST':
        employee.name = request.form.get('name')
        employee.position = request.form.get('position')
        salary = request.form.get('salary')
        employee.salary = float(salary) if salary else None
        hire_date_str = request.form.get('hire_date')
        employee.hire_date = datetime.strptime(hire_date_str, '%Y-%m-%d') if hire_date_str else None
        employee.contact = request.form.get('contact')
        
        db.session.commit()
        flash('Employee updated successfully.', 'success')
        return redirect(url_for('employees'))

    return render_template('admin/create_edit_employee.html', employee=employee)

@app.route('/admin/employees/delete/<int:employee_id>', methods=['POST'])
@login_required
@admin_required
def delete_employee(employee_id):
    employee = _db_get_or_404(Employee, employee_id)
    db.session.delete(employee)
    db.session.commit()
    flash('Employee deleted successfully.', 'success')
    return redirect(url_for('employees'))


def _employee_for_current_user():
    emp = Employee.query.filter_by(user_id=current_user.id).first()
    return emp


def _make_payroll_receipt_view(payment: 'PayrollPayment', payroll: 'Payroll') -> dict:
    """Return a dict with fields expected by employee payroll receipt templates."""
    payment_dt = getattr(payment, 'payment_date', None)
    if not payment_dt:
        payment_dt = get_eat_now()

    try:
        previous_paid = (
            db.session.query(func.coalesce(func.sum(PayrollPayment.amount), 0))
            .filter(PayrollPayment.payroll_id == payroll.id)
            .filter(PayrollPayment.id != payment.id)
            .filter(PayrollPayment.payment_date < payment_dt)
            .scalar()
        ) or 0
    except Exception:
        previous_paid = 0

    current_paid = float(previous_paid or 0) + float(getattr(payment, 'amount', 0) or 0)
    salary = float(getattr(payroll, 'amount', 0) or 0)
    arrears = float(salary) - float(current_paid)

    return {
        'id': payment.id,
        'receipt_number': f"PR-{int(payment.id):06d}",
        'payment_date': payment_dt,
        'amount': float(getattr(payment, 'amount', 0) or 0),
        'salary': salary,
        'previous_amount_paid': float(previous_paid or 0),
        'current_amount_paid': float(current_paid or 0),
        'arrears': float(arrears or 0),
        'notes': getattr(payment, 'notes', None),
        'created_at': payment_dt,
        'paid_by': getattr(payment, 'paid_by', None),
        'payroll_id': payroll.id,
    }


@app.route('/employee/payroll/receipts')
@login_required
def view_my_payroll_receipts():
    if getattr(current_user, 'role', None) != 'employee':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    employee = _employee_for_current_user()
    if not employee:
        flash('No employee profile is linked to your account.', 'warning')
        return redirect(url_for('home'))

    rows = (
        db.session.query(PayrollPayment, Payroll)
        .join(Payroll, PayrollPayment.payroll_id == Payroll.id)
        .filter(Payroll.employee_id == employee.id)
        .order_by(PayrollPayment.payment_date.desc())
        .all()
    )

    receipts = [_make_payroll_receipt_view(p, pr) for (p, pr) in rows]
    is_embed = bool(request.args.get('embed'))

    return render_template(
        'employee/payroll_receipts.html',
        employee=employee,
        receipts=receipts,
        is_embed=is_embed,
    )


@app.route('/employee/payroll/receipts/<int:receipt_id>')
@login_required
def view_payroll_receipt(receipt_id):
    if getattr(current_user, 'role', None) != 'employee':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    employee = _employee_for_current_user()
    if not employee:
        flash('No employee profile is linked to your account.', 'warning')
        return redirect(url_for('home'))

    payment = _db_get_or_404(PayrollPayment, receipt_id)
    payroll = _db_get_or_404(Payroll, payment.payroll_id)
    if int(getattr(payroll, 'employee_id', 0) or 0) != int(employee.id):
        abort(403)

    receipt = _make_payroll_receipt_view(payment, payroll)

    issued_user = None
    try:
        if receipt.get('paid_by'):
            issued_user = _db_get(User, int(receipt.get('paid_by')))
    except Exception:
        issued_user = None

    # Template expects payroll.hired_date; map from employee.hire_date for compatibility.
    try:
        setattr(payroll, 'hired_date', getattr(employee, 'hire_date', None))
    except Exception:
        pass

    return render_template(
        'employee/payroll_receipt_detail.html',
        receipt=receipt,
        employee=employee,
        payroll=payroll,
        issued_user=issued_user,
    )


@app.route('/employee/payroll/receipts/<int:receipt_id>/download')
@login_required
def download_payroll_receipt_employee(receipt_id):
    """Download a payroll receipt.

    This implementation provides an HTML download (print-to-PDF friendly) to
    avoid introducing heavy PDF dependencies.
    """
    if getattr(current_user, 'role', None) != 'employee':
        flash('Unauthorized access', 'danger')
        return redirect(url_for('home'))

    employee = _employee_for_current_user()
    if not employee:
        flash('No employee profile is linked to your account.', 'warning')
        return redirect(url_for('home'))

    payment = _db_get_or_404(PayrollPayment, receipt_id)
    payroll = _db_get_or_404(Payroll, payment.payroll_id)
    if int(getattr(payroll, 'employee_id', 0) or 0) != int(employee.id):
        abort(403)

    receipt = _make_payroll_receipt_view(payment, payroll)
    issued_user = None
    try:
        if receipt.get('paid_by'):
            issued_user = _db_get(User, int(receipt.get('paid_by')))
    except Exception:
        issued_user = None

    try:
        setattr(payroll, 'hired_date', getattr(employee, 'hire_date', None))
    except Exception:
        pass

    html = render_template(
        'employee/payroll_receipt_detail.html',
        receipt=receipt,
        employee=employee,
        payroll=payroll,
        issued_user=issued_user,
    )

    filename = f"payroll-receipt-{receipt.get('receipt_number','receipt')}.html"
    resp = make_response(html)
    resp.headers['Content-Type'] = 'text/html; charset=utf-8'
    resp.headers['Content-Disposition'] = f'attachment; filename="{filename}"'
    return resp

# =================================
# COMMUNICATION SYSTEM ROUTES & SOCKET.IO HANDLERS
# =================================

@app.route('/api/communication/users', methods=['GET'])
@login_required
def api_communication_users():
    """Get list of all users for communication"""
    try:
        # Get all users except current user
        users = User.query.filter(User.id != current_user.id, User.is_active == True).all()
        
        users_data = []
        for user in users:
            # Get unread message count from this user
            unread_count = Message.query.filter_by(
                sender_id=user.id,
                recipient_id=current_user.id,
                is_read=False
            ).count()
            
            # Get online status
            status = UserOnlineStatus.query.filter_by(user_id=user.id).first()
            is_online = status.is_online if status else False
            last_seen = status.last_seen.isoformat() if (status and status.last_seen) else None

            # Conversation settings + blocks (safe fallback if tables not created yet)
            settings = None
            blocked_by_me = False
            blocked_me = False
            try:
                conversation = Conversation.query.filter(
                    or_(
                        and_(Conversation.user1_id == current_user.id, Conversation.user2_id == user.id),
                        and_(Conversation.user1_id == user.id, Conversation.user2_id == current_user.id)
                    )
                ).first()

                if conversation:
                    settings = ConversationSettings.query.filter_by(
                        user_id=current_user.id,
                        conversation_id=conversation.id
                    ).first()

                blocked_by_me = BlockedUser.query.filter_by(blocker_id=current_user.id, blocked_id=user.id).first() is not None
                blocked_me = BlockedUser.query.filter_by(blocker_id=user.id, blocked_id=current_user.id).first() is not None
            except Exception:
                settings = None
                blocked_by_me = False
                blocked_me = False
            
            users_data.append({
                'id': user.id,
                'username': user.username,
                'role': user.role,
                'is_online': is_online,
                'last_seen': last_seen,
                'unread_count': unread_count,
                'is_archived': bool(settings.is_archived) if settings else False,
                'is_pinned': bool(settings.is_pinned) if settings else False,
                'is_muted': bool(settings.is_muted) if settings else False,
                'blocked_by_me': blocked_by_me,
                'blocked_me': blocked_me
            })
        
        return jsonify({'success': True, 'users': users_data})
    
    except Exception as e:
        app.logger.error(f"Error fetching users: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/conversation/<int:other_user_id>', methods=['GET'])
@login_required
def api_communication_conversation(other_user_id):
    """Get conversation and messages with another user"""
    try:
        # Find or create conversation
        conversation = Conversation.query.filter(
            or_(
                and_(Conversation.user1_id == current_user.id, Conversation.user2_id == other_user_id),
                and_(Conversation.user1_id == other_user_id, Conversation.user2_id == current_user.id)
            )
        ).first()
        
        if not conversation:
            # Create new conversation
            conversation = Conversation(
                user1_id=current_user.id,
                user2_id=other_user_id
            )
            db.session.add(conversation)
            db.session.commit()
        
        # Get messages
        messages = Message.query.filter_by(conversation_id=conversation.id).order_by(Message.created_at).all()

        messages_data = []
        try:
            message_ids = [m.message_id for m in messages]

            deletions = set(
                d.message_id for d in MessageDeletion.query.filter(MessageDeletion.message_id.in_(message_ids)).all()
            ) if message_ids else set()

            edit_counts = {}
            if message_ids:
                for mid, cnt in (
                    db.session.query(MessageEdit.message_id, db.func.count(MessageEdit.id))
                    .filter(MessageEdit.message_id.in_(message_ids))
                    .group_by(MessageEdit.message_id)
                    .all()
                ):
                    edit_counts[mid] = int(cnt)

            starred = set(
                s.message_id for s in MessageStar.query.filter(
                    MessageStar.user_id == current_user.id,
                    MessageStar.message_id.in_(message_ids)
                ).all()
            ) if message_ids else set()

            reply_map = {}
            if message_ids:
                for r in MessageReply.query.filter(MessageReply.message_id.in_(message_ids)).all():
                    reply_map[r.message_id] = r.replied_to_message_id

            replied_to_ids = list({v for v in reply_map.values() if v})
            replied_to_lookup = {}
            if replied_to_ids:
                for m in Message.query.filter(Message.message_id.in_(replied_to_ids)).all():
                    replied_to_lookup[m.message_id] = {
                        'message_id': m.message_id,
                        'sender_id': m.sender_id,
                        'content': (m.content or '')[:280]
                    }

            reactions_map = {}
            my_reaction_map = {}
            if message_ids:
                for r in MessageReaction.query.filter(MessageReaction.message_id.in_(message_ids)).all():
                    reactions_map.setdefault(r.message_id, {})
                    reactions_map[r.message_id][r.emoji] = reactions_map[r.message_id].get(r.emoji, 0) + 1
                    if r.user_id == current_user.id:
                        my_reaction_map[r.message_id] = r.emoji

            for msg in messages:
                is_deleted = msg.message_id in deletions
                emoji_counts = reactions_map.get(msg.message_id, {})
                reactions_list = [{'emoji': e, 'count': c} for (e, c) in emoji_counts.items()]

                messages_data.append({
                    'message_id': msg.message_id,
                    'sender_id': msg.sender_id,
                    'recipient_id': msg.recipient_id,
                    'content': '' if is_deleted else msg.content,
                    'is_deleted': is_deleted,
                    'is_delivered': msg.is_delivered,
                    'is_read': msg.is_read,
                    'is_edited': bool(edit_counts.get(msg.message_id, 0)),
                    'edit_count': int(edit_counts.get(msg.message_id, 0) or 0),
                    'is_starred': msg.message_id in starred,
                    'replied_to': replied_to_lookup.get(reply_map.get(msg.message_id)),
                    'reactions': reactions_list,
                    'my_reaction': my_reaction_map.get(msg.message_id),
                    'created_at': msg.created_at.isoformat()
                })
        except Exception:
            for msg in messages:
                messages_data.append({
                    'message_id': msg.message_id,
                    'sender_id': msg.sender_id,
                    'recipient_id': msg.recipient_id,
                    'content': msg.content,
                    'is_deleted': False,
                    'is_delivered': msg.is_delivered,
                    'is_read': msg.is_read,
                    'is_edited': False,
                    'edit_count': 0,
                    'is_starred': False,
                    'replied_to': None,
                    'reactions': [],
                    'my_reaction': None,
                    'created_at': msg.created_at.isoformat()
                })
        
        return jsonify({
            'success': True,
            'conversation': {
                'id': conversation.id,
                'conversation_id': conversation.conversation_id
            },
            'messages': messages_data
        })
    
    except Exception as e:
        app.logger.error(f"Error fetching conversation: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/send_message', methods=['POST'])
@login_required
def api_communication_send_message():
    """Send a message to another user"""
    try:
        data = request.get_json()
        receiver_id = data.get('receiver_id')
        content = data.get('content')
        reply_to_message_id = data.get('reply_to_message_id')
        
        if not receiver_id or not content:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400

        if _is_blocked(current_user.id, receiver_id):
            return jsonify({'success': False, 'error': 'Messaging is blocked between these users'}), 403
        
        # Find or create conversation
        conversation = Conversation.query.filter(
            or_(
                and_(Conversation.user1_id == current_user.id, Conversation.user2_id == receiver_id),
                and_(Conversation.user1_id == receiver_id, Conversation.user2_id == current_user.id)
            )
        ).first()
        
        if not conversation:
            conversation = Conversation(
                user1_id=current_user.id,
                user2_id=receiver_id
            )
            db.session.add(conversation)
            db.session.flush()
        
        # Create message
        message = Message(
            conversation_id=conversation.id,
            sender_id=current_user.id,
            recipient_id=receiver_id,
            content=content
        )
        # Ensure message_id exists before we create dependent rows (e.g., replies).
        # SQLAlchemy Column defaults may not populate until flush/insert.
        if not getattr(message, 'message_id', None):
            message.message_id = str(uuid.uuid4())

        db.session.add(message)
        db.session.flush()

        replied_to_payload = None
        if reply_to_message_id:
            replied_to = Message.query.filter_by(message_id=reply_to_message_id, conversation_id=conversation.id).first()
            if replied_to and message.message_id:
                db.session.add(MessageReply(message_id=message.message_id, replied_to_message_id=reply_to_message_id))
                replied_to_payload = {
                    'message_id': replied_to.message_id,
                    'sender_id': replied_to.sender_id,
                    'content': (replied_to.content or '')[:280]
                }
        
        # Update conversation last message time
        conversation.last_message_at = get_eat_now()
        
        db.session.commit()
        
        return jsonify({
            'success': True,
            'message': {
                'message_id': message.message_id,
                'sender_id': message.sender_id,
                'recipient_id': message.recipient_id,
                'content': message.content,
                'is_deleted': False,
                'is_delivered': message.is_delivered,
                'is_read': message.is_read,
                'is_edited': False,
                'edit_count': 0,
                'is_starred': False,
                'replied_to': replied_to_payload,
                'reactions': [],
                'my_reaction': None,
                'created_at': message.created_at.isoformat()
            }
        })
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error sending message: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/mark_read', methods=['POST'])
@login_required
def api_communication_mark_read():
    """Mark messages from a sender as read"""
    try:
        data = request.get_json()
        sender_id = data.get('sender_id')
        
        if not sender_id:
            return jsonify({'success': False, 'error': 'Missing sender_id'}), 400
        
        # Update all unread messages from this sender
        unread_messages = Message.query.filter_by(
            sender_id=sender_id,
            recipient_id=current_user.id,
            is_read=False
        ).all()
        
        for msg in unread_messages:
            msg.is_read = True
            msg.read_at = get_eat_now()
            
            # Notify sender that message was read via Socket.IO
            sender_socket = None
            for sid, uid in active_sockets.items():
                if uid == sender_id:
                    sender_socket = sid
                    break
            
            if sender_socket:
                socketio.emit('message_read', {
                    'message_id': msg.message_id
                }, room=sender_socket)
        
        db.session.commit()
        
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error marking messages as read: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/unread_count', methods=['GET'])
@login_required
def api_communication_unread_count():
    """Get total unread message count for current user"""
    try:
        unread_count = Message.query.filter_by(
            recipient_id=current_user.id,
            is_read=False
        ).count()
        
        return jsonify({'success': True, 'unread_count': unread_count})
    
    except Exception as e:
        app.logger.error(f"Error fetching unread count: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/search', methods=['GET'])
@login_required
def api_communication_search():
    """Search messages in a 1:1 conversation."""
    try:
        q = (request.args.get('q') or '').strip()
        other_user_id = request.args.get('other_user_id', type=int)

        if not q or not other_user_id:
            return jsonify({'success': False, 'error': 'Missing q or other_user_id'}), 400

        conversation = Conversation.query.filter(
            or_(
                and_(Conversation.user1_id == current_user.id, Conversation.user2_id == other_user_id),
                and_(Conversation.user1_id == other_user_id, Conversation.user2_id == current_user.id)
            )
        ).first()

        if not conversation:
            return jsonify({'success': True, 'messages': []})

        base_q = Message.query.filter_by(conversation_id=conversation.id)
        base_q = base_q.filter(Message.content.ilike(f"%{q}%"))
        base_q = base_q.order_by(Message.created_at.desc()).limit(50)
        results = base_q.all()

        deletions = set(
            d.message_id for d in MessageDeletion.query.filter(
                MessageDeletion.message_id.in_([m.message_id for m in results])
            ).all()
        ) if results else set()

        payload = []
        for m in results:
            if m.message_id in deletions:
                continue
            payload.append({
                'message_id': m.message_id,
                'sender_id': m.sender_id,
                'recipient_id': m.recipient_id,
                'content': m.content,
                'created_at': m.created_at.isoformat(),
            })

        return jsonify({'success': True, 'messages': payload})
    except Exception as e:
        app.logger.error(f"Error searching messages: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/message/<string:message_id>/edit', methods=['POST'])
@login_required
def api_communication_edit_message(message_id: str):
    """Edit a message (sender only) and store history."""
    try:
        data = request.get_json() or {}
        new_content = (data.get('content') or '').strip()
        if not new_content:
            return jsonify({'success': False, 'error': 'Missing content'}), 400

        msg = Message.query.filter_by(message_id=message_id).first()
        if not msg:
            return jsonify({'success': False, 'error': 'Message not found'}), 404

        if msg.sender_id != current_user.id:
            return jsonify({'success': False, 'error': 'Not allowed'}), 403

        if MessageDeletion.query.filter_by(message_id=message_id).first():
            return jsonify({'success': False, 'error': 'Message is deleted'}), 400

        old = msg.content or ''
        if old == new_content:
            return jsonify({'success': True, 'message': {'message_id': msg.message_id, 'content': msg.content, 'is_edited': True}})

        db.session.add(MessageEdit(
            message_id=msg.message_id,
            editor_id=current_user.id,
            old_content=old,
            new_content=new_content
        ))
        msg.content = new_content
        db.session.commit()

        return jsonify({'success': True, 'message': {'message_id': msg.message_id, 'content': msg.content, 'is_edited': True}})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error editing message: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/message/<string:message_id>/delete', methods=['POST'])
@login_required
def api_communication_delete_message(message_id: str):
    """Delete a message for everyone (sender only)."""
    try:
        msg = Message.query.filter_by(message_id=message_id).first()
        if not msg:
            return jsonify({'success': False, 'error': 'Message not found'}), 404

        if msg.sender_id != current_user.id:
            return jsonify({'success': False, 'error': 'Not allowed'}), 403

        existing = MessageDeletion.query.filter_by(message_id=message_id).first()
        if existing:
            return jsonify({'success': True, 'deleted': True})

        db.session.add(MessageDeletion(
            message_id=message_id,
            deleted_by_user_id=current_user.id,
            scope='everyone'
        ))
        db.session.commit()
        return jsonify({'success': True, 'deleted': True})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting message: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/message/<string:message_id>/react', methods=['POST'])
@login_required
def api_communication_react_message(message_id: str):
    """Set/clear a reaction for the current user on a message."""
    try:
        data = request.get_json() or {}
        emoji = (data.get('emoji') or '').strip()
        if not emoji:
            return jsonify({'success': False, 'error': 'Missing emoji'}), 400

        msg = Message.query.filter_by(message_id=message_id).first()
        if not msg:
            return jsonify({'success': False, 'error': 'Message not found'}), 404

        # Ensure participant
        if current_user.id not in (msg.sender_id, msg.recipient_id):
            return jsonify({'success': False, 'error': 'Not allowed'}), 403

        existing = MessageReaction.query.filter_by(message_id=message_id, user_id=current_user.id).first()
        if existing and existing.emoji == emoji:
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'my_reaction': None})

        if existing:
            existing.emoji = emoji
        else:
            db.session.add(MessageReaction(message_id=message_id, user_id=current_user.id, emoji=emoji))

        db.session.commit()
        return jsonify({'success': True, 'my_reaction': emoji})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error reacting to message: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/message/<string:message_id>/star', methods=['POST'])
@login_required
def api_communication_star_message(message_id: str):
    """Toggle star (favorite) for the current user on a message."""
    try:
        msg = Message.query.filter_by(message_id=message_id).first()
        if not msg:
            return jsonify({'success': False, 'error': 'Message not found'}), 404

        if current_user.id not in (msg.sender_id, msg.recipient_id):
            return jsonify({'success': False, 'error': 'Not allowed'}), 403

        existing = MessageStar.query.filter_by(message_id=message_id, user_id=current_user.id).first()
        if existing:
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'is_starred': False})

        db.session.add(MessageStar(message_id=message_id, user_id=current_user.id))
        db.session.commit()
        return jsonify({'success': True, 'is_starred': True})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error starring message: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/user/<int:user_id>/block', methods=['POST'])
@login_required
def api_communication_block_user(user_id: int):
    """Toggle block/unblock for a user."""
    try:
        if user_id == current_user.id:
            return jsonify({'success': False, 'error': 'Cannot block yourself'}), 400

        target = _db_get(User, user_id)
        if not target or not getattr(target, 'is_active', True):
            return jsonify({'success': False, 'error': 'User not found'}), 404

        existing = BlockedUser.query.filter_by(blocker_id=current_user.id, blocked_id=user_id).first()
        if existing:
            db.session.delete(existing)
            db.session.commit()
            return jsonify({'success': True, 'blocked': False})

        db.session.add(BlockedUser(blocker_id=current_user.id, blocked_id=user_id))
        db.session.commit()
        return jsonify({'success': True, 'blocked': True})
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error toggling block: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/conversation/<int:other_user_id>/settings', methods=['POST'])
@login_required
def api_communication_conversation_settings(other_user_id: int):
    """Update conversation settings for current user (mute/archive/pin)."""
    try:
        data = request.get_json() or {}

        conversation = Conversation.query.filter(
            or_(
                and_(Conversation.user1_id == current_user.id, Conversation.user2_id == other_user_id),
                and_(Conversation.user1_id == other_user_id, Conversation.user2_id == current_user.id)
            )
        ).first()

        if not conversation:
            conversation = Conversation(user1_id=current_user.id, user2_id=other_user_id)
            db.session.add(conversation)
            db.session.flush()

        settings = ConversationSettings.query.filter_by(user_id=current_user.id, conversation_id=conversation.id).first()
        if not settings:
            settings = ConversationSettings(user_id=current_user.id, conversation_id=conversation.id)
            db.session.add(settings)

        if 'is_muted' in data:
            settings.is_muted = bool(data.get('is_muted'))
        if 'is_archived' in data:
            settings.is_archived = bool(data.get('is_archived'))
        if 'is_pinned' in data:
            settings.is_pinned = bool(data.get('is_pinned'))
            settings.pinned_at = get_eat_now() if settings.is_pinned else None

        db.session.commit()

        return jsonify({
            'success': True,
            'settings': {
                'is_muted': bool(settings.is_muted),
                'is_archived': bool(settings.is_archived),
                'is_pinned': bool(settings.is_pinned),
            }
        })
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error updating conversation settings: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/calls/history', methods=['GET'])
@login_required
def api_communication_calls_history():
    """Get call history for current user."""
    try:
        rows = (
            CallLog.query.filter(
                or_(CallLog.caller_id == current_user.id, CallLog.receiver_id == current_user.id)
            )
            .order_by(CallLog.started_at.desc())
            .limit(100)
            .all()
        )

        payload = []
        for c in rows:
            other_user_id = c.receiver_id if c.caller_id == current_user.id else c.caller_id
            other_user = _db_get(User, other_user_id)
            payload.append({
                'call_id': c.call_id,
                'call_type': c.call_type,
                'call_status': c.call_status,
                'started_at': c.started_at.isoformat() if c.started_at else None,
                'answered_at': c.answered_at.isoformat() if c.answered_at else None,
                'ended_at': c.ended_at.isoformat() if c.ended_at else None,
                'duration_seconds': int(c.duration_seconds or 0),
                'other_user_id': other_user_id,
                'other_user_name': getattr(other_user, 'username', None) if other_user else None,
                'direction': 'outgoing' if c.caller_id == current_user.id else 'incoming',
            })

        return jsonify({'success': True, 'calls': payload})
    except Exception as e:
        app.logger.error(f"Error fetching call history: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/initiate_call', methods=['POST'])
@login_required
def api_communication_initiate_call():
    """Initiate a voice or video call"""
    try:
        data = request.get_json()
        receiver_id = data.get('receiver_id')
        call_type = data.get('call_type')
        
        if not receiver_id or not call_type:
            return jsonify({'success': False, 'error': 'Missing required fields'}), 400

        if _is_blocked(current_user.id, receiver_id):
            return jsonify({'success': False, 'error': 'Calling is blocked between these users'}), 403
        
        # Create call log
        call_log = CallLog(
            caller_id=current_user.id,
            receiver_id=receiver_id,
            call_type=call_type,
            call_status='initiated'
        )
        db.session.add(call_log)
        db.session.commit()
        
        return jsonify({
            'success': True,
            'call_id': call_log.call_id
        })
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error initiating call: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/answer_call', methods=['POST'])
@login_required
def api_communication_answer_call():
    """Answer an incoming call"""
    try:
        data = request.get_json()
        call_id = data.get('call_id')
        
        if not call_id:
            return jsonify({'success': False, 'error': 'Missing call_id'}), 400
        
        call_log = CallLog.query.filter_by(call_id=call_id).first()
        if not call_log:
            return jsonify({'success': False, 'error': 'Call not found'}), 404
        
        call_log.call_status = 'answered'
        call_log.answered_at = get_eat_now()
        db.session.commit()
        
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error answering call: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/reject_call', methods=['POST'])
@login_required
def api_communication_reject_call():
    """Reject an incoming call"""
    try:
        data = request.get_json()
        call_id = data.get('call_id')
        
        if not call_id:
            return jsonify({'success': False, 'error': 'Missing call_id'}), 400
        
        call_log = CallLog.query.filter_by(call_id=call_id).first()
        if not call_log:
            return jsonify({'success': False, 'error': 'Call not found'}), 404
        
        call_log.call_status = 'rejected'
        call_log.ended_at = get_eat_now()
        db.session.commit()
        
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error rejecting call: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/end_call', methods=['POST'])
@login_required
def api_communication_end_call():
    """End an active call"""
    try:
        data = request.get_json()
        call_id = data.get('call_id')
        
        if not call_id:
            return jsonify({'success': False, 'error': 'Missing call_id'}), 400
        
        call_log = CallLog.query.filter_by(call_id=call_id).first()
        if not call_log:
            return jsonify({'success': False, 'error': 'Call not found'}), 404
        
        call_log.call_status = 'ended'
        call_log.ended_at = get_eat_now()
        
        # Calculate duration if call was answered
        if call_log.answered_at:
            duration = (call_log.ended_at - call_log.answered_at).total_seconds()
            call_log.duration_seconds = int(duration)
        
        db.session.commit()
        
        return jsonify({'success': True})
    
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error ending call: {str(e)}")
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/communication/ice_servers', methods=['GET'])
@login_required
def api_communication_ice_servers():
    """Return ICE server configuration for WebRTC (STUN + optional TURN).

    Note: TURN credentials must be sent to the browser to function.
    """
    try:
        ice_servers = [
            {'urls': 'stun:stun.l.google.com:19302'},
            {'urls': 'stun:stun1.l.google.com:19302'},
        ]

        turn_url = os.getenv('TURN_SERVER_URL')
        turn_username = os.getenv('TURN_USERNAME')
        turn_credential = os.getenv('TURN_CREDENTIAL')

        if turn_url and turn_username and turn_credential:
            ice_servers.append({
                'urls': turn_url,
                'username': turn_username,
                'credential': turn_credential,
            })

        return jsonify({'success': True, 'ice_servers': ice_servers})
    except Exception as e:
        app.logger.error(f"Error building ICE servers config: {str(e)}")
        return jsonify({'success': False, 'error': str(e), 'ice_servers': []}), 500


# Socket.IO Event Handlers
from flask_socketio import emit, join_room, leave_room

# Store active socket connections
active_sockets = {}

@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    app.logger.info(f'Client connected: {request.sid}')


@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    # Update user online status
    if request.sid in active_sockets:
        user_id = active_sockets[request.sid]
        
        status = UserOnlineStatus.query.filter_by(user_id=user_id).first()
        if status:
            status.is_online = False
            status.last_seen = get_eat_now()
            status.socket_id = None
            db.session.commit()
        
        # Notify others about status change
        socketio.emit('user_status_update', {
            'user_id': user_id,
            'is_online': False,
            'last_seen': status.last_seen.isoformat() if (status and status.last_seen) else None
        }, skip_sid=request.sid)
        
        del active_sockets[request.sid]
    
    app.logger.info(f'Client disconnected: {request.sid}')


@socketio.on('user_connected')
def handle_user_connected(data):
    """Handle user connection with user_id"""
    user_id = data.get('user_id')
    if not user_id:
        return
    
    # Store socket connection
    active_sockets[request.sid] = user_id
    
    # Update or create online status
    status = UserOnlineStatus.query.filter_by(user_id=user_id).first()
    if not status:
        status = UserOnlineStatus(user_id=user_id)
        db.session.add(status)
    
    status.is_online = True
    status.last_seen = get_eat_now()
    status.socket_id = request.sid
    db.session.commit()
    
    # Notify others about status change
    socketio.emit('user_status_update', {
        'user_id': user_id,
        'is_online': True,
        'last_seen': status.last_seen.isoformat() if (status and status.last_seen) else None
    }, skip_sid=request.sid)


@socketio.on('join_conversation')
def handle_join_conversation(data):
    """Join a conversation room"""
    user_id = data.get('user_id')
    other_user_id = data.get('other_user_id')
    
    if not user_id or not other_user_id:
        return
    
    # Create room name (consistent regardless of who joins)
    room = f"conversation_{min(user_id, other_user_id)}_{max(user_id, other_user_id)}"
    join_room(room)
    app.logger.info(f'User {user_id} joined conversation room: {room}')


@socketio.on('send_message')
def handle_send_message(data):
    """Handle real-time message sending"""
    message = data.get('message')
    receiver_id = data.get('receiver_id')
    
    if not message or not receiver_id:
        return
    
    # Get receiver's socket
    receiver_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            receiver_socket = sid
            break
    
    if receiver_socket:
        # Send to specific user
        socketio.emit('new_message', {
            'message': message
        }, room=receiver_socket)
        
        # Mark message as delivered if receiver is online
        try:
            msg = Message.query.filter_by(message_id=message.get('message_id')).first()
            if msg and not msg.is_delivered:
                msg.is_delivered = True
                msg.delivered_at = get_eat_now()
                db.session.commit()
                
                # Notify sender that message was delivered
                sender_socket = None
                for sid, uid in active_sockets.items():
                    if uid == message.get('sender_id'):
                        sender_socket = sid
                        break
                
                if sender_socket:
                    socketio.emit('message_delivered', {
                        'message_id': message.get('message_id')
                    }, room=sender_socket)
        except Exception as e:
            app.logger.error(f"Error marking message as delivered: {str(e)}")


@socketio.on('message_received')
def handle_message_received(data):
    """Handle message received confirmation"""
    message_id = data.get('message_id')
    sender_id = data.get('sender_id')
    
    if not message_id:
        return
    
    try:
        # Mark message as delivered
        msg = Message.query.filter_by(message_id=message_id).first()
        if msg and not msg.is_delivered:
            msg.is_delivered = True
            msg.delivered_at = get_eat_now()
            db.session.commit()
            
            # Notify sender
            sender_socket = None
            for sid, uid in active_sockets.items():
                if uid == sender_id:
                    sender_socket = sid
                    break
            
            if sender_socket:
                socketio.emit('message_delivered', {
                    'message_id': message_id
                }, room=sender_socket)
    except Exception as e:
        app.logger.error(f"Error in message_received handler: {str(e)}")


@socketio.on('typing')
def handle_typing(data):
    """Handle typing indicator"""
    receiver_id = data.get('receiver_id')
    is_typing = data.get('is_typing')
    user_id = active_sockets.get(request.sid)
    
    if not receiver_id or user_id is None:
        return
    
    # Get receiver's socket
    receiver_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            receiver_socket = sid
            break
    
    if receiver_socket:
        socketio.emit('typing_status', {
            'user_id': user_id,
            'is_typing': is_typing
        }, room=receiver_socket)


@socketio.on('initiate_call')
def handle_initiate_call(data):
    """Handle call initiation"""
    receiver_id = data.get('receiver_id')
    call_type = data.get('call_type')
    call_id = data.get('call_id')
    caller_name = data.get('caller_name')
    caller_id = active_sockets.get(request.sid)
    
    if not receiver_id or not call_type or not call_id:
        return
    
    # Get receiver's socket
    receiver_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            receiver_socket = sid
            break
    
    if receiver_socket:
        socketio.emit('incoming_call', {
            'caller_id': caller_id,
            'caller_name': caller_name,
            'call_type': call_type,
            'call_id': call_id
        }, room=receiver_socket)


@socketio.on('accept_call')
def handle_accept_call(data):
    """Handle call acceptance"""
    call_id = data.get('call_id')
    receiver_id = data.get('receiver_id')
    
    if not call_id or not receiver_id:
        return
    
    # Get caller's socket
    caller_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            caller_socket = sid
            break
    
    if caller_socket:
        socketio.emit('call_accepted', {
            'call_id': call_id
        }, room=caller_socket)


@socketio.on('reject_call')
def handle_reject_call(data):
    """Handle call rejection"""
    call_id = data.get('call_id')
    receiver_id = data.get('receiver_id')
    
    if not call_id or not receiver_id:
        return
    
    # Get caller's socket
    caller_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            caller_socket = sid
            break
    
    if caller_socket:
        socketio.emit('call_rejected', {
            'call_id': call_id
        }, room=caller_socket)


@socketio.on('end_call')
def handle_end_call(data):
    """Handle call ending"""
    call_id = data.get('call_id')
    receiver_id = data.get('receiver_id')
    
    if not call_id or not receiver_id:
        return
    
    # Get other party's socket
    other_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            other_socket = sid
            break
    
    if other_socket:
        socketio.emit('call_ended', {
            'call_id': call_id
        }, room=other_socket)


@socketio.on('webrtc_offer')
def handle_webrtc_offer(data):
    """Handle WebRTC offer"""
    receiver_id = data.get('receiver_id')
    offer = data.get('offer')
    call_id = data.get('call_id')
    caller_id = active_sockets.get(request.sid)
    
    if not receiver_id or not offer:
        return
    
    # Get receiver's socket
    receiver_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            receiver_socket = sid
            break
    
    if receiver_socket:
        socketio.emit('webrtc_offer', {
            'caller_id': caller_id,
            'offer': offer,
            'call_id': call_id
        }, room=receiver_socket)


@socketio.on('webrtc_answer')
def handle_webrtc_answer(data):
    """Handle WebRTC answer"""
    receiver_id = data.get('receiver_id')
    answer = data.get('answer')
    call_id = data.get('call_id')
    
    if not receiver_id or not answer:
        return
    
    # Get caller's socket
    caller_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            caller_socket = sid
            break
    
    if caller_socket:
        socketio.emit('webrtc_answer', {
            'answer': answer,
            'call_id': call_id
        }, room=caller_socket)


@socketio.on('webrtc_ice_candidate')
def handle_webrtc_ice_candidate(data):
    """Handle WebRTC ICE candidate"""
    receiver_id = data.get('receiver_id')
    candidate = data.get('candidate')
    call_id = data.get('call_id')
    
    if not receiver_id or not candidate:
        return
    
    # Get other party's socket
    other_socket = None
    for sid, uid in active_sockets.items():
        if uid == receiver_id:
            other_socket = sid
            break
    
    if other_socket:
        socketio.emit('webrtc_ice_candidate', {
            'candidate': candidate,
            'call_id': call_id
        }, room=other_socket)


# =====================
# SIGNATURE API ROUTES
# =====================

@app.route('/api/signature/save', methods=['POST'])
@login_required
def api_signature_save():
    """Save a drawn signature for the current user"""
    try:
        data = request.get_json()
        signature_data = data.get('signature_data')
        signature_type = data.get('signature_type', 'admin')
        
        if not signature_data:
            return jsonify({'success': False, 'error': 'No signature data provided'}), 400
        
        # Check if user already has an active signature
        existing = DrawnSignature.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if existing:
            # Update existing signature
            existing.signature_data = signature_data
            existing.signature_type = signature_type
            existing.updated_at = get_eat_now()
        else:
            # Create new signature
            signature = DrawnSignature(
                user_id=current_user.id,
                signature_data=signature_data,
                signature_type=signature_type
            )
            db.session.add(signature)
        
        db.session.commit()
        return jsonify({'success': True, 'message': 'Signature saved successfully'})
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/signature/load', methods=['GET'])
@login_required
def api_signature_load():
    """Load the active signature for the current user"""
    try:
        signature = DrawnSignature.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if signature:
            return jsonify({
                'success': True,
                'signature_data': signature.signature_data,
                'signature_type': signature.signature_type,
                'created_at': signature.created_at.isoformat(),
                'updated_at': signature.updated_at.isoformat()
            })
        else:
            return jsonify({'success': True, 'signature_data': None})
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/signature/delete', methods=['POST'])
@login_required
def api_signature_delete():
    """Delete the active signature for the current user"""
    try:
        signature = DrawnSignature.query.filter_by(
            user_id=current_user.id,
            is_active=True
        ).first()
        
        if signature:
            signature.is_active = False
            db.session.commit()
            return jsonify({'success': True, 'message': 'Signature deleted successfully'})
        else:
            return jsonify({'success': False, 'error': 'No active signature found'}), 404
    
    except Exception as e:
        db.session.rollback()
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/signature/<int:user_id>', methods=['GET'])
@login_required
def api_signature_get(user_id):
    """Get signature for a specific user (for admin use)"""
    try:
        # Only allow admins to view other users' signatures
        if current_user.role != 'admin' and current_user.id != user_id:
            return jsonify({'success': False, 'error': 'Unauthorized'}), 403
        
        signature = DrawnSignature.query.filter_by(
            user_id=user_id,
            is_active=True
        ).first()
        
        if signature:
            return jsonify({
                'success': True,
                'signature_data': signature.signature_data,
                'signature_type': signature.signature_type
            })
        else:
            return jsonify({'success': True, 'signature_data': None})
    
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


if __name__ == '__main__':

    if not os.path.exists('instance'):
        os.makedirs('instance')
    if not os.path.exists(app.config['UPLOAD_FOLDER']):
        os.makedirs(app.config['UPLOAD_FOLDER'])
    if not os.path.exists(app.config['BACKUP_FOLDER']):
        os.makedirs(app.config['BACKUP_FOLDER'])

    # Ensure DB and tables exist before serving any requests.
    if app.config.get('DEBUG'):
        print("=" * 60)
        print("🚀 DEBUG MODE: Fast startup enabled")
        print("   - Skipping detailed database checks")
        print("   - Skipping background schedulers")
        print("   - Skipping email configuration warnings")
        print("   - Skipping API key validation")
        print("=" * 60)
    
    initialize_database()

    # Initialize login manager
    login_manager = LoginManager()
    login_manager.init_app(app)
    login_manager.login_view = 'auth.login'
    login_manager.login_message_category = 'info'

    @login_manager.user_loader
    def load_user(user_id):
        return db.session.get(User, int(user_id))

    if os.environ.get('RENDER'):
        # Production - use gunicorn or platform-provided process manager
        app.logger.info("Production mode - ready for gunicorn")
    else:
        # Development - start Flask server with Socket.IO support
        app.logger.info("Development mode - starting Flask server with Socket.IO")

        host = '0.0.0.0'
        port = int(os.environ.get('PORT', 5000))

        app.logger.info(f"Starting server on {host}:{port} (DEBUG={app.config.get('DEBUG', False)})")
        print(f"Starting server on {host}:{port} (DEBUG={app.config.get('DEBUG', False)})")
        socketio.run(app, host=host, port=port, debug=app.config.get('DEBUG', False), allow_unsafe_werkzeug=True)